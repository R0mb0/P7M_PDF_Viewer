(()=>{var Bd=Object.create;var Yh=Object.defineProperty;var Pd=Object.getOwnPropertyDescriptor;var jd=Object.getOwnPropertyNames;var xd=Object.getPrototypeOf,Od=Object.prototype.hasOwnProperty;var Rd=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),Gm=(n,e)=>{for(var t in e)Yh(n,t,{get:e[t],enumerable:!0})},Td=(n,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of jd(e))!Od.call(n,a)&&a!==t&&Yh(n,a,{get:()=>e[a],enumerable:!(s=Pd(e,a))||s.enumerable});return n};var Qh=(n,e,t)=>(t=n!=null?Bd(xd(n)):{},Td(e||!n||!n.__esModule?Yh(t,"default",{value:n,enumerable:!0}):t,n));var Wu=Rd(Ga=>{"use strict";var Dd="[object ArrayBuffer]",Nt=class n{static isArrayBuffer(e){return Object.prototype.toString.call(e)===Dd}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){let s=n.toUint8Array(e),a=n.toUint8Array(t);if(s.length!==a.byteLength)return!1;for(let r=0;r<s.length;r++)if(s[r]!==a[r])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let s=0;for(let o of t)s+=o.byteLength;let a=new Uint8Array(s),r=0;for(let o of t){let u=this.toUint8Array(o);a.set(u,r),r+=u.length}return e[e.length-1]instanceof Function?this.toView(a,e[e.length-1]):a.buffer}},Xh="string",Ud=/^[0-9a-f\s]+$/i,Ld=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,Hd=/^[a-zA-Z0-9-_]+$/,Fu=class{static fromString(e){let t=unescape(encodeURIComponent(e)),s=new Uint8Array(t.length);for(let a=0;a<t.length;a++)s[a]=t.charCodeAt(a);return s.buffer}static toString(e){let t=Nt.toUint8Array(e),s="";for(let r=0;r<t.length;r++)s+=String.fromCharCode(t[r]);return decodeURIComponent(escape(s))}},We=class{static toString(e,t=!1){let s=Nt.toArrayBuffer(e),a=new DataView(s),r="";for(let o=0;o<s.byteLength;o+=2){let u=a.getUint16(o,t);r+=String.fromCharCode(u)}return r}static fromString(e,t=!1){let s=new ArrayBuffer(e.length*2),a=new DataView(s);for(let r=0;r<e.length;r++)a.setUint16(r*2,e.charCodeAt(r),t);return s}},Gu=class n{static isHex(e){return typeof e===Xh&&Ud.test(e)}static isBase64(e){return typeof e===Xh&&Ld.test(e)}static isBase64Url(e){return typeof e===Xh&&Hd.test(e)}static ToString(e,t="utf8"){let s=Nt.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(s);case"binary":return this.ToBinary(s);case"hex":return this.ToHex(s);case"base64":return this.ToBase64(s);case"base64url":return this.ToBase64Url(s);case"utf16le":return We.toString(s,!0);case"utf16":case"utf16be":return We.toString(s);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return We.fromString(e,!0);case"utf16":case"utf16be":return We.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){let t=Nt.toUint8Array(e);if(typeof btoa!="undefined"){let s=this.ToString(t,"binary");return btoa(s)}else return Buffer.from(t).toString("base64")}static FromBase64(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob!="undefined"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=n.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Fu.fromString(e);case"utf16":case"utf16be":return We.fromString(e);case"utf16le":case"usc2":return We.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=n.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Fu.toString(e);case"utf16":case"utf16be":return We.toString(e);case"utf16le":case"usc2":return We.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){let t=e.length,s=new Uint8Array(t);for(let a=0;a<t;a++)s[a]=e.charCodeAt(a);return s.buffer}static ToBinary(e){let t=Nt.toUint8Array(e),s="";for(let a=0;a<t.length;a++)s+=String.fromCharCode(t[a]);return s}static ToHex(e){let t=Nt.toUint8Array(e),s="",a=t.length;for(let r=0;r<a;r++){let o=t[r];o<16&&(s+="0"),s+=o.toString(16)}return s}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);let s=new Uint8Array(t.length/2);for(let a=0;a<t.length;a=a+2){let r=t.slice(a,a+2);s[a/2]=parseInt(r,16)}return s.buffer}static ToUtf16String(e,t=!1){return We.toString(e,t)}static FromUtf16String(e,t=!1){return We.fromString(e,t)}static Base64Padding(e){let t=4-e.length%4;if(t<4)for(let s=0;s<t;s++)e+="=";return e}static formatString(e){return(e==null?void 0:e.replace(/[\n\r\t ]/g,""))||""}};Gu.DEFAULT_UTF8_ENCODING="utf8";function _d(n,...e){let t=arguments[0];for(let s=1;s<arguments.length;s++){let a=arguments[s];for(let r in a)t[r]=a[r]}return t}function Kd(...n){let e=n.map(a=>a.byteLength).reduce((a,r)=>a+r),t=new Uint8Array(e),s=0;return n.map(a=>new Uint8Array(a)).forEach(a=>{for(let r of a)t[s++]=r}),t.buffer}function Md(n,e){if(!(n&&e)||n.byteLength!==e.byteLength)return!1;let t=new Uint8Array(n),s=new Uint8Array(e);for(let a=0;a<n.byteLength;a++)if(t[a]!==s[a])return!1;return!0}Ga.BufferSourceConverter=Nt;Ga.Convert=Gu;Ga.assign=_d;Ga.combine=Kd;Ga.isEqual=Md});var gc={};Gm(gc,{Any:()=>U,BaseBlock:()=>Ne,BaseStringBlock:()=>ao,BitString:()=>F,BmpString:()=>Bt,Boolean:()=>Ke,CharacterString:()=>An,Choice:()=>ie,Constructed:()=>p,DATE:()=>co,DateTime:()=>fo,Duration:()=>mo,EndOfContent:()=>ro,Enumerated:()=>Ze,GeneralString:()=>yn,GeneralizedTime:()=>re,GraphicString:()=>Sn,HexBlock:()=>ft,IA5String:()=>os,Integer:()=>w,Null:()=>le,NumericString:()=>ut,ObjectIdentifier:()=>O,OctetString:()=>I,Primitive:()=>D,PrintableString:()=>De,RawData:()=>us,RelativeObjectIdentifier:()=>uo,Repeated:()=>_,Sequence:()=>f,Set:()=>ue,TIME:()=>go,TeletexString:()=>jt,TimeOfDay:()=>ho,UTCTime:()=>ct,UniversalString:()=>Pt,Utf8String:()=>Te,ValueBlock:()=>Ie,VideotexString:()=>wn,ViewWriter:()=>Ya,VisibleString:()=>ls,compareSchema:()=>k,fromBER:()=>ve,verifySchema:()=>s1});var Y=Qh(Wu());function i(n,e,t){var s;return n instanceof Object&&(s=n[e])!==null&&s!==void 0?s:t}function Yu(n,e=0,t=n.byteLength-e,s=!1){let a="";for(let r of new Uint8Array(n,e,t)){let o=r.toString(16).toUpperCase();o.length===1&&(a+="0"),a+=o,s&&(a+=" ")}return a.trim()}function It(n,e){let t=0;if(n.length===1)return n[0];for(let s=n.length-1;s>=0;s--)t+=n[n.length-1-s]*Math.pow(2,e*s);return t}function ze(n,e,t=-1){let s=t,a=n,r=0,o=Math.pow(2,e);for(let u=1;u<8;u++){if(n<o){let l;if(s<0)l=new ArrayBuffer(u),r=u;else{if(s<u)return new ArrayBuffer(0);l=new ArrayBuffer(s),r=s}let h=new Uint8Array(l);for(let m=u-1;m>=0;m--){let g=Math.pow(2,m*e);h[r-m-1]=Math.floor(a/g),a-=h[r-m-1]*g}return l}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function pn(...n){let e=0,t=0;for(let r of n)e+=r.byteLength;let s=new ArrayBuffer(e),a=new Uint8Array(s);for(let r of n)a.set(new Uint8Array(r),t),t+=r.byteLength;return s}function Qu(...n){let e=0,t=0;for(let r of n)e+=r.length;let s=new ArrayBuffer(e),a=new Uint8Array(s);for(let r of n)a.set(r,t),t+=r.length;return a}function zh(){let n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let u=n[0]===255&&n[1]&128,l=n[0]===0&&(n[1]&128)===0;(u||l)&&this.warnings.push("Needlessly long format")}let e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let u=0;u<this.valueHex.byteLength;u++)t[u]=0;t[0]=n[0]&128;let s=It(t,8),a=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(a);for(let u=0;u<this.valueHex.byteLength;u++)r[u]=n[u];return r[0]&=127,It(r,8)-s}function Wm(n){let e=n<0?n*-1:n,t=128;for(let s=1;s<8;s++){if(e<=t){if(n<0){let o=t-e,u=ze(o,8,s),l=new Uint8Array(u);return l[0]|=128,u}let a=ze(e,8,s),r=new Uint8Array(a);if(r[0]&128){let o=a.slice(0),u=new Uint8Array(o);a=new ArrayBuffer(a.byteLength+1),r=new Uint8Array(a);for(let l=0;l<o.byteLength;l++)r[l+1]=u[l];r[0]=0}return a}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function is(n,e){if(n.byteLength!==e.byteLength)return!1;let t=new Uint8Array(n),s=new Uint8Array(e);for(let a=0;a<t.length;a++)if(t[a]!==s[a])return!1;return!0}function He(n,e){let t=n.toString(10);if(e<t.length)return"";let s=e-t.length,a=new Array(s);for(let o=0;o<s;o++)a[o]="0";return a.join("").concat(t)}var Ym="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Qm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function Xu(n,e=!1,t=!1,s=!1){let a=0,r=0,o=0,u="",l=e?Qm:Ym;if(s){let h=0;for(let m=0;m<n.length;m++)if(n.charCodeAt(m)!==0){h=m;break}n=n.slice(h)}for(;a<n.length;){let h=n.charCodeAt(a++);a>=n.length&&(r=1);let m=n.charCodeAt(a++);a>=n.length&&(o=1);let g=n.charCodeAt(a++),d=h>>2,b=(h&3)<<4|m>>4,y=(m&15)<<2|g>>6,E=g&63;r===1?y=E=64:o===1&&(E=64),t?y===64?u+=`${l.charAt(d)}${l.charAt(b)}`:E===64?u+=`${l.charAt(d)}${l.charAt(b)}${l.charAt(y)}`:u+=`${l.charAt(d)}${l.charAt(b)}${l.charAt(y)}${l.charAt(E)}`:u+=`${l.charAt(d)}${l.charAt(b)}${l.charAt(y)}${l.charAt(E)}`}return u}function Wa(n,e=!1,t=!1){let s=e?Qm:Ym;function a(l){for(let h=0;h<64;h++)if(s.charAt(h)===l)return h;return 64}function r(l){return l===64?0:l}let o=0,u="";for(;o<n.length;){let l=a(n.charAt(o++)),h=o>=n.length?0:a(n.charAt(o++)),m=o>=n.length?0:a(n.charAt(o++)),g=o>=n.length?0:a(n.charAt(o++)),d=r(l)<<2|r(h)>>4,b=(r(h)&15)<<4|r(m)>>2,y=(r(m)&3)<<6|r(g);u+=String.fromCharCode(d),m!==64&&(u+=String.fromCharCode(b)),g!==64&&(u+=String.fromCharCode(y))}if(t){let l=u.length,h=-1;for(let m=l-1;m>=0;m--)if(u.charCodeAt(m)!==0){h=m;break}h!==-1?u=u.slice(0,h+1):u=""}return u}function eo(n){let e="",t=new Uint8Array(n);for(let s of t)e+=String.fromCharCode(s);return e}function vn(n){let e=n.length,t=new ArrayBuffer(e),s=new Uint8Array(t);for(let a=0;a<e;a++)s[a]=n.charCodeAt(a);return t}var qd=Math.log(2);function Xm(n){let e=Math.log(n)/qd,t=Math.floor(e),s=Math.round(e);return t===s?t:s}function N(n,e){for(let t of e)delete n[t]}function zu(){if(typeof BigInt=="undefined")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function ef(n){let e=0,t=0;for(let a=0;a<n.length;a++){let r=n[a];e+=r.byteLength}let s=new Uint8Array(e);for(let a=0;a<n.length;a++){let r=n[a];s.set(new Uint8Array(r),t),t+=r.byteLength}return s.buffer}function xt(n,e,t,s){return e instanceof Uint8Array?e.byteLength?t<0?(n.error="Wrong parameter: inputOffset less than zero",!1):s<0?(n.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-s<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Ya=class{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return ef(this.items)}},to=[new Uint8Array([1])],Zm="0123456789",Zh="name",eg="valueHexView",$d="isHexOnly",Jd="idBlock",Fd="tagClass",Gd="tagNumber",Wd="isConstructed",Yd="fromBER",Qd="toBER",Xd="local",_e="",ht=new ArrayBuffer(0),mc=new Uint8Array(0),no="EndOfContent",sg="OCTET STRING",ng="BIT STRING";function ft(n){var e;return e=class extends n{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(s){this.valueHexView=new Uint8Array(s)}constructor(...s){var a;super(...s);let r=s[0]||{};this.isHexOnly=(a=r.isHexOnly)!==null&&a!==void 0?a:!1,this.valueHexView=r.valueHex?Y.BufferSourceConverter.toUint8Array(r.valueHex):mc}fromBER(s,a,r){let o=s instanceof ArrayBuffer?new Uint8Array(s):s;if(!xt(this,o,a,r))return-1;let u=a+r;return this.valueHexView=o.subarray(a,u),this.valueHexView.length?(this.blockLength=r,u):(this.warnings.push("Zero buffer length"),a)}toBER(s=!1){return this.isHexOnly?s?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",ht)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:Y.Convert.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}var Vt=class{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t=_e,warnings:s=[],valueBeforeDecode:a=mc}={}){this.blockLength=e,this.error=t,this.warnings=s,this.valueBeforeDecodeView=Y.BufferSourceConverter.toUint8Array(a)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Y.Convert.ToHex(this.valueBeforeDecodeView)}}};Vt.NAME="baseBlock";var Ie=class extends Vt{fromBER(e,t,s){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Ie.NAME="valueBlock";var Zu=class extends ft(Vt){constructor({idBlock:e={}}={}){var t,s,a,r;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?Y.BufferSourceConverter.toUint8Array(e.valueHex):mc,this.tagClass=(s=e.tagClass)!==null&&s!==void 0?s:-1,this.tagNumber=(a=e.tagNumber)!==null&&a!==void 0?a:-1,this.isConstructed=(r=e.isConstructed)!==null&&r!==void 0?r:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",ht}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){let a=new Uint8Array(1);if(!e){let r=this.tagNumber;r&=31,t|=r,a[0]=t}return a.buffer}if(!this.isHexOnly){let a=ze(this.tagNumber,7),r=new Uint8Array(a),o=a.byteLength,u=new Uint8Array(o+1);if(u[0]=t|31,!e){for(let l=0;l<o-1;l++)u[l+1]=r[l]|128;u[o]=r[o-1]}return u.buffer}let s=new Uint8Array(this.valueHexView.byteLength+1);if(s[0]=t|31,!e){let a=this.valueHexView;for(let r=0;r<a.length-1;r++)s[r+1]=a[r]|128;s[this.valueHexView.byteLength]=a[a.length-1]}return s.buffer}fromBER(e,t,s){let a=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,a,t,s))return-1;let r=a.subarray(t,t+s);if(r.length===0)return this.error="Zero buffer length",-1;switch(r[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(r[0]&32)===32,this.isHexOnly=!1;let u=r[0]&31;if(u!==31)this.tagNumber=u,this.blockLength=1;else{let l=1,h=this.valueHexView=new Uint8Array(255),m=255;for(;r[l]&128;){if(h[l-1]=r[l]&127,l++,l>=r.length)return this.error="End of input reached before message was fully decoded",-1;if(l===m){m+=255;let d=new Uint8Array(m);for(let b=0;b<h.length;b++)d[b]=h[b];h=this.valueHexView=new Uint8Array(m)}}this.blockLength=l+1,h[l-1]=r[l]&127;let g=new Uint8Array(l);for(let d=0;d<l;d++)g[d]=h[d];h=this.valueHexView=new Uint8Array(l),h.set(g),this.blockLength<=9?this.tagNumber=It(h,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};Zu.NAME="identificationBlock";var ec=class extends Vt{constructor({lenBlock:e={}}={}){var t,s,a;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(s=e.longFormUsed)!==null&&s!==void 0?s:!1,this.length=(a=e.length)!==null&&a!==void 0?a:0}fromBER(e,t,s){let a=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,a,t,s))return-1;let r=a.subarray(t,t+s);if(r.length===0)return this.error="Zero buffer length",-1;if(r[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=r[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(r[0]&128),this.longFormUsed===!1)return this.length=r[0],this.blockLength=1,t+this.blockLength;let o=r[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>r.length)return this.error="End of input reached before message was fully decoded",-1;let u=t+1,l=a.subarray(u,u+o);return l[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=It(l,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,s;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(s=new Uint8Array(t),s[0]=128),t;if(this.longFormUsed){let a=ze(this.length,8);if(a.byteLength>127)return this.error="Too big length",ht;if(t=new ArrayBuffer(a.byteLength+1),e)return t;let r=new Uint8Array(a);s=new Uint8Array(t),s[0]=a.byteLength|128;for(let o=0;o<a.byteLength;o++)s[o+1]=r[o];return t}return t=new ArrayBuffer(1),e===!1&&(s=new Uint8Array(t),s[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};ec.NAME="lengthBlock";var R={},Ne=class extends Vt{constructor({name:e=_e,optional:t=!1,primitiveSchema:s,...a}={},r){super(a),this.name=e,this.optional=t,s&&(this.primitiveSchema=s),this.idBlock=new Zu(a),this.lenBlock=new ec(a),this.valueBlock=r?new r(a):new Ie(a)}fromBER(e,t,s){let a=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return a===-1?(this.error=this.valueBlock.error,a):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),a)}toBER(e,t){let s=t||new Ya;t||ag(this);let a=this.idBlock.toBER(e);if(s.write(a),this.lenBlock.isIndefiniteForm)s.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,s),s.write(new ArrayBuffer(2));else{let r=this.valueBlock.toBER(e);this.lenBlock.length=r.byteLength;let o=this.lenBlock.toBER(e);s.write(o),s.write(r)}return t?ht:s.final()}toJSON(){let e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():Y.Convert.ToHex(this.toBER())}onAsciiEncoding(){let e=this.constructor.NAME,t=Y.Convert.ToHex(this.valueBlock.valueBeforeDecodeView);return`${e} : ${t}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;let t=this.toBER(),s=e.toBER();return is(t,s)}};Ne.NAME="BaseBlock";function ag(n){var e;if(n instanceof R.Constructed)for(let t of n.valueBlock.value)ag(t)&&(n.lenBlock.isIndefiniteForm=!0);return!!(!((e=n.lenBlock)===null||e===void 0)&&e.isIndefiniteForm)}var ao=class extends Ne{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e=_e,...t}={},s){super(t,s),e&&this.fromString(e)}fromBER(e,t,s){let a=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return a===-1?(this.error=this.valueBlock.error,a):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),a)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};ao.NAME="BaseStringBlock";var tc=class extends ft(Ie){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}};tc.NAME="PrimitiveValueBlock";var rg,D=class extends Ne{constructor(e={}){super(e,tc),this.idBlock.isConstructed=!1}};rg=D;R.Primitive=rg;D.NAME="PRIMITIVE";function zd(n,e){if(n instanceof e)return n;let t=new e;return t.idBlock=n.idBlock,t.lenBlock=n.lenBlock,t.warnings=n.warnings,t.valueBeforeDecodeView=n.valueBeforeDecodeView,t}function Qa(n,e=0,t=n.length){let s=e,a=new Ne({},Ie),r=new Vt;if(!xt(r,n,e,t))return a.error=r.error,{offset:-1,result:a};if(!n.subarray(e,e+t).length)return a.error="Zero buffer length",{offset:-1,result:a};let u=a.idBlock.fromBER(n,e,t);if(a.idBlock.warnings.length&&a.warnings.concat(a.idBlock.warnings),u===-1)return a.error=a.idBlock.error,{offset:-1,result:a};if(e=u,t-=a.idBlock.blockLength,u=a.lenBlock.fromBER(n,e,t),a.lenBlock.warnings.length&&a.warnings.concat(a.lenBlock.warnings),u===-1)return a.error=a.lenBlock.error,{offset:-1,result:a};if(e=u,t-=a.lenBlock.blockLength,!a.idBlock.isConstructed&&a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let l=Ne;switch(a.idBlock.tagClass){case 1:if(a.idBlock.tagNumber>=37&&a.idBlock.isHexOnly===!1)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};l=R.EndOfContent;break;case 1:l=R.Boolean;break;case 2:l=R.Integer;break;case 3:l=R.BitString;break;case 4:l=R.OctetString;break;case 5:l=R.Null;break;case 6:l=R.ObjectIdentifier;break;case 10:l=R.Enumerated;break;case 12:l=R.Utf8String;break;case 13:l=R.RelativeObjectIdentifier;break;case 14:l=R.TIME;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:l=R.Sequence;break;case 17:l=R.Set;break;case 18:l=R.NumericString;break;case 19:l=R.PrintableString;break;case 20:l=R.TeletexString;break;case 21:l=R.VideotexString;break;case 22:l=R.IA5String;break;case 23:l=R.UTCTime;break;case 24:l=R.GeneralizedTime;break;case 25:l=R.GraphicString;break;case 26:l=R.VisibleString;break;case 27:l=R.GeneralString;break;case 28:l=R.UniversalString;break;case 29:l=R.CharacterString;break;case 30:l=R.BmpString;break;case 31:l=R.DATE;break;case 32:l=R.TimeOfDay;break;case 33:l=R.DateTime;break;case 34:l=R.Duration;break;default:{let h=a.idBlock.isConstructed?new R.Constructed:new R.Primitive;h.idBlock=a.idBlock,h.lenBlock=a.lenBlock,h.warnings=a.warnings,a=h}}break;case 2:case 3:case 4:default:l=a.idBlock.isConstructed?R.Constructed:R.Primitive}return a=zd(a,l),u=a.fromBER(n,e,a.lenBlock.isIndefiniteForm?t:a.lenBlock.length),a.valueBeforeDecodeView=n.subarray(s,s+a.blockLength),{offset:u,result:a}}function ve(n){if(!n.byteLength){let e=new Ne({},Ie);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Qa(Y.BufferSourceConverter.toUint8Array(n).slice(),0,n.byteLength)}function Zd(n,e){return n?1:e}var lt=class extends Ie{constructor({value:e=[],isIndefiniteForm:t=!1,...s}={}){super(s),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,s){let a=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,a,t,s))return-1;if(this.valueBeforeDecodeView=a.subarray(t,t+s),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let r=t;for(;Zd(this.isIndefiniteForm,s)>0;){let o=Qa(a,r,s);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(r=o.offset,this.blockLength+=o.result.blockLength,s-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===no)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===no?this.value.pop():this.warnings.push("No EndOfContent block encoded")),r}toBER(e,t){let s=t||new Ya;for(let a=0;a<this.value.length;a++)this.value[a].toBER(e,s);return t?ht:s.final()}toJSON(){let e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let t of this.value)e.value.push(t.toJSON());return e}};lt.NAME="ConstructedValueBlock";var ig,p=class extends Ne{constructor(e={}){super(e,lt),this.idBlock.isConstructed=!0}fromBER(e,t,s){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let a=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return a===-1?(this.error=this.valueBlock.error,a):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),a)}onAsciiEncoding(){let e=[];for(let s of this.valueBlock.value)e.push(s.toString("ascii").split(`
`).map(a=>`  ${a}`).join(`
`));let t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}};ig=p;R.Constructed=ig;p.NAME="CONSTRUCTED";var sc=class extends Ie{fromBER(e,t,s){return t}toBER(e){return ht}};sc.override="EndOfContentValueBlock";var og,ro=class extends Ne{constructor(e={}){super(e,sc),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}};og=ro;R.EndOfContent=og;ro.NAME=no;var lg,le=class extends Ne{constructor(e={}){super(e,Ie),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,s){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=s,t+s>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+s}toBER(e,t){let s=new ArrayBuffer(2);if(!e){let a=new Uint8Array(s);a[0]=5,a[1]=0}return t&&t.write(s),s}onAsciiEncoding(){return`${this.constructor.NAME}`}};lg=le;R.Null=lg;le.NAME="NULL";var nc=class extends ft(Ie){get value(){for(let e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=Y.BufferSourceConverter.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,s){let a=Y.BufferSourceConverter.toUint8Array(e);return xt(this,a,t,s)?(this.valueHexView=a.subarray(t,t+s),s>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,zh.call(this),this.blockLength=s,t+s):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}};nc.NAME="BooleanValueBlock";var ug,Ke=class extends Ne{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,nc),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};ug=Ke;R.Boolean=ug;Ke.NAME="BOOLEAN";var ac=class extends ft(lt){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,s){let a=0;if(this.isConstructed){if(this.isHexOnly=!1,a=lt.prototype.fromBER.call(this,e,t,s),a===-1)return a;for(let r=0;r<this.value.length;r++){let o=this.value[r].constructor.NAME;if(o===no){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==sg)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,a=super.fromBER(e,t,s),this.blockLength=s;return a}toBER(e,t){return this.isConstructed?lt.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}};ac.NAME="OctetStringValueBlock";var tf,I=class extends Ne{constructor({idBlock:e={},lenBlock:t={},...s}={}){var a,r;(a=s.isConstructed)!==null&&a!==void 0||(s.isConstructed=!!(!((r=s.value)===null||r===void 0)&&r.length)),super({idBlock:{isConstructed:s.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!s.isIndefiniteForm},...s},ac),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,s){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,s===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){let r=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+s);try{if(r.byteLength){let o=Qa(r,0,r.byteLength);o.offset!==-1&&o.offset===s&&(this.valueBlock.value=[o.result])}}catch(o){}}return super.fromBER(e,t,s)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return p.prototype.onAsciiEncoding.call(this);let e=this.constructor.NAME,t=Y.Convert.ToHex(this.valueBlock.valueHexView);return`${e} : ${t}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;let e=[];for(let t of this.valueBlock.value)t instanceof tf&&e.push(t.valueBlock.valueHexView);return Y.BufferSourceConverter.concat(e)}};tf=I;R.OctetString=tf;I.NAME=sg;var rc=class extends ft(lt){constructor({unusedBits:e=0,isConstructed:t=!1,...s}={}){super(s),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,s){if(!s)return t;let a=-1;if(this.isConstructed){if(a=lt.prototype.fromBER.call(this,e,t,s),a===-1)return a;for(let u of this.value){let l=u.constructor.NAME;if(l===no){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(l!==ng)return this.error="BIT STRING may consists of BIT STRINGs only",-1;let h=u.valueBlock;if(this.unusedBits>0&&h.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=h.unusedBits}return a}let r=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,r,t,s))return-1;let o=r.subarray(t,t+s);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){let u=o.subarray(1);try{if(u.byteLength){let l=Qa(u,0,u.byteLength);l.offset!==-1&&l.offset===s-1&&(this.value=[l.result])}}catch(l){}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+s}toBER(e,t){if(this.isConstructed)return lt.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength){let a=new Uint8Array(1);return a[0]=0,a.buffer}let s=new Uint8Array(this.valueHexView.length+1);return s[0]=this.unusedBits,s.set(this.valueHexView,1),s.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}};rc.NAME="BitStringValueBlock";var cg,F=class extends Ne{constructor({idBlock:e={},lenBlock:t={},...s}={}){var a,r;(a=s.isConstructed)!==null&&a!==void 0||(s.isConstructed=!!(!((r=s.value)===null||r===void 0)&&r.length)),super({idBlock:{isConstructed:s.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!s.isIndefiniteForm},...s},rc),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,s){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,s)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return p.prototype.onAsciiEncoding.call(this);{let e=[],t=this.valueBlock.valueHexView;for(let o of t)e.push(o.toString(2).padStart(8,"0"));let s=e.join(""),a=this.constructor.NAME,r=s.substring(0,s.length-this.valueBlock.unusedBits);return`${a} : ${r}`}}};cg=F;R.BitString=cg;F.NAME=ng;var hg;function e1(n,e){let t=new Uint8Array([0]),s=new Uint8Array(n),a=new Uint8Array(e),r=s.slice(0),o=r.length-1,u=a.slice(0),l=u.length-1,h=0,m=l<o?o:l,g=0;for(let d=m;d>=0;d--,g++){switch(!0){case g<u.length:h=r[o-g]+u[l-g]+t[0];break;default:h=r[o-g]+t[0]}switch(t[0]=h/10,!0){case g>=r.length:r=Qu(new Uint8Array([h%10]),r);break;default:r[o-g]=h%10}}return t[0]>0&&(r=Qu(t,r)),r}function tg(n){if(n>=to.length)for(let e=to.length;e<=n;e++){let t=new Uint8Array([0]),s=to[e-1].slice(0);for(let a=s.length-1;a>=0;a--){let r=new Uint8Array([(s[a]<<1)+t[0]]);t[0]=r[0]/10,s[a]=r[0]%10}t[0]>0&&(s=Qu(t,s)),to.push(s)}return to[n]}function t1(n,e){let t=0,s=new Uint8Array(n),a=new Uint8Array(e),r=s.slice(0),o=r.length-1,u=a.slice(0),l=u.length-1,h,m=0;for(let g=l;g>=0;g--,m++)switch(h=r[o-m]-u[l-m]-t,!0){case h<0:t=1,r[o-m]=h+10;break;default:t=0,r[o-m]=h}if(t>0)for(let g=o-l+1;g>=0;g--,m++)if(h=r[o-m]-t,h<0)t=1,r[o-m]=h+10;else{t=0,r[o-m]=h;break}return r.slice()}var io=class extends ft(Ie){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=zh.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(Wm(e))}get valueDec(){return this._valueDec}fromDER(e,t,s,a=0){let r=this.fromBER(e,t,s);if(r===-1)return r;let o=this.valueHexView;return o[0]===0&&(o[1]&128)!==0?this.valueHexView=o.subarray(1):a!==0&&o.length<a&&(a-o.length>1&&(a=o.length+1),this.valueHexView=o.subarray(a-o.length)),r}toDER(e=!1){let t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{let s=new Uint8Array(this.valueHexView.length+1);s[0]=0,s.set(t,1),this.valueHexView=s}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,s){let a=super.fromBER(e,t,s);return a===-1||this.setValueHex(),a}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){let e=this.valueHexView.length*8-1,t=new Uint8Array(this.valueHexView.length*8/3),s=0,a,r=this.valueHexView,o="",u=!1;for(let l=r.byteLength-1;l>=0;l--){a=r[l];for(let h=0;h<8;h++){if((a&1)===1)switch(s){case e:t=t1(tg(s),t),o="-";break;default:t=e1(t,tg(s))}s++,a>>=1}}for(let l=0;l<t.length;l++)t[l]&&(u=!0),u&&(o+=Zm.charAt(t[l]));return u===!1&&(o+=Zm.charAt(0)),o}};hg=io;io.NAME="IntegerValueBlock";Object.defineProperty(hg.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var so,w=class extends Ne{constructor(e={}){super(e,io),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return zu(),BigInt(this.valueBlock.toString())}static fromBigInt(e){zu();let t=BigInt(e),s=new Ya,a=t.toString(16).replace(/^-/,""),r=new Uint8Array(Y.Convert.FromHex(a));if(t<0){let u=new Uint8Array(r.length+(r[0]&128?1:0));u[0]|=128;let h=BigInt(`0x${Y.Convert.ToHex(u)}`)+t,m=Y.BufferSourceConverter.toUint8Array(Y.Convert.FromHex(h.toString(16)));m[0]|=128,s.write(m)}else r[0]&128&&s.write(new Uint8Array([0])),s.write(r);return new so({valueHex:s.final()})}convertToDER(){let e=new so({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new so({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}};so=w;R.Integer=so;w.NAME="INTEGER";var fg,Ze=class extends w{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}};fg=Ze;R.Enumerated=fg;Ze.NAME="ENUMERATED";var oo=class extends ft(Ie){constructor({valueDec:e=-1,isFirstSid:t=!1,...s}={}){super(s),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,s){if(!s)return t;let a=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,a,t,s))return-1;let r=a.subarray(t,t+s);this.valueHexView=new Uint8Array(s);for(let u=0;u<s&&(this.valueHexView[u]=r[u]&127,this.blockLength++,(r[u]&128)!==0);u++);let o=new Uint8Array(this.blockLength);for(let u=0;u<this.blockLength;u++)o[u]=this.valueHexView[u];return this.valueHexView=o,(r[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=It(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){zu();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;let s=new Uint8Array(t.length/7);for(let a=0;a<s.length;a++)s[a]=parseInt(t.slice(a*7,a*7+7),2)+(a+1<s.length?128:0);this.fromBER(s.buffer,0,s.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);let a=this.valueHexView,r=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)r[o]=a[o]|128;return r[this.blockLength-1]=a[this.blockLength-1],r.buffer}let t=ze(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ht;let s=new Uint8Array(t.byteLength);if(!e){let a=new Uint8Array(t),r=t.byteLength-1;for(let o=0;o<r;o++)s[o]=a[o]|128;s[r]=a[r]}return s}toString(){let e="";if(this.isHexOnly)e=Y.Convert.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}};oo.NAME="sidBlock";var ic=class extends Ie{constructor({value:e=_e,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,s){let a=t;for(;s>0;){let r=new oo;if(a=r.fromBER(e,a,s),a===-1)return this.blockLength=0,this.error=r.error,a;this.value.length===0&&(r.isFirstSid=!0),this.blockLength+=r.blockLength,s-=r.blockLength,this.value.push(r)}return a}toBER(e){let t=[];for(let s=0;s<this.value.length;s++){let a=this.value[s].toBER(e);if(a.byteLength===0)return this.error=this.value[s].error,ht;t.push(a)}return ef(t)}fromString(e){this.value=[];let t=0,s=0,a="",r=!1;do if(s=e.indexOf(".",t),s===-1?a=e.substring(t):a=e.substring(t,s),t=s+1,r){let o=this.value[0],u=0;switch(o.valueDec){case 0:break;case 1:u=40;break;case 2:u=80;break;default:this.value=[];return}let l=parseInt(a,10);if(isNaN(l))return;o.valueDec=l+u,r=!1}else{let o=new oo;if(a>Number.MAX_SAFE_INTEGER){zu();let u=BigInt(a);o.valueBigInt=u}else if(o.valueDec=parseInt(a,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,r=!0),this.value.push(o)}while(s!==-1)}toString(){let e="",t=!1;for(let s=0;s<this.value.length;s++){t=this.value[s].isHexOnly;let a=this.value[s].toString();s!==0&&(e=`${e}.`),t?(a=`{${a}}`,this.value[s].isFirstSid?e=`2.{${a} - 80}`:e+=a):e+=a}return e}toJSON(){let e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}};ic.NAME="ObjectIdentifierValueBlock";var mg,O=class extends Ne{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,ic),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};mg=O;R.ObjectIdentifier=mg;O.NAME="OBJECT IDENTIFIER";var lo=class extends ft(Vt){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,s){if(s===0)return t;let a=Y.BufferSourceConverter.toUint8Array(e);if(!xt(this,a,t,s))return-1;let r=a.subarray(t,t+s);this.valueHexView=new Uint8Array(s);for(let u=0;u<s&&(this.valueHexView[u]=r[u]&127,this.blockLength++,(r[u]&128)!==0);u++);let o=new Uint8Array(this.blockLength);for(let u=0;u<this.blockLength;u++)o[u]=this.valueHexView[u];return this.valueHexView=o,(r[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=It(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);let a=this.valueHexView,r=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)r[o]=a[o]|128;return r[this.blockLength-1]=a[this.blockLength-1],r.buffer}let t=ze(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ht;let s=new Uint8Array(t.byteLength);if(!e){let a=new Uint8Array(t),r=t.byteLength-1;for(let o=0;o<r;o++)s[o]=a[o]|128;s[r]=a[r]}return s.buffer}toString(){let e="";return this.isHexOnly?e=Y.Convert.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}};lo.NAME="relativeSidBlock";var oc=class extends Ie{constructor({value:e=_e,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,s){let a=t;for(;s>0;){let r=new lo;if(a=r.fromBER(e,a,s),a===-1)return this.blockLength=0,this.error=r.error,a;this.blockLength+=r.blockLength,s-=r.blockLength,this.value.push(r)}return a}toBER(e,t){let s=[];for(let a=0;a<this.value.length;a++){let r=this.value[a].toBER(e);if(r.byteLength===0)return this.error=this.value[a].error,ht;s.push(r)}return ef(s)}fromString(e){this.value=[];let t=0,s=0,a="";do{s=e.indexOf(".",t),s===-1?a=e.substring(t):a=e.substring(t,s),t=s+1;let r=new lo;if(r.valueDec=parseInt(a,10),isNaN(r.valueDec))return!0;this.value.push(r)}while(s!==-1);return!0}toString(){let e="",t=!1;for(let s=0;s<this.value.length;s++){t=this.value[s].isHexOnly;let a=this.value[s].toString();s!==0&&(e=`${e}.`),t&&(a=`{${a}}`),e+=a}return e}toJSON(){let e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}};oc.NAME="RelativeObjectIdentifierValueBlock";var gg,uo=class extends Ne{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,oc),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};gg=uo;R.RelativeObjectIdentifier=gg;uo.NAME="RelativeObjectIdentifier";var dg,f=class extends p{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}};dg=f;R.Sequence=dg;f.NAME="SEQUENCE";var pg,ue=class extends p{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};pg=ue;R.Set=pg;ue.NAME="SET";var lc=class extends ft(Ie){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=_e}toJSON(){return{...super.toJSON(),value:this.value}}};lc.NAME="StringValueBlock";var uc=class extends lc{};uc.NAME="SimpleStringValueBlock";var Re=class extends ao{constructor({...e}={}){super(e,uc)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,Y.BufferSourceConverter.toUint8Array(e))}fromString(e){let t=e.length,s=this.valueBlock.valueHexView=new Uint8Array(t);for(let a=0;a<t;a++)s[a]=e.charCodeAt(a);this.valueBlock.value=e}};Re.NAME="SIMPLE STRING";var cc=class extends Re{fromBuffer(e){this.valueBlock.valueHexView=Y.BufferSourceConverter.toUint8Array(e);try{this.valueBlock.value=Y.Convert.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=Y.Convert.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(Y.Convert.FromUtf8String(e)),this.valueBlock.value=e}};cc.NAME="Utf8StringValueBlock";var vg,Te=class extends cc{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}};vg=Te;R.Utf8String=vg;Te.NAME="UTF8String";var hc=class extends Re{fromBuffer(e){this.valueBlock.value=Y.Convert.ToUtf16String(e),this.valueBlock.valueHexView=Y.BufferSourceConverter.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(Y.Convert.FromUtf16String(e))}};hc.NAME="BmpStringValueBlock";var wg,Bt=class extends hc{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}};wg=Bt;R.BmpString=wg;Bt.NAME="BMPString";var fc=class extends Re{fromBuffer(e){let t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),s=new Uint8Array(t);for(let a=0;a<s.length;a+=4)s[a]=s[a+3],s[a+1]=s[a+2],s[a+2]=0,s[a+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){let t=e.length,s=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let a=0;a<t;a++){let r=ze(e.charCodeAt(a),8),o=new Uint8Array(r);if(o.length>4)continue;let u=4-o.length;for(let l=o.length-1;l>=0;l--)s[a*4+l+u]=o[l]}this.valueBlock.value=e}};fc.NAME="UniversalStringValueBlock";var Sg,Pt=class extends fc{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}};Sg=Pt;R.UniversalString=Sg;Pt.NAME="UniversalString";var yg,ut=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}};yg=ut;R.NumericString=yg;ut.NAME="NumericString";var Ag,De=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}};Ag=De;R.PrintableString=Ag;De.NAME="PrintableString";var bg,jt=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}};bg=jt;R.TeletexString=bg;jt.NAME="TeletexString";var Cg,wn=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}};Cg=wn;R.VideotexString=Cg;wn.NAME="VideotexString";var kg,os=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}};kg=os;R.IA5String=kg;os.NAME="IA5String";var Eg,Sn=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}};Eg=Sn;R.GraphicString=Eg;Sn.NAME="GraphicString";var Ng,ls=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}};Ng=ls;R.VisibleString=Ng;ls.NAME="VisibleString";var Ig,yn=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}};Ig=yn;R.GeneralString=Ig;yn.NAME="GeneralString";var Vg,An=class extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}};Vg=An;R.CharacterString=Vg;An.NAME="CharacterString";var Bg,ct=class extends ls{constructor({value:e,valueDate:t,...s}={}){if(super(s),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let a=0;a<e.length;a++)this.valueBlock.valueHexView[a]=e.charCodeAt(a)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,Y.BufferSourceConverter.toUint8Array(e)))}toBuffer(){let e=this.toString(),t=new ArrayBuffer(e.length),s=new Uint8Array(t);for(let a=0;a<e.length;a++)s[a]=e.charCodeAt(a);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){let s=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(s===null){this.error="Wrong input string for conversion";return}let a=parseInt(s[1],10);a>=50?this.year=1900+a:this.year=2e3+a,this.month=parseInt(s[2],10),this.day=parseInt(s[3],10),this.hour=parseInt(s[4],10),this.minute=parseInt(s[5],10),this.second=parseInt(s[6],10)}toString(e="iso"){if(e==="iso"){let t=new Array(7);return t[0]=He(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=He(this.month,2),t[2]=He(this.day,2),t[3]=He(this.hour,2),t[4]=He(this.minute,2),t[5]=He(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}};Bg=ct;R.UTCTime=Bg;ct.NAME="UTCTime";var Pg,re=class extends ct{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){let e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t=!1,s="",a="",r=0,o,u=0,l=0;if(e[e.length-1]==="Z")s=e.substring(0,e.length-1),t=!0;else{let g=new Number(e[e.length-1]);if(isNaN(g.valueOf()))throw new Error("Wrong input string for conversion");s=e}if(t){if(s.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(s.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let g=1,d=s.indexOf("+"),b="";if(d===-1&&(d=s.indexOf("-"),g=-1),d!==-1){if(b=s.substring(d+1),s=s.substring(0,d),b.length!==2&&b.length!==4)throw new Error("Wrong input string for conversion");let y=parseInt(b.substring(0,2),10);if(isNaN(y.valueOf()))throw new Error("Wrong input string for conversion");if(u=g*y,b.length===4){if(y=parseInt(b.substring(2,4),10),isNaN(y.valueOf()))throw new Error("Wrong input string for conversion");l=g*y}}}let h=s.indexOf(".");if(h===-1&&(h=s.indexOf(",")),h!==-1){let g=new Number(`0${s.substring(h)}`);if(isNaN(g.valueOf()))throw new Error("Wrong input string for conversion");r=g.valueOf(),a=s.substring(0,h)}else a=s;switch(!0){case a.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,h!==-1)throw new Error("Wrong input string for conversion");break;case a.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let g=60*r;this.minute=Math.floor(g),g=60*(g-this.minute),this.second=Math.floor(g),g=1e3*(g-this.second),this.millisecond=Math.floor(g)}break;case a.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let g=60*r;this.second=Math.floor(g),g=1e3*(g-this.second),this.millisecond=Math.floor(g)}break;case a.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let g=1e3*r;this.millisecond=Math.floor(g)}break;default:throw new Error("Wrong input string for conversion")}let m=o.exec(a);if(m===null)throw new Error("Wrong input string for conversion");for(let g=1;g<m.length;g++)switch(g){case 1:this.year=parseInt(m[g],10);break;case 2:this.month=parseInt(m[g],10);break;case 3:this.day=parseInt(m[g],10);break;case 4:this.hour=parseInt(m[g],10)+u;break;case 5:this.minute=parseInt(m[g],10)+l;break;case 6:this.second=parseInt(m[g],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){let g=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=g.getUTCFullYear(),this.month=g.getUTCMonth(),this.day=g.getUTCDay(),this.hour=g.getUTCHours(),this.minute=g.getUTCMinutes(),this.second=g.getUTCSeconds(),this.millisecond=g.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){let t=[];return t.push(He(this.year,4)),t.push(He(this.month,2)),t.push(He(this.day,2)),t.push(He(this.hour,2)),t.push(He(this.minute,2)),t.push(He(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(He(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}};Pg=re;R.GeneralizedTime=Pg;re.NAME="GeneralizedTime";var jg,co=class extends Te{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}};jg=co;R.DATE=jg;co.NAME="DATE";var xg,ho=class extends Te{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}};xg=ho;R.TimeOfDay=xg;ho.NAME="TimeOfDay";var Og,fo=class extends Te{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}};Og=fo;R.DateTime=Og;fo.NAME="DateTime";var Rg,mo=class extends Te{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}};Rg=mo;R.Duration=Rg;mo.NAME="Duration";var Tg,go=class extends Te{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}};Tg=go;R.TIME=Tg;go.NAME="TIME";var U=class{constructor({name:e=_e,optional:t=!1}={}){this.name=e,this.optional=t}},ie=class extends U{constructor({value:e=[],...t}={}){super(t),this.value=e}},_=class extends U{constructor({value:e=new U,local:t=!1,...s}={}){super(s),this.value=e,this.local=t}},us=class{get data(){return this.dataView.slice().buffer}set data(e){this.dataView=Y.BufferSourceConverter.toUint8Array(e)}constructor({data:e=mc}={}){this.dataView=Y.BufferSourceConverter.toUint8Array(e)}fromBER(e,t,s){let a=t+s;return this.dataView=Y.BufferSourceConverter.toUint8Array(e).subarray(t,a),a}toBER(e){return this.dataView.slice().buffer}};function k(n,e,t){if(t instanceof ie){for(let r of t.value)if(k(n,e,r).verified)return{verified:!0,result:n};{let r={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(Zh)&&(r.name=t.name),r}}if(t instanceof U)return t.hasOwnProperty(Zh)&&(n[t.name]=e),{verified:!0,result:n};if(!(n instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Jd in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Yd in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Qd in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};let s=t.idBlock.toBER(!1);if(s.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(s,0,s.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(Fd)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(Gd)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:n};if(t.idBlock.hasOwnProperty(Wd)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:n};if(!($d in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:n};if(t.idBlock.isHexOnly){if(!(eg in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};let r=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(r.length!==o.length)return{verified:!1,result:n};for(let u=0;u<r.length;u++)if(r[u]!==o[1])return{verified:!1,result:n}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&(n[t.name]=e)),t instanceof R.Constructed){let r=0,o={verified:!1,result:{error:"Unknown error"}},u=t.valueBlock.value.length;if(u>0&&t.valueBlock.value[0]instanceof _&&(u=e.valueBlock.value.length),u===0)return{verified:!0,result:n};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let l=!0;for(let h=0;h<t.valueBlock.value.length;h++)l=l&&(t.valueBlock.value[h].optional||!1);return l?{verified:!0,result:n}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&delete n[t.name]),n.error="Inconsistent object length",{verified:!1,result:n})}for(let l=0;l<u;l++)if(l-r>=e.valueBlock.value.length){if(t.valueBlock.value[l].optional===!1){let h={verified:!1,result:n};return n.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&(delete n[t.name],h.name=t.name)),h}}else if(t.valueBlock.value[0]instanceof _){if(o=k(n,e.valueBlock.value[l],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)r++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&delete n[t.name]),o;if(Zh in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let h={};Xd in t.valueBlock.value[0]&&t.valueBlock.value[0].local?h=e:h=n,typeof h[t.valueBlock.value[0].name]=="undefined"&&(h[t.valueBlock.value[0].name]=[]),h[t.valueBlock.value[0].name].push(e.valueBlock.value[l])}}else if(o=k(n,e.valueBlock.value[l-r],t.valueBlock.value[l]),o.verified===!1)if(t.valueBlock.value[l].optional)r++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&delete n[t.name]),o;if(o.verified===!1){let l={verified:!1,result:n};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&(delete n[t.name],l.name=t.name)),l}return{verified:!0,result:n}}if(t.primitiveSchema&&eg in e.valueBlock){let r=Qa(e.valueBlock.valueHexView);if(r.offset===-1){let o={verified:!1,result:r.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,_e),t.name&&(delete n[t.name],o.name=t.name)),o}return k(n,r.result,t.primitiveSchema)}return{verified:!0,result:n}}function s1(n,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};let t=Qa(Y.BufferSourceConverter.toUint8Array(n));return t.offset===-1?{verified:!1,result:t.result}:k(t.result,t.result,e)}var Fm={};Gm(Fm,{AbstractCryptoEngine:()=>kh,AccessDescription:()=>Bi,Accuracy:()=>dt,AlgorithmIdentifier:()=>S,AltName:()=>Pi,ArgumentError:()=>se,AsnError:()=>A,AttCertValidityPeriod:()=>yt,Attribute:()=>fe,AttributeCertificateInfoV1:()=>Ia,AttributeCertificateInfoV2:()=>Ba,AttributeCertificateV1:()=>Ra,AttributeCertificateV2:()=>rt,AttributeTypeAndValue:()=>Vi,AuthenticatedSafe:()=>Qi,AuthorityKeyIdentifier:()=>ji,BasicConstraints:()=>xi,BasicOCSPResponse:()=>hn,CAVersion:()=>Eu,CRLBag:()=>Hu,CRLDistributionPoints:()=>Ui,CertBag:()=>Du,CertID:()=>Oe,Certificate:()=>Pe,CertificateChainValidationEngine:()=>qu,CertificatePolicies:()=>Ti,CertificateRevocationList:()=>fn,CertificateSet:()=>bt,CertificateTemplate:()=>Ch,CertificationRequest:()=>Uh,ChainValidationCode:()=>en,ChainValidationError:()=>Qt,ContentInfo:()=>ce,CryptoEngine:()=>Oa,DigestInfo:()=>wt,DistributionPoint:()=>Di,ECCCMSSharedInfo:()=>Wi,ECNamedCurves:()=>it,ECPrivateKey:()=>Mi,ECPublicKey:()=>Xe,EncapsulatedContentInfo:()=>St,EncryptedContentInfo:()=>ke,EncryptedData:()=>mn,EnvelopedData:()=>Yi,ExtKeyUsage:()=>Nu,Extension:()=>Ue,ExtensionValueFactory:()=>Eh,Extensions:()=>Se,GeneralName:()=>ne,GeneralNames:()=>ye,GeneralSubtree:()=>nn,HASHED_MESSAGE:()=>sn,HASH_ALGORITHM:()=>tn,Holder:()=>Va,InfoAccess:()=>Li,IssuerAndSerialNumber:()=>be,IssuerSerial:()=>Je,IssuingDistributionPoint:()=>Iu,KEKIdentifier:()=>cn,KEKRecipientInfo:()=>_a,KeyAgreeRecipientIdentifier:()=>es,KeyAgreeRecipientInfo:()=>Ha,KeyBag:()=>nm,KeyTransRecipientInfo:()=>Ta,MICROS:()=>Wt,MILLIS:()=>Gt,MacData:()=>at,MessageImprint:()=>Me,NameConstraints:()=>Vu,OCSPRequest:()=>Lh,OCSPResponse:()=>Hh,ObjectDigestInfo:()=>At,OriginatorIdentifierOrKey:()=>ln,OriginatorInfo:()=>ja,OriginatorPublicKey:()=>Da,OtherCertificateFormat:()=>Pa,OtherKeyAttribute:()=>Ct,OtherPrimeInfo:()=>Ea,OtherRecipientInfo:()=>Gi,OtherRevocationInfoFormat:()=>rn,PBES2Params:()=>$i,PBKDF2Params:()=>Zt,PFX:()=>_h,PKCS8ShroudedKeyBag:()=>_u,PKIStatus:()=>pm,PKIStatusInfo:()=>an,POLICY_IDENTIFIER:()=>Ni,POLICY_QUALIFIERS:()=>Zs,ParameterError:()=>Q,PasswordRecipientinfo:()=>Ka,PkiObject:()=>C,PolicyConstraints:()=>Bu,PolicyInformation:()=>Ri,PolicyMapping:()=>Hi,PolicyMappings:()=>Pu,PolicyQualifierInfo:()=>Oi,PrivateKeyInfo:()=>ts,PrivateKeyUsagePeriod:()=>ju,PublicKeyInfo:()=>qe,QCStatement:()=>_i,QCStatements:()=>xu,RDN:()=>Mf,RSAESOAEPParams:()=>xa,RSAPrivateKey:()=>qi,RSAPublicKey:()=>Ki,RSASSAPSSParams:()=>Na,RecipientEncryptedKey:()=>La,RecipientEncryptedKeys:()=>un,RecipientIdentifier:()=>Mu,RecipientInfo:()=>pt,RecipientKeyIdentifier:()=>Ua,RelativeDistinguishedNames:()=>oe,Request:()=>Ma,ResponseBytes:()=>Xt,ResponseData:()=>Ye,RevocationInfoChoices:()=>on,RevokedCertificate:()=>Uu,SECONDS:()=>Ft,SafeBag:()=>Fi,SafeBagValueFactory:()=>Th,SafeContents:()=>zt,SecretBag:()=>Ku,Signature:()=>vt,SignedAndUnsignedAttributes:()=>Be,SignedCertificateTimestamp:()=>Ou,SignedCertificateTimestampList:()=>Ru,SignedData:()=>ss,SignedDataVerifyError:()=>Ce,SignerInfo:()=>qa,SingleResponse:()=>Xi,SubjectDirectoryAttributes:()=>Tu,TBSRequest:()=>Qe,TSTInfo:()=>$u,TYPE:()=>ki,TYPE_AND_VALUES:()=>vs,Time:()=>Ae,TimeStampReq:()=>Kh,TimeStampResp:()=>Mh,TimeType:()=>Xf,V2Form:()=>Ji,VALUE:()=>Ei,VALUE_BEFORE_DECODE:()=>Po,checkCA:()=>Hm,createCMSECDSASignature:()=>Nd,createECDSASignatureFromCMS:()=>Id,engine:()=>Om,getAlgorithmByOID:()=>Ep,getAlgorithmParameters:()=>kp,getCrypto:()=>q,getEngine:()=>Ed,getHashAlgorithm:()=>Np,getOIDByAlgorithm:()=>Cp,getRandomValues:()=>bp,id_AnyPolicy:()=>$e,id_AuthorityInfoAccess:()=>Fh,id_AuthorityKeyIdentifier:()=>Jh,id_BaseCRLNumber:()=>ld,id_BasicConstraints:()=>qh,id_CRLBag_X509CRL:()=>Ff,id_CRLDistributionPoints:()=>Em,id_CRLNumber:()=>od,id_CRLReason:()=>ud,id_CertBag_AttributeCertificate:()=>Jf,id_CertBag_SDSICertificate:()=>Sd,id_CertBag_X509Certificate:()=>$f,id_CertificateIssuer:()=>Cm,id_CertificatePolicies:()=>Nm,id_ContentType_Data:()=>Gh,id_ContentType_EncryptedData:()=>xm,id_ContentType_EnvelopedData:()=>jm,id_ContentType_SignedData:()=>Pm,id_ExtKeyUsage:()=>fd,id_FreshestCRL:()=>$h,id_InhibitAnyPolicy:()=>md,id_InvalidityDate:()=>cd,id_IssuerAltName:()=>Am,id_IssuingDistributionPoint:()=>bm,id_KeyUsage:()=>rd,id_MicrosoftAppPolicies:()=>hd,id_MicrosoftCaVersion:()=>pd,id_MicrosoftCertTemplateV1:()=>K1,id_MicrosoftCertTemplateV2:()=>dd,id_MicrosoftPrevCaCertHash:()=>M1,id_NameConstraints:()=>km,id_PKIX_OCSP_Basic:()=>Cu,id_PolicyConstraints:()=>Vm,id_PolicyMappings:()=>Im,id_PrivateKeyUsagePeriod:()=>id,id_QCStatements:()=>vd,id_SignedCertificateTimestampList:()=>Bm,id_SubjectAltName:()=>ym,id_SubjectDirectoryAttributes:()=>nd,id_SubjectInfoAccess:()=>gd,id_SubjectKeyIdentifier:()=>ad,id_ad:()=>Wh,id_ad_caIssuers:()=>q1,id_ad_ocsp:()=>$1,id_eContentType_TSTInfo:()=>wd,id_pkix:()=>yd,id_sha1:()=>J1,id_sha256:()=>F1,id_sha384:()=>G1,id_sha512:()=>W1,kdf:()=>Wf,setEngine:()=>Gf,stringPrep:()=>Yt,verifySCTsForCertificate:()=>Vp});var H=Qh(Wu()),Ii=Qh(Wu());var Ve=class n{constructor(e={}){if("view"in e)this.fromUint8Array(e.view);else if("buffer"in e)this.fromArrayBuffer(e.buffer);else if("string"in e)this.fromString(e.string);else if("hexstring"in e)this.fromHexString(e.hexstring);else if("length"in e&&e.length>0){if(this.length=e.length,e.stub)for(let t=0;t<this._view.length;t++)this._view[t]=e.stub}else this.length=0}set buffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this.view.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}fromUint8Array(e){this.fromArrayBuffer(new Uint8Array(e).buffer)}fromString(e){let t=e.length;this.length=t;for(let s=0;s<t;s++)this.view[s]=e.charCodeAt(s)}toString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let a=e;a<e+t;a++)s+=String.fromCharCode(this.view[a]);return s}fromHexString(e){let t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);let s=new Map;s.set("0",0),s.set("1",1),s.set("2",2),s.set("3",3),s.set("4",4),s.set("5",5),s.set("6",6),s.set("7",7),s.set("8",8),s.set("9",9),s.set("A",10),s.set("a",10),s.set("B",11),s.set("b",11),s.set("C",12),s.set("c",12),s.set("D",13),s.set("d",13),s.set("E",14),s.set("e",14),s.set("F",15),s.set("f",15);let a=0,r=0;for(let o=0;o<t;o++)o%2?(r|=s.get(e.charAt(o)),this.view[a]=r,a++):r=s.get(e.charAt(o))<<4}toHexString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let a=e;a<e+t;a++){let r=this.view[a].toString(16).toUpperCase();s=s+(r.length==1?"0":"")+r}return s}copy(e=0,t=this.length-e){if(!e&&!this.length)return new n;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new n({buffer:this._buffer.slice(e,e+t)})}slice(e=0,t=this.length){if(!e&&!this.length)return new n;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new n({buffer:this._buffer.slice(e,t)})}realloc(e){let t=new ArrayBuffer(e),s=new Uint8Array(t);e>this._view.length?s.set(this._view):s.set(new Uint8Array(this._buffer,0,e)),this._buffer=t,this._view=new Uint8Array(this._buffer)}append(e){let t=this.length,s=e.length,a=e._view.subarray();this.realloc(t+s),this._view.set(a,t)}insert(e,t=0,s=this.length-t){return t>this.length-1?!1:(s>this.length-t&&(s=this.length-t),s>e.length&&(s=e.length),s==e.length?this._view.set(e._view,t):this._view.set(e._view.subarray(0,s),t),!0)}isEqual(e){if(this.length!=e.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l=e.length;if(l>o)return-1;let h=[];for(let m=0;m<l;m++)h.push(e.view[m]);for(let m=0;m<=o-l;m++){let g=!0,d=u?r-l-m:r+m;for(let b=0;b<l;b++)if(this.view[b+d]!=h[b]){g=!1;break}if(g)return u?r-l-m:r+l+m}return-1}findFirstIn(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l={id:-1,position:u?0:r+o,length:0};for(let h=0;h<e.length;h++){let m=this.findPattern(e[h],r,o,u);if(m!=-1){let g=!1,d=e[h].length;u?m-d>=l.position-l.length&&(g=!0):m-d<=l.position-l.length&&(g=!0),g&&(l.position=m,l.id=h,l.length=d)}}return l}findAllIn(e,t,s){let{start:a,length:r}=this.prepareFindParameters(t,s),o=[],u={id:-1,position:a};do{let l=u.position;if(u=this.findFirstIn(e,u.position,r),u.id==-1)break;r-=u.position-l,o.push({id:u.id,position:u.position})}while(!0);return o}findAllPatternIn(e,t,s){let{start:a,length:r}=this.prepareFindParameters(t,s),o=[],u=e.length;if(u>r)return-1;let l=Array.from(e.view);for(let h=0;h<=r-u;h++){let m=!0,g=a+h;for(let d=0;d<u;d++)if(this.view[d+g]!=l[d]){m=!1;break}m&&(o.push(a+u+h),h+=u-1)}return o}findFirstNotIn(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l={left:{id:-1,position:r},right:{id:-1,position:0},value:new n},h=o;for(;h>0;){if(l.right=this.findFirstIn(e,u?r-o+h:r+o-h,h,u),l.right.id==-1){o=h,u?r-=o:r=l.left.position,l.value=new n({buffer:this._buffer.slice(r,r+o)});break}if(l.right.position!=(u?l.left.position-e[l.right.id].length:l.left.position+e[l.right.id].length)){u?(r=l.right.position+e[l.right.id].length,o=l.left.position-l.right.position-e[l.right.id].length):(r=l.left.position,o=l.right.position-l.left.position-e[l.right.id].length),l.value=new n({buffer:this._buffer.slice(r,r+o)});break}l.left=l.right,h-=e[l.right.id].length}if(u){let m=l.right;l.right=l.left,l.left=m}return l}findAllNotIn(e,t,s){let{start:a,length:r}=this.prepareFindParameters(t,s),o=[],u={left:{id:-1,position:a},right:{id:-1,position:a},value:new n};do{let l=u.right.position;u=this.findFirstNotIn(e,u.right.position,r),r-=u.right.position-l,o.push({left:{id:u.left.id,position:u.left.position},right:{id:u.right.id,position:u.right.position},value:u.value})}while(u.right.id!=-1);return o}findFirstSequence(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l=this.skipNotPatterns(e,r,o,u);if(l==-1)return{position:-1,value:new n};let h=this.skipPatterns(e,l,o-(u?r-l:l-r),u);u?(r=h,o=l-h):(r=l,o=h-l);let m=new n({buffer:this._buffer.slice(r,r+o)});return{position:h,value:m}}findAllSequences(e,t,s){let{start:a,length:r}=this.prepareFindParameters(t,s),o=[],u={position:a,value:new n};do{let l=u.position;u=this.findFirstSequence(e,u.position,r),u.position!=-1&&(r-=u.position-l,o.push({position:u.position,value:u.value}))}while(u.position!=-1);return o}findPairedPatterns(e,t,s,a){let r=[];if(e.isEqual(t))return r;let{start:o,length:u}=this.prepareFindParameters(s,a),l=0,h=this.findAllPatternIn(e,o,u);if(!Array.isArray(h)||h.length==0)return r;let m=this.findAllPatternIn(t,o,u);if(!Array.isArray(m)||m.length==0)return r;for(;l<h.length&&m.length!=0;){if(h[0]==m[0]){r.push({left:h[0],right:m[0]}),h.splice(0,1),m.splice(0,1);continue}if(h[l]>m[0])break;for(;h[l]<m[0]&&(l++,!(l>=h.length)););r.push({left:h[l-1],right:m[0]}),h.splice(l-1,1),m.splice(0,1),l=0}return r.sort((g,d)=>g.left-d.left),r}findPairedArrays(e,t,s,a){let{start:r,length:o}=this.prepareFindParameters(s,a),u=[],l=0,h=this.findAllIn(e,r,o);if(h.length==0)return u;let m=this.findAllIn(t,r,o);if(m.length==0)return u;for(;l<h.length&&m.length!=0;){if(h[0].position==m[0].position){u.push({left:h[0],right:m[0]}),h.splice(0,1),m.splice(0,1);continue}if(h[l].position>m[0].position)break;for(;h[l].position<m[0].position&&(l++,!(l>=h.length)););u.push({left:h[l-1],right:m[0]}),h.splice(l-1,1),m.splice(0,1),l=0}return u.sort((g,d)=>g.left.position-d.left.position),u}replacePattern(e,t,s,a,r=null){let o=[],u,l={status:-1,searchPatternPositions:[],replacePatternPositions:[]},{start:h,length:m}=this.prepareFindParameters(s,a);if(r==null){if(o=this.findAllIn([e],h,m),o.length==0)return l}else o=r;l.searchPatternPositions.push(...Array.from(o,y=>y.position));let g=e.length-t.length,d=new ArrayBuffer(this.view.length-o.length*g),b=new Uint8Array(d);for(b.set(new Uint8Array(this.buffer,0,h)),u=0;u<o.length;u++){let y=u==0?h:o[u-1].position;b.set(new Uint8Array(this.buffer,y,o[u].position-e.length-y),y-u*g),b.set(t.view,o[u].position-e.length-u*g),l.replacePatternPositions.push(o[u].position-e.length-u*g)}return u--,b.set(new Uint8Array(this.buffer,o[u].position,this.length-o[u].position),o[u].position-e.length+t.length-u*g),this.buffer=d,this.view=new Uint8Array(this.buffer),l.status=1,l}skipPatterns(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l=r;for(let h=0;h<e.length;h++){let m=e[h].length,g=u?l-m:l,d=!0;for(let b=0;b<m;b++)if(this.view[b+g]!=e[h].view[b]){d=!1;break}if(d){if(h=-1,u){if(l-=m,l<=0)return l}else if(l+=m,l>=r+o)return l}}return l}skipNotPatterns(e,t,s,a){let{start:r,length:o,backward:u}=this.prepareFindParameters(t,s,a),l=-1;for(let h=0;h<o;h++){for(let m=0;m<e.length;m++){let g=e[m].length,d=u?r-h-g:r+h,b=!0;for(let y=0;y<g;y++)if(this.view[y+d]!=e[m].view[y]){b=!1;break}if(b){l=u?r-h:r+h;break}}if(l!=-1)break}return l}prepareFindParameters(e=null,t=null,s=!1){return e===null&&(e=s?this.length:0),e>this.length&&(e=this.length),s?(t===null&&(t=e),t>e&&(t=e)):(t===null&&(t=this.length-e),t>this.length-e&&(t=this.length-e)),{start:e,length:t,backward:s}}};var n1=16777216,mt=class n{constructor(e={}){this._stream=new Ve,this._length=0,this._start=0,this.backward=!1,this.appendBlock=0,this.prevLength=0,this.prevStart=0,"view"in e?this.stream=new Ve({view:e.view}):"buffer"in e?this.stream=new Ve({buffer:e.buffer}):"string"in e?this.stream=new Ve({string:e.string}):"hexstring"in e?this.stream=new Ve({hexstring:e.hexstring}):"stream"in e?this.stream=e.stream.slice():this.stream=new Ve,"backward"in e&&e.backward&&(this.backward=e.backward,this._start=this.stream.length),"length"in e&&e.length>0&&(this._length=e.length),"start"in e&&e.start&&e.start>0&&(this._start=e.start),"appendBlock"in e&&e.appendBlock&&e.appendBlock>0&&(this.appendBlock=e.appendBlock)}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e.length,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.length||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream.buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(t==null||t>this.length)&&(t=this.length);let s=this.stream.findPattern(e,this.start,this.length,this.backward);if(s==-1)return s;if(this.backward){if(s<this.start-e.length-t)return-1}else if(s>this.start+e.length+t)return-1;return this.start=s,s}findFirstIn(e,t=null){(t==null||t>this.length)&&(t=this.length);let s=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(s.id==-1)return s;if(this.backward){if(s.position<this.start-e[s.id].length-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(s.position>this.start+e[s.id].length+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=s.position,s}findAllIn(e){let t=this.backward?this.start-this.length:this.start;return this.stream.findAllIn(e,t,this.length)}findFirstNotIn(e,t=null){(t==null||t>this._length)&&(t=this._length);let s=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(s.left.id==-1&&s.right.id==-1)return s;if(this.backward){if(s.right.id!=-1&&s.right.position<this._start-e[s.right.id].length-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Ve}}else if(s.left.id!=-1&&s.left.position>this._start+e[s.left.id].length+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Ve};return this.backward?s.left.id==-1?this.start=0:this.start=s.left.position:s.right.id==-1?this.start=this._start+this._length:this.start=s.right.position,s}findAllNotIn(e){let t=this.backward?this._start-this._length:this._start;return this._stream.findAllNotIn(e,t,this._length)}findFirstSequence(e,t=null,s=null){(t==null||t>this._length)&&(t=this._length),(s==null||s>t)&&(s=t);let a=this._stream.findFirstSequence(e,this._start,t,this.backward);if(a.value.length==0)return a;if(this.backward){if(a.position<this._start-a.value.length-s)return{position:-1,value:new Ve}}else if(a.position>this._start+a.value.length+s)return{position:-1,value:new Ve};return this.start=a.position,a}findAllSequences(e){let t=this.backward?this.start-this.length:this.start;return this.stream.findAllSequences(e,t,this.length)}findPairedPatterns(e,t,s=null){(s==null||s>this.length)&&(s=this.length);let a=this.backward?this.start-this.length:this.start,r=this.stream.findPairedPatterns(e,t,a,this.length);if(r.length){if(this.backward){if(r[0].right<this.start-t.length-s)return[]}else if(r[0].left>this.start+e.length+s)return[]}return r}findPairedArrays(e,t,s=null){(s==null||s>this.length)&&(s=this.length);let a=this.backward?this.start-this.length:this.start,r=this.stream.findPairedArrays(e,t,a,this.length);if(r.length){if(this.backward){if(r[0].right.position<this.start-t[r[0].right.id].length-s)return[]}else if(r[0].left.position>this.start+e[r[0].left.id].length+s)return[]}return r}replacePattern(e,t){let s=this.backward?this.start-this.length:this.start;return this.stream.replacePattern(e,t,s,this.length)}skipPatterns(e){let t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){let t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return t==-1?-1:(this.start=t,t)}append(e){this.beforeAppend(e.length),this._stream.view.set(e.view,this._start),this._length+=e.length*2,this.start=this._start+e.length,this.prevLength-=e.length*2}appendView(e){this.beforeAppend(e.length),this._stream.view.set(e,this._start),this._length+=e.length*2,this.start=this._start+e.length,this.prevLength-=e.length*2}appendChar(e){this.beforeAppend(1),this._stream.view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this.beforeAppend(2);let t=new Uint16Array([e]),s=new Uint8Array(t.buffer);this.stream.view[this._start]=s[1],this._stream.view[this._start+1]=s[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this.beforeAppend(3);let t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[2],this._stream.view[this._start+1]=s[1],this._stream.view[this._start+2]=s[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this.beforeAppend(4);let t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[3],this._stream.view[this._start+1]=s[2],this._stream.view[this._start+2]=s[1],this._stream.view[this._start+3]=s[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}appendInt16(e){this.beforeAppend(2);let t=new Int16Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[1],this._stream.view[this._start+1]=s[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendInt32(e){this.beforeAppend(4);let t=new Int32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[3],this._stream.view[this._start+1]=s[2],this._stream.view[this._start+2]=s[1],this._stream.view[this._start+3]=s[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return new Uint8Array(0);this._length<e&&(e=this._length);let s;if(this.backward){let a=this._stream.view.subarray(this._length-e,this._length);s=new Uint8Array(e);for(let r=0;r<e;r++)s[e-1-r]=a[r]}else s=this._stream.view.subarray(this._start,this._start+e);return t&&(this.start+=this.backward?-1*e:e),s}getUint16(e=!0){let t=this.getBlock(2,e);return t.length<2?0:t[0]<<8|t[1]}getInt16(e=!0){let t=this.getUint16(e),s=32768;return t&s?-(s-(t^s)):t}getUint24(e=!0){let t=this.getBlock(4,e);return t.length<3?0:t[0]<<16|t[1]<<8|t[2]}getUint32(e=!0){let t=this.getBlock(4,e);return t.length<4?0:t[0]*n1+(t[1]<<16)+(t[2]<<8)+t[3]}getInt32(e=!0){let t=this.getUint32(e),s=2147483648;return t&s?-(s-(t^s)):t}beforeAppend(e){this._start+e>this._stream.length&&(e>this.appendBlock&&(this.appendBlock=e+n.APPEND_BLOCK),this._stream.realloc(this._stream.length+this.appendBlock))}};mt.APPEND_BLOCK=1e3;function r1(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function sf(n,...e){if(!r1(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${n.length}`)}function nf(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Dg(n,e){sf(n);let t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var pc=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),et=(n,e)=>n<<32-e|n>>>e,vc=(n,e)=>n<<e|n>>>32-e>>>0,vw=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function i1(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function af(n){return typeof n=="string"&&(n=i1(n)),sf(n),n}var dc=class{clone(){return this._cloneInto()}},ww={}.toString;function bn(n){let e=s=>n().update(af(s)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function o1(n,e,t,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,s);let a=BigInt(32),r=BigInt(4294967295),o=Number(t>>a&r),u=Number(t&r),l=s?4:0,h=s?0:4;n.setUint32(e+l,o,s),n.setUint32(e+h,u,s)}var wc=(n,e,t)=>n&e^~n&t,Sc=(n,e,t)=>n&e^n&t^e&t,cs=class extends dc{constructor(e,t,s,a){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=a,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=pc(this.buffer)}update(e){nf(this);let{view:t,buffer:s,blockLen:a}=this;e=af(e);let r=e.length;for(let o=0;o<r;){let u=Math.min(a-this.pos,r-o);if(u===a){let l=pc(e);for(;a<=r-o;o+=a)this.process(l,o);continue}s.set(e.subarray(o,o+u),this.pos),this.pos+=u,o+=u,this.pos===a&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){nf(this),Dg(e,this),this.finished=!0;let{buffer:t,view:s,blockLen:a,isLE:r}=this,{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>a-o&&(this.process(s,0),o=0);for(let g=o;g<a;g++)t[g]=0;o1(s,a-8,BigInt(this.length*8),r),this.process(s,0);let u=pc(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let h=l/4,m=this.get();if(h>m.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<h;g++)u.setUint32(4*g,m[g],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:s,length:a,finished:r,destroyed:o,pos:u}=this;return e.length=a,e.pos=u,e.finished=r,e.destroyed=o,a%t&&e.buffer.set(s),e}};var po=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),hs=new Uint32Array(80),rf=class extends cs{constructor(){super(64,20,8,!1),this.A=po[0]|0,this.B=po[1]|0,this.C=po[2]|0,this.D=po[3]|0,this.E=po[4]|0}get(){let{A:e,B:t,C:s,D:a,E:r}=this;return[e,t,s,a,r]}set(e,t,s,a,r){this.A=e|0,this.B=t|0,this.C=s|0,this.D=a|0,this.E=r|0}process(e,t){for(let l=0;l<16;l++,t+=4)hs[l]=e.getUint32(t,!1);for(let l=16;l<80;l++)hs[l]=vc(hs[l-3]^hs[l-8]^hs[l-14]^hs[l-16],1);let{A:s,B:a,C:r,D:o,E:u}=this;for(let l=0;l<80;l++){let h,m;l<20?(h=wc(a,r,o),m=1518500249):l<40?(h=a^r^o,m=1859775393):l<60?(h=Sc(a,r,o),m=2400959708):(h=a^r^o,m=3395469782);let g=vc(s,5)+h+u+m+hs[l]|0;u=o,o=r,r=vc(a,30),a=s,s=g}s=s+this.A|0,a=a+this.B|0,r=r+this.C|0,o=o+this.D|0,u=u+this.E|0,this.set(s,a,r,o,u)}roundClean(){hs.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}},Ug=bn(()=>new rf);var l1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),fs=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ms=new Uint32Array(64),of=class extends cs{constructor(){super(64,32,8,!1),this.A=fs[0]|0,this.B=fs[1]|0,this.C=fs[2]|0,this.D=fs[3]|0,this.E=fs[4]|0,this.F=fs[5]|0,this.G=fs[6]|0,this.H=fs[7]|0}get(){let{A:e,B:t,C:s,D:a,E:r,F:o,G:u,H:l}=this;return[e,t,s,a,r,o,u,l]}set(e,t,s,a,r,o,u,l){this.A=e|0,this.B=t|0,this.C=s|0,this.D=a|0,this.E=r|0,this.F=o|0,this.G=u|0,this.H=l|0}process(e,t){for(let g=0;g<16;g++,t+=4)ms[g]=e.getUint32(t,!1);for(let g=16;g<64;g++){let d=ms[g-15],b=ms[g-2],y=et(d,7)^et(d,18)^d>>>3,E=et(b,17)^et(b,19)^b>>>10;ms[g]=E+ms[g-7]+y+ms[g-16]|0}let{A:s,B:a,C:r,D:o,E:u,F:l,G:h,H:m}=this;for(let g=0;g<64;g++){let d=et(u,6)^et(u,11)^et(u,25),b=m+d+wc(u,l,h)+l1[g]+ms[g]|0,E=(et(s,2)^et(s,13)^et(s,22))+Sc(s,a,r)|0;m=h,h=l,l=u,u=o+b|0,o=r,r=a,a=s,s=b+E|0}s=s+this.A|0,a=a+this.B|0,r=r+this.C|0,o=o+this.D|0,u=u+this.E|0,l=l+this.F|0,h=h+this.G|0,m=m+this.H|0,this.set(s,a,r,o,u,l,h,m)}roundClean(){ms.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var lf=bn(()=>new of);var yc=BigInt(4294967295),uf=BigInt(32);function Lg(n,e=!1){return e?{h:Number(n&yc),l:Number(n>>uf&yc)}:{h:Number(n>>uf&yc)|0,l:Number(n&yc)|0}}function u1(n,e=!1){let t=new Uint32Array(n.length),s=new Uint32Array(n.length);for(let a=0;a<n.length;a++){let{h:r,l:o}=Lg(n[a],e);[t[a],s[a]]=[r,o]}return[t,s]}var c1=(n,e)=>BigInt(n>>>0)<<uf|BigInt(e>>>0),h1=(n,e,t)=>n>>>t,f1=(n,e,t)=>n<<32-t|e>>>t,m1=(n,e,t)=>n>>>t|e<<32-t,g1=(n,e,t)=>n<<32-t|e>>>t,d1=(n,e,t)=>n<<64-t|e>>>t-32,p1=(n,e,t)=>n>>>t-32|e<<64-t,v1=(n,e)=>e,w1=(n,e)=>n,S1=(n,e,t)=>n<<t|e>>>32-t,y1=(n,e,t)=>e<<t|n>>>32-t,A1=(n,e,t)=>e<<t-32|n>>>64-t,b1=(n,e,t)=>n<<t-32|e>>>64-t;function C1(n,e,t,s){let a=(e>>>0)+(s>>>0);return{h:n+t+(a/2**32|0)|0,l:a|0}}var k1=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),E1=(n,e,t,s)=>e+t+s+(n/2**32|0)|0,N1=(n,e,t,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(s>>>0),I1=(n,e,t,s,a)=>e+t+s+a+(n/2**32|0)|0,V1=(n,e,t,s,a)=>(n>>>0)+(e>>>0)+(t>>>0)+(s>>>0)+(a>>>0),B1=(n,e,t,s,a,r)=>e+t+s+a+r+(n/2**32|0)|0;var P1={fromBig:Lg,split:u1,toBig:c1,shrSH:h1,shrSL:f1,rotrSH:m1,rotrSL:g1,rotrBH:d1,rotrBL:p1,rotr32H:v1,rotr32L:w1,rotlSH:S1,rotlSL:y1,rotlBH:A1,rotlBL:b1,add:C1,add3L:k1,add3H:E1,add4L:N1,add4H:I1,add5H:B1,add5L:V1},G=P1;var[j1,x1]=G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),gs=new Uint32Array(80),ds=new Uint32Array(80),Ac=class extends cs{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:e,Al:t,Bh:s,Bl:a,Ch:r,Cl:o,Dh:u,Dl:l,Eh:h,El:m,Fh:g,Fl:d,Gh:b,Gl:y,Hh:E,Hl:v}=this;return[e,t,s,a,r,o,u,l,h,m,g,d,b,y,E,v]}set(e,t,s,a,r,o,u,l,h,m,g,d,b,y,E,v){this.Ah=e|0,this.Al=t|0,this.Bh=s|0,this.Bl=a|0,this.Ch=r|0,this.Cl=o|0,this.Dh=u|0,this.Dl=l|0,this.Eh=h|0,this.El=m|0,this.Fh=g|0,this.Fl=d|0,this.Gh=b|0,this.Gl=y|0,this.Hh=E|0,this.Hl=v|0}process(e,t){for(let V=0;V<16;V++,t+=4)gs[V]=e.getUint32(t),ds[V]=e.getUint32(t+=4);for(let V=16;V<80;V++){let B=gs[V-15]|0,x=ds[V-15]|0,K=G.rotrSH(B,x,1)^G.rotrSH(B,x,8)^G.shrSH(B,x,7),ee=G.rotrSL(B,x,1)^G.rotrSL(B,x,8)^G.shrSL(B,x,7),$=gs[V-2]|0,X=ds[V-2]|0,me=G.rotrSH($,X,19)^G.rotrBH($,X,61)^G.shrSH($,X,6),z=G.rotrSL($,X,19)^G.rotrBL($,X,61)^G.shrSL($,X,6),ae=G.add4L(ee,z,ds[V-7],ds[V-16]),kt=G.add4H(ae,K,me,gs[V-7],gs[V-16]);gs[V]=kt|0,ds[V]=ae|0}let{Ah:s,Al:a,Bh:r,Bl:o,Ch:u,Cl:l,Dh:h,Dl:m,Eh:g,El:d,Fh:b,Fl:y,Gh:E,Gl:v,Hh:j,Hl:P}=this;for(let V=0;V<80;V++){let B=G.rotrSH(g,d,14)^G.rotrSH(g,d,18)^G.rotrBH(g,d,41),x=G.rotrSL(g,d,14)^G.rotrSL(g,d,18)^G.rotrBL(g,d,41),K=g&b^~g&E,ee=d&y^~d&v,$=G.add5L(P,x,ee,x1[V],ds[V]),X=G.add5H($,j,B,K,j1[V],gs[V]),me=$|0,z=G.rotrSH(s,a,28)^G.rotrBH(s,a,34)^G.rotrBH(s,a,39),ae=G.rotrSL(s,a,28)^G.rotrBL(s,a,34)^G.rotrBL(s,a,39),kt=s&r^s&u^r&u,je=a&o^a&l^o&l;j=E|0,P=v|0,E=b|0,v=y|0,b=g|0,y=d|0,{h:g,l:d}=G.add(h|0,m|0,X|0,me|0),h=u|0,m=l|0,u=r|0,l=o|0,r=s|0,o=a|0;let ge=G.add3L(me,ae,je);s=G.add3H(ge,X,z,kt),a=ge|0}({h:s,l:a}=G.add(this.Ah|0,this.Al|0,s|0,a|0)),{h:r,l:o}=G.add(this.Bh|0,this.Bl|0,r|0,o|0),{h:u,l}=G.add(this.Ch|0,this.Cl|0,u|0,l|0),{h,l:m}=G.add(this.Dh|0,this.Dl|0,h|0,m|0),{h:g,l:d}=G.add(this.Eh|0,this.El|0,g|0,d|0),{h:b,l:y}=G.add(this.Fh|0,this.Fl|0,b|0,y|0),{h:E,l:v}=G.add(this.Gh|0,this.Gl|0,E|0,v|0),{h:j,l:P}=G.add(this.Hh|0,this.Hl|0,j|0,P|0),this.set(s,a,r,o,u,l,h,m,g,d,b,y,E,v,j,P)}roundClean(){gs.fill(0),ds.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var cf=class extends Ac{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}},hf=bn(()=>new Ac);var ff=bn(()=>new cf);var we=new ArrayBuffer(0),c="",se=class n extends TypeError{constructor(){super(...arguments),this.name=n.NAME}static isType(e,t){if(typeof t=="string"){if(t==="Array"&&Array.isArray(e))return!0;if(t==="ArrayBuffer"&&e instanceof ArrayBuffer)return!0;if(t==="ArrayBufferView"&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...s){for(let r of s)if(this.isType(e,r))return;let a=s.map(r=>r instanceof Function&&"name"in r?r.name:`${r}`);throw new n(`Parameter '${t}' is not of type ${a.length>1?`(${a.join(" or ")})`:a[0]}`)}};se.NAME="ArgumentError";var Q=class n extends TypeError{static assert(...e){let t=null,s,a;typeof e[0]=="string"?(t=e[0],s=e[1],a=e.slice(2)):(s=e[0],a=e.slice(1)),se.assert(s,"parameters","object");for(let r of a){let o=s[r];if(o==null)throw new n(r,t)}}static assertEmpty(e,t,s){if(e==null)throw new n(t,s)}constructor(e,t=null,s){super(),this.name=n.NAME,this.field=e,t&&(this.target=t),s?this.message=s:this.message=`Absent mandatory parameter '${e}' ${t?` in '${t}'`:c}`}};Q.NAME="ParameterError";var A=class n extends Error{static assertSchema(e,t){if(!e.verified)throw new Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(e.offset===-1)throw new n(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}},C=class{static blockName(){return this.CLASS_NAME}static fromBER(e){let t=ve(e);A.assert(t,this.name);try{return new this({schema:t.result})}catch(s){throw new A(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch(s){t=this.toSchema(!0)}return H.Convert.ToString(t.toBER(),e)}};C.CLASS_NAME="PkiObject";function Yt(n){let e=!1,t=c,s=n.trim();for(let a=0;a<s.length;a++)s.charCodeAt(a)===32?e===!1&&(e=!0):(e&&(t+=" ",e=!1),t+=s[a]);return t.toLowerCase()}var vo="type",mf="value",Vi=class n extends C{constructor(e={}){super(),this.type=i(e,vo,n.defaultValues(vo)),this.value=i(e,mf,n.defaultValues(mf)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vo:return c;case mf:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.type||c}),new U({name:t.value||c})]})}fromSchema(e){N(e,[vo,"typeValue"]);let t=k(e,e,n.schema({names:{type:vo,value:"typeValue"}}));A.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new f({value:[new O({value:this.type}),this.value]})}toJSON(){let e={type:this.type};return Object.keys(this.value).length!==0?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){let t=[Te.blockName(),Bt.blockName(),Pt.blockName(),ut.blockName(),De.blockName(),jt.blockName(),wn.blockName(),os.blockName(),Sn.blockName(),ls.blockName(),yn.blockName(),An.blockName()];if(e instanceof ArrayBuffer)return H.BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===n.blockName()){if(this.type!==e.type)return!1;let s=[!1,!1],a=this.value.constructor.blockName();for(let o of t)a===o&&(s[0]=!0),e.value.constructor.blockName()===o&&(s[1]=!0);if(s[0]!==s[1])return!1;if(s[0]&&s[1]){let o=Yt(this.value.valueBlock.value),u=Yt(e.value.valueBlock.value);if(o.localeCompare(u)!==0)return!1}else if(!H.BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}};Vi.CLASS_NAME="AttributeTypeAndValue";var vs="typesAndValues",Po="valueBeforeDecode",Mf="RDN",oe=class n extends C{constructor(e={}){super(),this.typesAndValues=i(e,vs,n.defaultValues(vs)),this.valueBeforeDecode=i(e,Po,n.defaultValues(Po)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vs:return[];case Po:return we;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case vs:return t.length===0;case Po:return t.byteLength===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.repeatedSequence||c,value:new ue({value:[new _({name:t.repeatedSet||c,value:Vi.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){N(e,[Mf,vs]);let t=k(e,e,n.schema({names:{blockName:Mf,repeatedSet:vs}}));A.assertSchema(t,this.className),vs in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,s=>new Vi({schema:s}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(this.valueBeforeDecode.byteLength===0)return new f({value:[new ue({value:Array.from(this.typesAndValues,t=>t.toSchema())})]});let e=ve(this.valueBeforeDecode);if(A.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof f))throw new Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof n){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(let[t,s]of this.typesAndValues.entries())if(s.isEqual(e.typesAndValues[t])===!1)return!1;return!0}return e instanceof ArrayBuffer?is(this.valueBeforeDecode,e):!1}};oe.CLASS_NAME="RelativeDistinguishedNames";var ki="type",Ei="value";function O1(n={},e=!1){let t=i(n,"names",{});return new f({optional:e,value:[new p({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:t.country_name||c,value:[new ie({value:[new ut,new De]})]}),new p({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:t.administration_domain_name||c,value:[new ie({value:[new ut,new De]})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:t.network_address||c,isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:t.terminal_identifier||c,isHexOnly:!0}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:t.private_domain_name||c,value:[new ie({value:[new ut,new De]})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:t.organization_name||c,isHexOnly:!0}),new D({optional:!0,name:t.numeric_user_identifier||c,idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new p({optional:!0,name:t.personal_name||c,idBlock:{tagClass:3,tagNumber:5},value:[new D({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new p({optional:!0,name:t.organizational_unit_names||c,idBlock:{tagClass:3,tagNumber:6},value:[new _({value:new De})]})]})}function R1(n=!1){return new f({optional:n,value:[new De,new De]})}function T1(n=!1){return new ue({optional:n,value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new U]})]})}var ne=class n extends C{constructor(e={}){super(),this.type=i(e,ki,n.defaultValues(ki)),this.value=i(e,Ei,n.defaultValues(Ei)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ki:return 9;case Ei:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ki:return t===n.defaultValues(e);case Ei:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ie({value:[new p({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||c,value:[new O,new p({idBlock:{tagClass:3,tagNumber:0},value:[new U]})]}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:1}}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:2}}),new p({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||c,value:[O1(t.builtInStandardAttributes||{},!1),R1(!0),T1(!0)]}),new p({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||c,value:[oe.schema(t.directoryName||{})]}),new p({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||c,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ie({value:[new jt,new De,new Pt,new Te,new Bt]})]}),new p({idBlock:{tagClass:3,tagNumber:1},value:[new ie({value:[new jt,new De,new Pt,new Te,new Bt]})]})]}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:6}}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:7}}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){N(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);let t=k(e,e,n.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(A.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{let s=t.result.blockName;s.idBlock.tagClass=1,s.idBlock.tagNumber=22;let a=s.toBER(!1),r=ve(a);A.assert(r,"GeneralName value"),this.value=r.result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new oe({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new I({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{let s=t.result.blockName;s.idBlock.tagClass=1,s.idBlock.tagNumber=6;let a=s.toBER(!1),r=ve(a);A.assert(r,"GeneralName registeredID"),this.value=r.result.valueBlock.toString()}break}}toSchema(){switch(this.type){case 0:case 3:case 5:return new p({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{let e=new os({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new p({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{let e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{let e=new O({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return n.schema()}}toJSON(){let e={type:this.type,value:c};if(typeof this.value=="string")e.value=this.value;else try{e.value=this.value.toJSON()}catch(t){}return e}};ne.CLASS_NAME="GeneralName";var jo="accessMethod",xo="accessLocation",D1=[jo,xo],Bi=class n extends C{constructor(e={}){super(),this.accessMethod=i(e,jo,n.defaultValues(jo)),this.accessLocation=i(e,xo,n.defaultValues(xo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jo:return c;case xo:return new ne;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.accessMethod||c}),ne.schema(t.accessLocation||{})]})}fromSchema(e){N(e,D1);let t=k(e,e,n.schema({names:{accessMethod:jo,accessLocation:{names:{blockName:xo}}}}));A.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new ne({schema:t.result.accessLocation})}toSchema(){return new f({value:[new O({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}};Bi.CLASS_NAME="AccessDescription";var Ft="seconds",Gt="millis",Wt="micros",dt=class n extends C{constructor(e={}){super(),Ft in e&&(this.seconds=i(e,Ft,n.defaultValues(Ft))),Gt in e&&(this.millis=i(e,Gt,n.defaultValues(Gt))),Wt in e&&(this.micros=i(e,Wt,n.defaultValues(Wt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ft:case Gt:case Wt:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ft:case Gt:case Wt:return t===n.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,optional:!0,value:[new w({optional:!0,name:t.seconds||c}),new D({name:t.millis||c,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({name:t.micros||c,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){N(e,[Ft,Gt,Wt]);let t=k(e,e,n.schema({names:{seconds:Ft,millis:Gt,micros:Wt}}));if(A.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){let s=new w({valueHex:t.result.millis.valueBlock.valueHex});this.millis=s.valueBlock.valueDec}if("micros"in t.result){let s=new w({valueHex:t.result.micros.valueBlock.valueHex});this.micros=s.valueBlock.valueDec}}toSchema(){let e=[];if(this.seconds!==void 0&&e.push(new w({value:this.seconds})),this.millis!==void 0){let t=new w({value:this.millis});e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(this.micros!==void 0){let t=new w({value:this.micros});e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new f({value:e})}toJSON(){let e={};return this.seconds!==void 0&&(e.seconds=this.seconds),this.millis!==void 0&&(e.millis=this.millis),this.micros!==void 0&&(e.micros=this.micros),e}};dt.CLASS_NAME="Accuracy";var bc="algorithmId",wo="algorithmParams",sd="algorithm",qf="params",U1=[sd,qf],S=class n extends C{constructor(e={}){super(),this.algorithmId=i(e,bc,n.defaultValues(bc)),wo in e&&(this.algorithmParams=i(e,wo,n.defaultValues(wo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case bc:return c;case wo:return new U;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case bc:return t===c;case wo:return t instanceof U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,optional:t.optional||!1,value:[new O({name:t.algorithmIdentifier||c}),new U({name:t.algorithmParams||c,optional:!0})]})}fromSchema(e){N(e,U1);let t=k(e,e,n.schema({names:{algorithmIdentifier:sd,algorithmParams:qf}}));A.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),qf in t.result&&(this.algorithmParams=t.result.params)}toSchema(){let e=[];return e.push(new O({value:this.algorithmId})),this.algorithmParams&&!(this.algorithmParams instanceof U)&&e.push(this.algorithmParams),new f({value:e})}toJSON(){let e={algorithmId:this.algorithmId};return this.algorithmParams&&!(this.algorithmParams instanceof U)&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return!(e instanceof n)||this.algorithmId!==e.algorithmId?!1:this.algorithmParams?e.algorithmParams?JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!1:!e.algorithmParams}};S.CLASS_NAME="AlgorithmIdentifier";var ar="altNames",L1=[ar],Pi=class n extends C{constructor(e={}){super(),this.altNames=i(e,ar,n.defaultValues(ar)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ar:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.altNames||c,value:ne.schema()})]})}fromSchema(e){N(e,L1);let t=k(e,e,n.schema({names:{altNames:ar}}));A.assertSchema(t,this.className),ar in t.result&&(this.altNames=Array.from(t.result.altNames,s=>new ne({schema:s})))}toSchema(){return new f({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}};Pi.CLASS_NAME="AltName";var rr="type",ir="values",H1=[rr,ir],fe=class n extends C{constructor(e={}){super(),this.type=i(e,rr,n.defaultValues(rr)),this.values=i(e,ir,n.defaultValues(ir)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rr:return c;case ir:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case rr:return t===c;case ir:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.type||c}),new ue({name:t.setName||c,value:[new _({name:t.values||c,value:new U})]})]})}fromSchema(e){N(e,H1);let t=k(e,e,n.schema({names:{type:rr,values:ir}}));A.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new f({value:[new O({value:this.type}),new ue({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}};fe.CLASS_NAME="Attribute";var Oo="notBeforeTime",Ro="notAfterTime",_1=[Oo,Ro],yt=class n extends C{constructor(e={}){super(),this.notBeforeTime=i(e,Oo,n.defaultValues(Oo)),this.notAfterTime=i(e,Ro,n.defaultValues(Ro)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Oo:case Ro:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new re({name:t.notBeforeTime||c}),new re({name:t.notAfterTime||c})]})}fromSchema(e){N(e,_1);let t=k(e,e,n.schema({names:{notBeforeTime:Oo,notAfterTime:Ro}}));A.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new f({value:[new re({valueDate:this.notBeforeTime}),new re({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}};yt.CLASS_NAME="AttCertValidityPeriod";var So="names",Hg="generalNames",ye=class n extends C{constructor(e={}){super(),this.names=i(e,So,n.defaultValues(So)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:return super.defaultValues(e)}}static schema(e={},t=!1){let s=i(e,So,{});return new f({optional:t,name:s.blockName||c,value:[new _({name:s.generalNames||c,value:ne.schema()})]})}fromSchema(e){N(e,[So,Hg]);let t=k(e,e,n.schema({names:{blockName:So,generalNames:Hg}}));A.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,s=>new ne({schema:s}))}toSchema(){return new f({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}};ye.CLASS_NAME="GeneralNames";var nd="2.5.29.9",ad="2.5.29.14",rd="2.5.29.15",id="2.5.29.16",ym="2.5.29.17",Am="2.5.29.18",qh="2.5.29.19",od="2.5.29.20",ld="2.5.29.27",ud="2.5.29.21",cd="2.5.29.24",bm="2.5.29.28",Cm="2.5.29.29",km="2.5.29.30",Em="2.5.29.31",$h="2.5.29.46",Nm="2.5.29.32",$e="2.5.29.32.0",hd="1.3.6.1.4.1.311.21.10",Im="2.5.29.33",Jh="2.5.29.35",Vm="2.5.29.36",fd="2.5.29.37",md="2.5.29.54",Fh="1.3.6.1.5.5.7.1.1",gd="1.3.6.1.5.5.7.1.11",Bm="1.3.6.1.4.1.11129.2.4.2",K1="1.3.6.1.4.1.311.20.2",M1="1.3.6.1.4.1.311.21.2",dd="1.3.6.1.4.1.311.21.7",pd="1.3.6.1.4.1.311.21.1",vd="1.3.6.1.5.5.7.1.3",Gh="1.2.840.113549.1.7.1",Pm="1.2.840.113549.1.7.2",jm="1.2.840.113549.1.7.3",xm="1.2.840.113549.1.7.6",wd="1.2.840.113549.1.9.16.1.4",$f="1.2.840.113549.1.9.22.1",Sd="1.2.840.113549.1.9.22.2",Jf="1.2.840.113549.1.9.22.3",Ff="1.2.840.113549.1.9.23.1",yd="1.3.6.1.5.5.7",Wh=`${yd}.48`,Cu=`${Wh}.1.1`,q1=`${Wh}.2`,$1=`${Wh}.1`,J1="1.3.14.3.2.26",F1="2.16.840.1.101.3.4.2.1",G1="2.16.840.1.101.3.4.2.2",W1="2.16.840.1.101.3.4.2.3",Nn="keyIdentifier",In="authorityCertIssuer",Vn="authorityCertSerialNumber",Y1=[Nn,In,Vn],ji=class n extends C{constructor(e={}){super(),Nn in e&&(this.keyIdentifier=i(e,Nn,n.defaultValues(Nn))),In in e&&(this.authorityCertIssuer=i(e,In,n.defaultValues(In))),Vn in e&&(this.authorityCertSerialNumber=i(e,Vn,n.defaultValues(Vn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Nn:return new I;case In:return[];case Vn:return new w;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new D({name:t.keyIdentifier||c,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new _({name:t.authorityCertIssuer||c,value:ne.schema()})]}),new D({name:t.authorityCertSerialNumber||c,optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){N(e,Y1);let t=k(e,e,n.schema({names:{keyIdentifier:Nn,authorityCertIssuer:In,authorityCertSerialNumber:Vn}}));A.assertSchema(t,this.className),Nn in t.result&&(this.keyIdentifier=new I({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),In in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,s=>new ne({schema:s}))),Vn in t.result&&(this.authorityCertSerialNumber=new w({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){let e=[];return this.keyIdentifier&&e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,t=>t.toSchema())})),this.authorityCertSerialNumber&&e.push(new D({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new f({value:e})}toJSON(){let e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,t=>t.toJSON())),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}};ji.CLASS_NAME="AuthorityKeyIdentifier";var Cn="pathLenConstraint",kn="cA",xi=class n extends C{constructor(e={}){super(),this.cA=i(e,kn,!1),Cn in e&&(this.pathLenConstraint=i(e,Cn,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case kn:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new Ke({optional:!0,name:t.cA||c}),new w({optional:!0,name:t.pathLenConstraint||c})]})}fromSchema(e){N(e,[kn,Cn]);let t=k(e,e,n.schema({names:{cA:kn,pathLenConstraint:Cn}}));A.assertSchema(t,this.className),kn in t.result&&(this.cA=t.result.cA.valueBlock.value),Cn in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){let e=[];return this.cA!==n.defaultValues(kn)&&e.push(new Ke({value:this.cA})),Cn in this&&(this.pathLenConstraint instanceof w?e.push(this.pathLenConstraint):e.push(new w({value:this.pathLenConstraint}))),new f({value:e})}toJSON(){let e={};return this.cA!==n.defaultValues(kn)&&(e.cA=this.cA),Cn in this&&(this.pathLenConstraint instanceof w?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}};xi.CLASS_NAME="BasicConstraints";var gf="certificateIndex",df="keyIndex",Eu=class n extends C{constructor(e={}){super(),this.certificateIndex=i(e,gf,n.defaultValues(gf)),this.keyIndex=i(e,df,n.defaultValues(df)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gf:case df:return 0;default:return super.defaultValues(e)}}static schema(){return new w}fromSchema(e){if(e.constructor.blockName()!==w.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0),s=new Uint8Array(t);switch(!0){case t.byteLength<4:{let g=new ArrayBuffer(4);new Uint8Array(g).set(s,4-t.byteLength),t=g.slice(0)}break;case t.byteLength>4:{let g=new ArrayBuffer(4);new Uint8Array(g).set(s.slice(0,4)),t=g.slice(0)}break}let a=t.slice(0,2),r=new Uint8Array(a),o=r[0];r[0]=r[1],r[1]=o;let u=new Uint16Array(a);this.keyIndex=u[0];let l=t.slice(2),h=new Uint8Array(l);o=h[0],h[0]=h[1],h[1]=o;let m=new Uint16Array(l);this.certificateIndex=m[0]}toSchema(){let e=new ArrayBuffer(2),t=new Uint16Array(e);t[0]=this.certificateIndex;let s=new Uint8Array(e),a=s[0];s[0]=s[1],s[1]=a;let r=new ArrayBuffer(2),o=new Uint16Array(r);o[0]=this.keyIndex;let u=new Uint8Array(r);return a=u[0],u[0]=u[1],u[1]=a,new w({valueHex:pn(r,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}};Eu.CLASS_NAME="CAVersion";var To="policyQualifierId",Do="qualifier",Q1=[To,Do],Oi=class n extends C{constructor(e={}){super(),this.policyQualifierId=i(e,To,n.defaultValues(To)),this.qualifier=i(e,Do,n.defaultValues(Do)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case To:return c;case Do:return new U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.policyQualifierId||c}),new U({name:t.qualifier||c})]})}fromSchema(e){N(e,Q1);let t=k(e,e,n.schema({names:{policyQualifierId:To,qualifier:Do}}));A.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new f({value:[new O({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}};Oi.CLASS_NAME="PolicyQualifierInfo";var Ni="policyIdentifier",Zs="policyQualifiers",X1=[Ni,Zs],Ri=class n extends C{constructor(e={}){super(),this.policyIdentifier=i(e,Ni,n.defaultValues(Ni)),Zs in e&&(this.policyQualifiers=i(e,Zs,n.defaultValues(Zs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ni:return c;case Zs:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.policyIdentifier||c}),new f({optional:!0,value:[new _({name:t.policyQualifiers||c,value:Oi.schema()})]})]})}fromSchema(e){N(e,X1);let t=k(e,e,n.schema({names:{policyIdentifier:Ni,policyQualifiers:Zs}}));A.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),Zs in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,s=>new Oi({schema:s})))}toSchema(){let e=[];return e.push(new O({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new f({value:Array.from(this.policyQualifiers,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,t=>t.toJSON())),e}};Ri.CLASS_NAME="PolicyInformation";var Uo="certificatePolicies",z1=[Uo],Ti=class n extends C{constructor(e={}){super(),this.certificatePolicies=i(e,Uo,n.defaultValues(Uo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Uo:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.certificatePolicies||c,value:Ri.schema()})]})}fromSchema(e){N(e,z1);let t=k(e,e,n.schema({names:{certificatePolicies:Uo}}));A.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,s=>new Ri({schema:s}))}toSchema(){return new f({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}};Ti.CLASS_NAME="CertificatePolicies";var Lo="templateID",Rt="templateMajorVersion",Tt="templateMinorVersion",Z1=[Lo,Rt,Tt],Ch=class n extends C{constructor(e={}){super(),this.templateID=i(e,Lo,n.defaultValues(Lo)),Rt in e&&(this.templateMajorVersion=i(e,Rt,n.defaultValues(Rt))),Tt in e&&(this.templateMinorVersion=i(e,Tt,n.defaultValues(Tt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Lo:return c;case Rt:case Tt:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.templateID||c}),new w({name:t.templateMajorVersion||c,optional:!0}),new w({name:t.templateMinorVersion||c,optional:!0})]})}fromSchema(e){N(e,Z1);let t=k(e,e,n.schema({names:{templateID:Lo,templateMajorVersion:Rt,templateMinorVersion:Tt}}));A.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),Rt in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),Tt in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){let e=[];return e.push(new O({value:this.templateID})),Rt in this&&e.push(new w({value:this.templateMajorVersion})),Tt in this&&e.push(new w({value:this.templateMinorVersion})),new f({value:e})}toJSON(){let e={templateID:this.templateID};return Rt in this&&(e.templateMajorVersion=this.templateMajorVersion),Tt in this&&(e.templateMinorVersion=this.templateMinorVersion),e}},Bn="distributionPoint",Ad="distributionPointNames",Pn="reasons",jn="cRLIssuer",bd="cRLIssuerNames",ep=[Bn,Ad,Pn,jn,bd],Di=class n extends C{constructor(e={}){super(),Bn in e&&(this.distributionPoint=i(e,Bn,n.defaultValues(Bn))),Pn in e&&(this.reasons=i(e,Pn,n.defaultValues(Pn))),jn in e&&(this.cRLIssuer=i(e,jn,n.defaultValues(jn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bn:return[];case Pn:return new F;case jn:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ie({value:[new p({name:t.distributionPoint||c,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:t.distributionPointNames||c,value:ne.schema()})]}),new p({name:t.distributionPoint||c,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:oe.schema().valueBlock.value})]})]}),new D({name:t.reasons||c,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new p({name:t.cRLIssuer||c,optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new _({name:t.cRLIssuerNames||c,value:ne.schema()})]})]})}fromSchema(e){N(e,ep);let t=k(e,e,n.schema({names:{distributionPoint:Bn,distributionPointNames:Ad,reasons:Pn,cRLIssuer:jn,cRLIssuerNames:bd}}));A.assertSchema(t,this.className),Bn in t.result&&(t.result.distributionPoint.idBlock.tagNumber===0&&(this.distributionPoint=Array.from(t.result.distributionPointNames,s=>new ne({schema:s}))),t.result.distributionPoint.idBlock.tagNumber===1&&(this.distributionPoint=new oe({schema:new f({value:t.result.distributionPoint.valueBlock.value})}))),Pn in t.result&&(this.reasons=new F({valueHex:t.result.reasons.valueBlock.valueHex})),jn in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,s=>new ne({schema:s})))}toSchema(){let e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new p({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,s=>s.toSchema())}):t=new p({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new p({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,t=>t.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,t=>t.toJSON())),e}};Di.CLASS_NAME="DistributionPoint";var Ho="distributionPoints",tp=[Ho],Ui=class n extends C{constructor(e={}){super(),this.distributionPoints=i(e,Ho,n.defaultValues(Ho)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ho:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.distributionPoints||c,value:Di.schema()})]})}fromSchema(e){N(e,tp);let t=k(e,e,n.schema({names:{distributionPoints:Ho}}));A.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,s=>new Di({schema:s}))}toSchema(){return new f({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}};Ui.CLASS_NAME="CRLDistributionPoints";var _o="keyPurposes",sp=[_o],Nu=class n extends C{constructor(e={}){super(),this.keyPurposes=i(e,_o,n.defaultValues(_o)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _o:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.keyPurposes||c,value:new O})]})}fromSchema(e){N(e,sp);let t=k(e,e,n.schema({names:{keyPurposes:_o}}));A.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,s=>s.valueBlock.toString())}toSchema(){return new f({value:Array.from(this.keyPurposes,e=>new O({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}};Nu.CLASS_NAME="ExtKeyUsage";var yo="accessDescriptions",Li=class n extends C{constructor(e={}){super(),this.accessDescriptions=i(e,yo,n.defaultValues(yo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case yo:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.accessDescriptions||c,value:Bi.schema()})]})}fromSchema(e){N(e,[yo]);let t=k(e,e,n.schema({names:{accessDescriptions:yo}}));A.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,s=>new Bi({schema:s}))}toSchema(){return new f({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}};Li.CLASS_NAME="InfoAccess";var xn="distributionPoint",Cd="distributionPointNames",ws="onlyContainsUserCerts",Ss="onlyContainsCACerts",ys="onlySomeReasons",As="indirectCRL",bs="onlyContainsAttributeCerts",np=[xn,Cd,ws,Ss,ys,As,bs],Iu=class n extends C{constructor(e={}){super(),xn in e&&(this.distributionPoint=i(e,xn,n.defaultValues(xn))),this.onlyContainsUserCerts=i(e,ws,n.defaultValues(ws)),this.onlyContainsCACerts=i(e,Ss,n.defaultValues(Ss)),ys in e&&(this.onlySomeReasons=i(e,ys,n.defaultValues(ys))),this.indirectCRL=i(e,As,n.defaultValues(As)),this.onlyContainsAttributeCerts=i(e,bs,n.defaultValues(bs)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xn:return[];case ws:return!1;case Ss:return!1;case ys:return 0;case As:return!1;case bs:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ie({value:[new p({name:t.distributionPoint||c,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:t.distributionPointNames||c,value:ne.schema()})]}),new p({name:t.distributionPoint||c,idBlock:{tagClass:3,tagNumber:1},value:oe.schema().valueBlock.value})]})]}),new D({name:t.onlyContainsUserCerts||c,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new D({name:t.onlyContainsCACerts||c,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new D({name:t.onlySomeReasons||c,optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new D({name:t.indirectCRL||c,optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new D({name:t.onlyContainsAttributeCerts||c,optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){N(e,np);let t=k(e,e,n.schema({names:{distributionPoint:xn,distributionPointNames:Cd,onlyContainsUserCerts:ws,onlyContainsCACerts:Ss,onlySomeReasons:ys,indirectCRL:As,onlyContainsAttributeCerts:bs}}));if(A.assertSchema(t,this.className),xn in t.result)switch(!0){case t.result.distributionPoint.idBlock.tagNumber===0:this.distributionPoint=Array.from(t.result.distributionPointNames,s=>new ne({schema:s}));break;case t.result.distributionPoint.idBlock.tagNumber===1:this.distributionPoint=new oe({schema:new f({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(ws in t.result){let s=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=s[0]!==0}if(Ss in t.result){let s=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=s[0]!==0}if(ys in t.result){let s=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=s[0]}if(As in t.result){let s=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=s[0]!==0}if(bs in t.result){let s=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=s[0]!==0}}toSchema(){let e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new p({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,s=>s.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==n.defaultValues(ws)&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==n.defaultValues(Ss)&&e.push(new D({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),this.onlySomeReasons!==void 0){let t=new ArrayBuffer(1),s=new Uint8Array(t);s[0]=this.onlySomeReasons,e.push(new D({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==n.defaultValues(As)&&e.push(new D({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==n.defaultValues(bs)&&e.push(new D({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new f({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,t=>t.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==n.defaultValues(ws)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==n.defaultValues(Ss)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),ys in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==n.defaultValues(As)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==n.defaultValues(bs)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}};Iu.CLASS_NAME="IssuingDistributionPoint";var Ko="base",or="minimum",Cs="maximum",ap=[Ko,or,Cs],nn=class n extends C{constructor(e={}){super(),this.base=i(e,Ko,n.defaultValues(Ko)),this.minimum=i(e,or,n.defaultValues(or)),Cs in e&&(this.maximum=i(e,Cs,n.defaultValues(Cs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ko:return new ne;case or:return 0;case Cs:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[ne.schema(t.base||{}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:t.minimum||c})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new w({name:t.maximum||c})]})]})}fromSchema(e){N(e,ap);let t=k(e,e,n.schema({names:{base:{names:{blockName:Ko}},minimum:or,maximum:Cs}}));A.assertSchema(t,this.className),this.base=new ne({schema:t.result.base}),or in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),Cs in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){let e=[];if(e.push(this.base.toSchema()),this.minimum!==0){let t=0;this.minimum instanceof w?t=this.minimum:t=new w({value:this.minimum}),e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(Cs in this){let t=0;this.maximum instanceof w?t=this.maximum:t=new w({value:this.maximum}),e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new f({value:e})}toJSON(){let e={base:this.base.toJSON()};return this.minimum!==0&&(typeof this.minimum=="number"?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),this.maximum!==void 0&&(typeof this.maximum=="number"?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}};nn.CLASS_NAME="GeneralSubtree";var On="permittedSubtrees",Rn="excludedSubtrees",rp=[On,Rn],Vu=class n extends C{constructor(e={}){super(),On in e&&(this.permittedSubtrees=i(e,On,n.defaultValues(On))),Rn in e&&(this.excludedSubtrees=i(e,Rn,n.defaultValues(Rn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case On:case Rn:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:t.permittedSubtrees||c,value:nn.schema()})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new _({name:t.excludedSubtrees||c,value:nn.schema()})]})]})}fromSchema(e){N(e,rp);let t=k(e,e,n.schema({names:{permittedSubtrees:On,excludedSubtrees:Rn}}));A.assertSchema(t,this.className),On in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,s=>new nn({schema:s}))),Rn in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,s=>new nn({schema:s})))}toSchema(){let e=[];return this.permittedSubtrees&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,t=>t.toSchema())})),this.excludedSubtrees&&e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,t=>t.toJSON())),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,t=>t.toJSON())),e}};Vu.CLASS_NAME="NameConstraints";var Dt="requireExplicitPolicy",Ut="inhibitPolicyMapping",ip=[Dt,Ut],Bu=class n extends C{constructor(e={}){super(),Dt in e&&(this.requireExplicitPolicy=i(e,Dt,n.defaultValues(Dt))),Ut in e&&(this.inhibitPolicyMapping=i(e,Ut,n.defaultValues(Ut))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Dt:return 0;case Ut:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new D({name:t.requireExplicitPolicy||c,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({name:t.inhibitPolicyMapping||c,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){N(e,ip);let t=k(e,e,n.schema({names:{requireExplicitPolicy:Dt,inhibitPolicyMapping:Ut}}));if(A.assertSchema(t,this.className),Dt in t.result){let s=t.result.requireExplicitPolicy;s.idBlock.tagClass=1,s.idBlock.tagNumber=2;let a=s.toBER(!1),r=ve(a);A.assert(r,"Integer"),this.requireExplicitPolicy=r.result.valueBlock.valueDec}if(Ut in t.result){let s=t.result.inhibitPolicyMapping;s.idBlock.tagClass=1,s.idBlock.tagNumber=2;let a=s.toBER(!1),r=ve(a);A.assert(r,"Integer"),this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){let e=[];if(Dt in this){let t=new w({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(Ut in this){let t=new w({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new f({value:e})}toJSON(){let e={};return Dt in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),Ut in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}};Bu.CLASS_NAME="PolicyConstraints";var Mo="issuerDomainPolicy",qo="subjectDomainPolicy",op=[Mo,qo],Hi=class n extends C{constructor(e={}){super(),this.issuerDomainPolicy=i(e,Mo,n.defaultValues(Mo)),this.subjectDomainPolicy=i(e,qo,n.defaultValues(qo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mo:return c;case qo:return c;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.issuerDomainPolicy||c}),new O({name:t.subjectDomainPolicy||c})]})}fromSchema(e){N(e,op);let t=k(e,e,n.schema({names:{issuerDomainPolicy:Mo,subjectDomainPolicy:qo}}));A.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new f({value:[new O({value:this.issuerDomainPolicy}),new O({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}};Hi.CLASS_NAME="PolicyMapping";var $o="mappings",lp=[$o],Pu=class n extends C{constructor(e={}){super(),this.mappings=i(e,$o,n.defaultValues($o)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $o:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.mappings||c,value:Hi.schema()})]})}fromSchema(e){N(e,lp);let t=k(e,e,n.schema({names:{mappings:$o}}));A.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,s=>new Hi({schema:s}))}toSchema(){return new f({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}};Pu.CLASS_NAME="PolicyMappings";var ks="notBefore",Es="notAfter",up=[ks,Es],ju=class n extends C{constructor(e={}){super(),ks in e&&(this.notBefore=i(e,ks,n.defaultValues(ks))),Es in e&&(this.notAfter=i(e,Es,n.defaultValues(Es))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ks:return new Date;case Es:return new Date;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new D({name:t.notBefore||c,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({name:t.notAfter||c,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){N(e,up);let t=k(e,e,n.schema({names:{notBefore:ks,notAfter:Es}}));if(A.assertSchema(t,this.className),ks in t.result){let s=new re;s.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=s.toDate()}if(Es in t.result){let s=new re({valueHex:t.result.notAfter.valueBlock.valueHex});s.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=s.toDate()}}toSchema(){let e=[];return ks in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:new re({valueDate:this.notBefore}).valueBlock.valueHexView})),Es in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:new re({valueDate:this.notAfter}).valueBlock.valueHexView})),new f({value:e})}toJSON(){let e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}};ju.CLASS_NAME="PrivateKeyUsagePeriod";var lr="id",Lt="type",ur="values",cp=[lr,Lt],hp=[ur],_i=class n extends C{constructor(e={}){super(),this.id=i(e,lr,n.defaultValues(lr)),Lt in e&&(this.type=i(e,Lt,n.defaultValues(Lt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lr:return c;case Lt:return new le;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lr:return t===c;case Lt:return t instanceof le;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.id||c}),new U({name:t.type||c,optional:!0})]})}fromSchema(e){N(e,cp);let t=k(e,e,n.schema({names:{id:lr,type:Lt}}));A.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),Lt in t.result&&(this.type=t.result.type)}toSchema(){let e=[new O({value:this.id})];return Lt in this&&e.push(this.type),new f({value:e})}toJSON(){let e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}};_i.CLASS_NAME="QCStatement";var xu=class n extends C{constructor(e={}){super(),this.values=i(e,ur,n.defaultValues(ur)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ur:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ur:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.values||c,value:_i.schema(t.value||{})})]})}fromSchema(e){N(e,hp);let t=k(e,e,n.schema({names:{values:ur}}));A.assertSchema(t,this.className),this.values=Array.from(t.result.values,s=>new _i({schema:s}))}toSchema(){return new f({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{values:Array.from(this.values,e=>e.toJSON())}}};xu.CLASS_NAME="QCStatements";var Tn,it=class{static register(e,t,s){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:s}}static find(e){return this.namedCurves[e.toLowerCase()]||null}};Tn=it;it.namedCurves={};Tn.register("P-256","1.2.840.10045.3.1.7",32),Tn.register("P-384","1.3.132.0.34",48),Tn.register("P-521","1.3.132.0.35",66),Tn.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),Tn.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),Tn.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);var Cc="x",kc="y",Ec="namedCurve",Xe=class n extends C{constructor(e={}){super(),this.x=i(e,Cc,n.defaultValues(Cc)),this.y=i(e,kc,n.defaultValues(kc)),this.namedCurve=i(e,Ec,n.defaultValues(Ec)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cc:case kc:return we;case Ec:return c;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Cc:case kc:return t instanceof ArrayBuffer&&is(t,n.defaultValues(e));case Ec:return typeof t=="string"&&t===n.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new us}fromSchema(e){let t=Ii.BufferSourceConverter.toUint8Array(e);if(t[0]!==4)throw new Error("Object's schema was not verified against input data for ECPublicKey");let s=it.find(this.namedCurve);if(!s)throw new Error(`Incorrect curve OID: ${this.namedCurve}`);let a=s.size;if(t.byteLength!==a*2+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=s.name,this.x=t.slice(1,a+1).buffer,this.y=t.slice(1+a,a*2+1).buffer}toSchema(){return new us({data:pn(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e=it.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:Xu(eo(this.x),!0,!0,!1),y:Xu(eo(this.y),!0,!0,!1)}}fromJSON(e){Q.assert("json",e,"crv","x","y");let t=0,s=it.find(e.crv);s&&(this.namedCurve=s.id,t=s.size);let a=vn(Wa(e.x,!0));if(a.byteLength<t){this.x=new ArrayBuffer(t);let o=new Uint8Array(this.x),u=new Uint8Array(a);o.set(u,1)}else this.x=a.slice(0,t);let r=vn(Wa(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);let o=new Uint8Array(this.y),u=new Uint8Array(r);o.set(u,1)}else this.y=r.slice(0,t)}};Xe.CLASS_NAME="ECPublicKey";var Jo="modulus",Fo="publicExponent",fp=[Jo,Fo],Ki=class n extends C{constructor(e={}){super(),this.modulus=i(e,Jo,n.defaultValues(Jo)),this.publicExponent=i(e,Fo,n.defaultValues(Fo)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jo:return new w;case Fo:return new w;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.modulus||c}),new w({name:t.publicExponent||c})]})}fromSchema(e){N(e,fp);let t=k(e,e,n.schema({names:{modulus:Jo,publicExponent:Fo}}));A.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new f({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:H.Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:H.Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){Q.assert("json",e,"n","e");let t=vn(Wa(e.n,!0));this.modulus=new w({valueHex:t.slice(0,Math.pow(2,Xm(t.byteLength)))}),this.publicExponent=new w({valueHex:vn(Wa(e.e,!0)).slice(0,3)})}};Ki.CLASS_NAME="RSAPublicKey";var Go="algorithm",Wo="subjectPublicKey",mp=[Go,Wo],qe=class n extends C{get parsedKey(){if(this._parsedKey===void 0){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===O.blockName())try{this._parsedKey=new Xe({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{let e=ve(this.subjectPublicKey.valueBlock.valueHexView);if(e.offset!==-1)try{this._parsedKey=new Ki({schema:e.result})}catch(t){}}break}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}constructor(e={}){super(),this.algorithm=i(e,Go,n.defaultValues(Go)),this.subjectPublicKey=i(e,Wo,n.defaultValues(Wo));let t=i(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Go:return new S;case Wo:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.algorithm||{}),new F({name:t.subjectPublicKey||c})]})}fromSchema(e){N(e,mp);let t=k(e,e,n.schema({names:{algorithm:{names:{blockName:Go}},subjectPublicKey:Wo}}));A.assertSchema(t,this.className),this.algorithm=new S({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new f({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};let e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA";break}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Xe({json:e}),this.algorithm=new S({algorithmId:"1.2.840.10045.2.1",algorithmParams:new O({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ki({json:e}),this.algorithm=new S({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new le});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new F({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=q(!0)){try{if(!e)throw new Error("Need to provide publicKey input parameter");let s=await t.exportKey("spki",e),a=ve(s);try{this.fromSchema(a.result)}catch(r){throw new Error("Error during initializing object from schema")}}catch(s){let a=s instanceof Error?s.message:`${s}`;throw new Error(`Error during exporting public key: ${a}`)}}};qe.CLASS_NAME="PublicKeyInfo";var cr="version",hr="privateKey",tt="namedCurve",Ns="publicKey",gp=[cr,hr,tt,Ns],Mi=class n extends C{constructor(e={}){super(),this.version=i(e,cr,n.defaultValues(cr)),this.privateKey=i(e,hr,n.defaultValues(hr)),tt in e&&(this.namedCurve=i(e,tt,n.defaultValues(tt))),Ns in e&&(this.publicKey=i(e,Ns,n.defaultValues(Ns))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cr:return 1;case hr:return new I;case tt:return c;case Ns:return new Xe;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cr:return t===n.defaultValues(e);case hr:return t.isEqual(n.defaultValues(e));case tt:return t===c;case Ns:return Xe.compareWithDefault(tt,t.namedCurve)&&Xe.compareWithDefault("x",t.x)&&Xe.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new I({name:t.privateKey||c}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new O({name:t.namedCurve||c})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new F({name:t.publicKey||c})]})]})}fromSchema(e){N(e,gp);let t=k(e,e,n.schema({names:{version:cr,privateKey:hr,namedCurve:tt,publicKey:Ns}}));if(A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,tt in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),Ns in t.result){let s={schema:t.result.publicKey.valueBlock.valueHex};tt in this&&(s.namedCurve=this.namedCurve),this.publicKey=new Xe(s)}}toSchema(){let e=[new w({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[new O({value:this.namedCurve})]})),this.publicKey&&e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[new F({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new f({value:e})}toJSON(){if(!this.namedCurve||n.compareWithDefault(tt,this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e=it.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:H.Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){let s=this.publicKey.toJSON();t.x=s.x,t.y=s.y}return t}fromJSON(e){Q.assert("json",e,"crv","d");let t=0,s=it.find(e.crv);s&&(this.namedCurve=s.id,t=s.size);let a=H.Convert.FromBase64Url(e.d);if(a.byteLength<t){let r=new ArrayBuffer(t),o=new Uint8Array(r),u=new Uint8Array(a);o.set(u,1),this.privateKey=new I({valueHex:r})}else this.privateKey=new I({valueHex:a.slice(0,t)});e.x&&e.y&&(this.publicKey=new Xe({json:e}))}};Mi.CLASS_NAME="ECPrivateKey";var Yo="prime",Qo="exponent",Xo="coefficient",dp=[Yo,Qo,Xo],Ea=class n extends C{constructor(e={}){super(),this.prime=i(e,Yo,n.defaultValues(Yo)),this.exponent=i(e,Qo,n.defaultValues(Qo)),this.coefficient=i(e,Xo,n.defaultValues(Xo)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Yo:return new w;case Qo:return new w;case Xo:return new w;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.prime||c}),new w({name:t.exponent||c}),new w({name:t.coefficient||c})]})}fromSchema(e){N(e,dp);let t=k(e,e,n.schema({names:{prime:Yo,exponent:Qo,coefficient:Xo}}));A.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new f({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:H.Convert.ToBase64Url(this.prime.valueBlock.valueHexView),d:H.Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),t:H.Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){Q.assert("json",e,"r","d","r"),this.prime=new w({valueHex:H.Convert.FromBase64Url(e.r)}),this.exponent=new w({valueHex:H.Convert.FromBase64Url(e.d)}),this.coefficient=new w({valueHex:H.Convert.FromBase64Url(e.t)})}};Ea.CLASS_NAME="OtherPrimeInfo";var zo="version",Zo="modulus",el="publicExponent",tl="privateExponent",sl="prime1",nl="prime2",al="exponent1",rl="exponent2",il="coefficient",Dn="otherPrimeInfos",pp=[zo,Zo,el,tl,sl,nl,al,rl,il,Dn],qi=class n extends C{constructor(e={}){super(),this.version=i(e,zo,n.defaultValues(zo)),this.modulus=i(e,Zo,n.defaultValues(Zo)),this.publicExponent=i(e,el,n.defaultValues(el)),this.privateExponent=i(e,tl,n.defaultValues(tl)),this.prime1=i(e,sl,n.defaultValues(sl)),this.prime2=i(e,nl,n.defaultValues(nl)),this.exponent1=i(e,al,n.defaultValues(al)),this.exponent2=i(e,rl,n.defaultValues(rl)),this.coefficient=i(e,il,n.defaultValues(il)),Dn in e&&(this.otherPrimeInfos=i(e,Dn,n.defaultValues(Dn))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case zo:return 0;case Zo:return new w;case el:return new w;case tl:return new w;case sl:return new w;case nl:return new w;case al:return new w;case rl:return new w;case il:return new w;case Dn:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new w({name:t.modulus||c}),new w({name:t.publicExponent||c}),new w({name:t.privateExponent||c}),new w({name:t.prime1||c}),new w({name:t.prime2||c}),new w({name:t.exponent1||c}),new w({name:t.exponent2||c}),new w({name:t.coefficient||c}),new f({optional:!0,value:[new _({name:t.otherPrimeInfosName||c,value:Ea.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){N(e,pp);let t=k(e,e,n.schema({names:{version:zo,modulus:Zo,publicExponent:el,privateExponent:tl,prime1:sl,prime2:nl,exponent1:al,exponent2:rl,coefficient:il,otherPrimeInfo:{names:{blockName:Dn}}}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),Dn in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,s=>new Ea({schema:s})))}toSchema(){let e=[];return e.push(new w({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new f({value:Array.from(this.otherPrimeInfos,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={n:H.Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:H.Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:H.Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:H.Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),q:H.Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:H.Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:H.Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:H.Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,t=>t.toJSON())),e}fromJSON(e){Q.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new w({valueHex:H.Convert.FromBase64Url(e.n)}),this.publicExponent=new w({valueHex:H.Convert.FromBase64Url(e.e)}),this.privateExponent=new w({valueHex:H.Convert.FromBase64Url(e.d)}),this.prime1=new w({valueHex:H.Convert.FromBase64Url(e.p)}),this.prime2=new w({valueHex:H.Convert.FromBase64Url(e.q)}),this.exponent1=new w({valueHex:H.Convert.FromBase64Url(e.dp)}),this.exponent2=new w({valueHex:H.Convert.FromBase64Url(e.dq)}),this.coefficient=new w({valueHex:H.Convert.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,t=>new Ea({json:t})))}};qi.CLASS_NAME="RSAPrivateKey";var ol="version",ll="privateKeyAlgorithm",ul="privateKey",Un="attributes",Nc="parsedKey",vp=[ol,ll,ul,Un],ts=class n extends C{constructor(e={}){super(),this.version=i(e,ol,n.defaultValues(ol)),this.privateKeyAlgorithm=i(e,ll,n.defaultValues(ll)),this.privateKey=i(e,ul,n.defaultValues(ul)),Un in e&&(this.attributes=i(e,Un,n.defaultValues(Un))),Nc in e&&(this.parsedKey=i(e,Nc,n.defaultValues(Nc))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ol:return 0;case ll:return new S;case ul:return new I;case Un:return[];case Nc:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),S.schema(t.privateKeyAlgorithm||{}),new I({name:t.privateKey||c}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:t.attributes||c,value:fe.schema()})]})]})}fromSchema(e){N(e,vp);let t=k(e,e,n.schema({names:{version:ol,privateKeyAlgorithm:{names:{blockName:ll}},privateKey:ul,attributes:Un}}));switch(A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new S({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,Un in t.result&&(this.attributes=Array.from(t.result.attributes,s=>new fe({schema:s}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{let s=ve(this.privateKey.valueBlock.valueHexView);s.offset!==-1&&(this.parsedKey=new qi({schema:s.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof O){let s=ve(this.privateKey.valueBlock.valueHexView);s.offset!==-1&&(this.parsedKey=new Mi({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:s.result}))}break}}toSchema(){let e=[new w({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,t=>t.toSchema())})),new f({value:e})}toJSON(){if(!this.parsedKey){let s={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(s.attributes=Array.from(this.attributes,a=>a.toJSON())),s}let e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA";break}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Mi({json:e}),this.privateKeyAlgorithm=new S({algorithmId:"1.2.840.10045.2.1",algorithmParams:new O({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new qi({json:e}),this.privateKeyAlgorithm=new S({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new le});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new I({valueHex:this.parsedKey.toSchema().toBER(!1)})}}};ts.CLASS_NAME="PrivateKeyInfo";var fr="contentType",mr="contentEncryptionAlgorithm",Ln="encryptedContent",wp=[fr,mr,Ln],_g=1024,ke=class n extends C{constructor(e={}){if(super(),this.contentType=i(e,fr,n.defaultValues(fr)),this.contentEncryptionAlgorithm=i(e,mr,n.defaultValues(mr)),Ln in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,this.encryptedContent.idBlock.tagClass===1&&this.encryptedContent.idBlock.tagNumber===4&&this.encryptedContent.idBlock.isConstructed===!1&&!e.disableSplit)){let t=new I({idBlock:{isConstructed:!0},isConstructed:!0}),s=0,a=this.encryptedContent.valueBlock.valueHexView.slice().buffer,r=a.byteLength;for(;r>0;){let o=new Uint8Array(a,s,s+_g>a.byteLength?a.byteLength-s:_g),u=new ArrayBuffer(o.length),l=new Uint8Array(u);for(let h=0;h<l.length;h++)l[h]=o[h];t.valueBlock.value.push(new I({valueHex:u})),r-=o.length,s+=o.length}this.encryptedContent=t}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fr:return c;case mr:return new S;case Ln:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fr:return t===c;case mr:return t.algorithmId===c&&!("algorithmParams"in t);case Ln:return t.isEqual(n.defaultValues(Ln));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.contentType||c}),S.schema(t.contentEncryptionAlgorithm||{}),new ie({value:[new p({name:t.encryptedContent||c,idBlock:{tagClass:3,tagNumber:0},value:[new _({value:new I})]}),new D({name:t.encryptedContent||c,idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){N(e,wp);let t=k(e,e,n.schema({names:{contentType:fr,contentEncryptionAlgorithm:{names:{blockName:mr}},encryptedContent:Ln}}));A.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new S({schema:t.result.contentEncryptionAlgorithm}),Ln in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){let e={isIndefiniteForm:!1},t=[];if(t.push(new O({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;let s=this.encryptedContent;s.idBlock.tagClass=3,s.idBlock.tagNumber=0,s.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(s)}return new f({lenBlock:e,value:t})}toJSON(){let e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw new Error("Parameter 'encryptedContent' is undefined");return I.prototype.getValue.call(this.encryptedContent)}};ke.CLASS_NAME="EncryptedContentInfo";var Is="hashAlgorithm",Vs="maskGenAlgorithm",Bs="saltLength",Ps="trailerField",Sp=[Is,Vs,Bs,Ps],Na=class n extends C{constructor(e={}){super(),this.hashAlgorithm=i(e,Is,n.defaultValues(Is)),this.maskGenAlgorithm=i(e,Vs,n.defaultValues(Vs)),this.saltLength=i(e,Bs,n.defaultValues(Bs)),this.trailerField=i(e,Ps,n.defaultValues(Ps)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Is:return new S({algorithmId:"1.3.14.3.2.26",algorithmParams:new le});case Vs:return new S({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new S({algorithmId:"1.3.14.3.2.26",algorithmParams:new le}).toSchema()});case Bs:return 20;case Ps:return 1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[S.schema(t.hashAlgorithm||{})]}),new p({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[S.schema(t.maskGenAlgorithm||{})]}),new p({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new w({name:t.saltLength||c})]}),new p({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new w({name:t.trailerField||c})]})]})}fromSchema(e){N(e,Sp);let t=k(e,e,n.schema({names:{hashAlgorithm:{names:{blockName:Is}},maskGenAlgorithm:{names:{blockName:Vs}},saltLength:Bs,trailerField:Ps}}));A.assertSchema(t,this.className),Is in t.result&&(this.hashAlgorithm=new S({schema:t.result.hashAlgorithm})),Vs in t.result&&(this.maskGenAlgorithm=new S({schema:t.result.maskGenAlgorithm})),Bs in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),Ps in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){let e=[];return this.hashAlgorithm.isEqual(n.defaultValues(Is))||e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(n.defaultValues(Vs))||e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==n.defaultValues(Bs)&&e.push(new p({idBlock:{tagClass:3,tagNumber:2},value:[new w({value:this.saltLength})]})),this.trailerField!==n.defaultValues(Ps)&&e.push(new p({idBlock:{tagClass:3,tagNumber:3},value:[new w({value:this.trailerField})]})),new f({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(n.defaultValues(Is))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(n.defaultValues(Vs))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==n.defaultValues(Bs)&&(e.saltLength=this.saltLength),this.trailerField!==n.defaultValues(Ps)&&(e.trailerField=this.trailerField),e}};Na.CLASS_NAME="RSASSAPSSParams";var gr="salt",cl="iterationCount",st="keyLength",Ht="prf",yp=[gr,cl,st,Ht],Zt=class n extends C{constructor(e={}){super(),this.salt=i(e,gr,n.defaultValues(gr)),this.iterationCount=i(e,cl,n.defaultValues(cl)),st in e&&(this.keyLength=i(e,st,n.defaultValues(st))),Ht in e&&(this.prf=i(e,Ht,n.defaultValues(Ht))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gr:return{};case cl:return-1;case st:return 0;case Ht:return new S({algorithmId:"1.3.14.3.2.26",algorithmParams:new le});default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new ie({value:[new I({name:t.saltPrimitive||c}),S.schema(t.saltConstructed||{})]}),new w({name:t.iterationCount||c}),new w({name:t.keyLength||c,optional:!0}),S.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){N(e,yp);let t=k(e,e,n.schema({names:{saltPrimitive:gr,saltConstructed:{names:{blockName:gr}},iterationCount:cl,keyLength:st,prf:{names:{blockName:Ht,optional:!0}}}}));A.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,st in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),Ht in t.result&&(this.prf=new S({schema:t.result.prf}))}toSchema(){let e=[];return e.push(this.salt),e.push(new w({value:this.iterationCount})),st in this&&n.defaultValues(st)!==this.keyLength&&e.push(new w({value:this.keyLength})),this.prf&&n.defaultValues(Ht).isEqual(this.prf)===!1&&e.push(this.prf.toSchema()),new f({value:e})}toJSON(){let e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return st in this&&n.defaultValues(st)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&n.defaultValues(Ht).isEqual(this.prf)===!1&&(e.prf=this.prf.toJSON()),e}};Zt.CLASS_NAME="PBKDF2Params";var hl="keyDerivationFunc",fl="encryptionScheme",Ap=[hl,fl],$i=class n extends C{constructor(e={}){super(),this.keyDerivationFunc=i(e,hl,n.defaultValues(hl)),this.encryptionScheme=i(e,fl,n.defaultValues(fl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case hl:return new S;case fl:return new S;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.keyDerivationFunc||{}),S.schema(t.encryptionScheme||{})]})}fromSchema(e){N(e,Ap);let t=k(e,e,n.schema({names:{keyDerivationFunc:{names:{blockName:hl}},encryptionScheme:{names:{blockName:fl}}}}));A.assertSchema(t,this.className),this.keyDerivationFunc=new S({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new S({schema:t.result.encryptionScheme})}toSchema(){return new f({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}};$i.CLASS_NAME="PBES2Params";var kh=class{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=i(e,"name",c)}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){if(e===null)throw new Error('Argument "array" must not be null');return this.crypto.getRandomValues(e)}};async function Kg(n,e,t,s,a){let r,o,u;switch(n.toUpperCase()){case"SHA-1":r=20,o=64,u=Ug;break;case"SHA-256":r=32,o=64,u=lf;break;case"SHA-384":r=48,o=128,u=ff;break;case"SHA-512":r=64,o=128,u=hf;break;default:throw new Error("Unsupported hashing algorithm")}let l=new Uint8Array(t),h=new TextDecoder().decode(t);new TextEncoder().encode(h).some((B,x)=>B!==l[x])&&(h=String.fromCharCode(...l));let g=new Uint8Array(h.length*2+2),d=new DataView(g.buffer);for(let B=0;B<h.length;B++)d.setUint16(B*2,h.charCodeAt(B),!1);d.setUint16(h.length*2,0,!1);let b=new Uint8Array(o).fill(3),y=new Uint8Array(s),E=new Uint8Array(o*Math.ceil(y.length/o)).map((B,x)=>y[x%y.length]),v=new Uint8Array(o*Math.ceil(g.length/o)).map((B,x)=>g[x%g.length]),j=new Uint8Array(E.length+v.length);j.set(E),j.set(v,E.length);let P=Math.ceil((e>>3)/r),V=[];for(let B=0;B<P;B++){let x=new Uint8Array(b.length+j.length);x.set(b),x.set(j,b.length);for(let X=0;X<a;X++)x=u(x);let K=new Uint8Array(o).map((X,me)=>x[me%x.length]),ee=Math.ceil(y.length/o)+Math.ceil(g.length/o),$=[];for(let X=0;X<ee;X++){let me=Array.from(j.slice(X*o,(X+1)*o)),z=511;for(let ae=K.length-1;ae>=0;ae--)z>>=8,z+=K[ae]+(me[ae]||0),me[ae]=z&255;$.push(...me)}j=new Uint8Array($),V.push(...x)}return new Uint8Array(V.slice(0,e>>3)).buffer}function kd(n){let e=typeof n=="string"?{name:n}:n;return"hash"in e?{...e,hash:kd(e.hash)}:e}var Oa=class extends kh{async importKey(e,t,s,a,r){var o,u,l,h,m,g;let d={},b=kd(s);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,s,a,r);case"spki":{let y=ve(H.BufferSourceConverter.toArrayBuffer(t));A.assert(y,"keyData");let E=new qe;try{E.fromSchema(y.result)}catch(v){throw new se("Incorrect keyData")}switch(b.name.toUpperCase()){case"RSA-PSS":{if(!b.hash)throw new Q("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(b.hash.name.toUpperCase()){case"SHA-1":d.alg="PS1";break;case"SHA-256":d.alg="PS256";break;case"SHA-384":d.alg="PS384";break;case"SHA-512":d.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${b.hash.name.toUpperCase()}`)}}case"RSASSA-PKCS1-V1_5":{if(r=["verify"],d.kty="RSA",d.ext=a,d.key_ops=r,E.algorithm.algorithmId!=="1.2.840.113549.1.1.1")throw new Error(`Incorrect public key algorithm: ${E.algorithm.algorithmId}`);if(!d.alg){if(!b.hash)throw new Q("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(b.hash.name.toUpperCase()){case"SHA-1":d.alg="RS1";break;case"SHA-256":d.alg="RS256";break;case"SHA-384":d.alg="RS384";break;case"SHA-512":d.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${b.hash.name.toUpperCase()}`)}}let v=E.toJSON();Object.assign(d,v)}break;case"ECDSA":r=["verify"];case"ECDH":{if(d={kty:"EC",ext:a,key_ops:r},E.algorithm.algorithmId!=="1.2.840.10045.2.1")throw new Error(`Incorrect public key algorithm: ${E.algorithm.algorithmId}`);let v=E.toJSON();Object.assign(d,v)}break;case"RSA-OAEP":{if(d.kty="RSA",d.ext=a,d.key_ops=r,this.name.toLowerCase()==="safari")d.alg="RSA-OAEP";else{if(!b.hash)throw new Q("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(b.hash.name.toUpperCase()){case"SHA-1":d.alg="RSA-OAEP";break;case"SHA-256":d.alg="RSA-OAEP-256";break;case"SHA-384":d.alg="RSA-OAEP-384";break;case"SHA-512":d.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${b.hash.name.toUpperCase()}`)}}let v=E.toJSON();Object.assign(d,v)}break;case"RSAES-PKCS1-V1_5":{d.kty="RSA",d.ext=a,d.key_ops=r,d.alg="PS1";let v=E.toJSON();Object.assign(d,v)}break;default:throw new Error(`Incorrect algorithm name: ${b.name.toUpperCase()}`)}}break;case"pkcs8":{let y=new ts,E=ve(H.BufferSourceConverter.toArrayBuffer(t));A.assert(E,"keyData");try{y.fromSchema(E.result)}catch(v){throw new Error("Incorrect keyData")}if(!y.parsedKey)throw new Error("Incorrect keyData");switch(b.name.toUpperCase()){case"RSA-PSS":switch((o=b.hash)===null||o===void 0?void 0:o.name.toUpperCase()){case"SHA-1":d.alg="PS1";break;case"SHA-256":d.alg="PS256";break;case"SHA-384":d.alg="PS384";break;case"SHA-512":d.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${(u=b.hash)===null||u===void 0?void 0:u.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(r=["sign"],d.kty="RSA",d.ext=a,d.key_ops=r,y.privateKeyAlgorithm.algorithmId!=="1.2.840.113549.1.1.1")throw new Error(`Incorrect private key algorithm: ${y.privateKeyAlgorithm.algorithmId}`);if(!("alg"in d))switch((l=b.hash)===null||l===void 0?void 0:l.name.toUpperCase()){case"SHA-1":d.alg="RS1";break;case"SHA-256":d.alg="RS256";break;case"SHA-384":d.alg="RS384";break;case"SHA-512":d.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${(h=b.hash)===null||h===void 0?void 0:h.name.toUpperCase()}`)}let v=y.toJSON();Object.assign(d,v)}break;case"ECDSA":r=["sign"];case"ECDH":{if(d={kty:"EC",ext:a,key_ops:r},y.privateKeyAlgorithm.algorithmId!=="1.2.840.10045.2.1")throw new Error(`Incorrect algorithm: ${y.privateKeyAlgorithm.algorithmId}`);let v=y.toJSON();Object.assign(d,v)}break;case"RSA-OAEP":{if(d.kty="RSA",d.ext=a,d.key_ops=r,this.name.toLowerCase()==="safari")d.alg="RSA-OAEP";else switch((m=b.hash)===null||m===void 0?void 0:m.name.toUpperCase()){case"SHA-1":d.alg="RSA-OAEP";break;case"SHA-256":d.alg="RSA-OAEP-256";break;case"SHA-384":d.alg="RSA-OAEP-384";break;case"SHA-512":d.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${(g=b.hash)===null||g===void 0?void 0:g.name.toUpperCase()}`)}let v=y.toJSON();Object.assign(d,v)}break;case"RSAES-PKCS1-V1_5":{r=["decrypt"],d.kty="RSA",d.ext=a,d.key_ops=r,d.alg="PS1";let v=y.toJSON();Object.assign(d,v)}break;default:throw new Error(`Incorrect algorithm name: ${b.name.toUpperCase()}`)}}break;case"jwk":d=t;break;default:throw new Error(`Incorrect format: ${e}`)}if(this.name.toLowerCase()==="safari")try{return this.subtle.importKey("jwk",vn(JSON.stringify(d)),s,a,r)}catch(y){return this.subtle.importKey("jwk",d,s,a,r)}return this.subtle.importKey("jwk",d,s,a,r)}async exportKey(e,t){let s=await this.subtle.exportKey("jwk",t);switch(this.name.toLowerCase()==="safari"&&s instanceof ArrayBuffer&&(s=JSON.parse(eo(s))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{let a=new qe;try{a.fromJSON(s)}catch(r){throw new Error("Incorrect key data")}return a.toSchema().toBER(!1)}case"pkcs8":{let a=new ts;try{a.fromJSON(s)}catch(r){throw new Error("Incorrect key data")}return a.toSchema().toBER(!1)}case"jwk":return s;default:throw new Error(`Incorrect format: ${e}`)}}async convert(e,t,s,a,r,o){if(e.toLowerCase()===t.toLowerCase())return s;let u=await this.importKey(e,s,a,r,o);return this.exportKey(t,u)}getAlgorithmByOID(e,t=!1,s){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw new Error(`Unsupported algorithm identifier ${s?`for ${s} `:c}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,s){let a=c;switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":a="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":a="1.2.840.113549.1.1.5";break;case"SHA-256":a="1.2.840.113549.1.1.11";break;case"SHA-384":a="1.2.840.113549.1.1.12";break;case"SHA-512":a="1.2.840.113549.1.1.13";break}break;case"RSA-PSS":a="1.2.840.113549.1.1.10";break;case"RSA-OAEP":a="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":a="1.2.840.10045.4.1";break;case"SHA-256":a="1.2.840.10045.4.3.2";break;case"SHA-384":a="1.2.840.10045.4.3.3";break;case"SHA-512":a="1.2.840.10045.4.3.4";break}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":a="1.3.133.16.840.63.0.2";break;case"SHA-256":a="1.3.132.1.11.1";break;case"SHA-384":a="1.3.132.1.11.2";break;case"SHA-512":a="1.3.132.1.11.3";break}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:a="2.16.840.1.101.3.4.1.2";break;case 192:a="2.16.840.1.101.3.4.1.22";break;case 256:a="2.16.840.1.101.3.4.1.42";break}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:a="2.16.840.1.101.3.4.1.6";break;case 192:a="2.16.840.1.101.3.4.1.26";break;case 256:a="2.16.840.1.101.3.4.1.46";break}break;case"AES-CFB":switch(e.length){case 128:a="2.16.840.1.101.3.4.1.4";break;case 192:a="2.16.840.1.101.3.4.1.24";break;case 256:a="2.16.840.1.101.3.4.1.44";break}break;case"AES-KW":switch(e.length){case 128:a="2.16.840.1.101.3.4.1.5";break;case 192:a="2.16.840.1.101.3.4.1.25";break;case 256:a="2.16.840.1.101.3.4.1.45";break}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":a="1.2.840.113549.2.7";break;case"SHA-256":a="1.2.840.113549.2.9";break;case"SHA-384":a="1.2.840.113549.2.10";break;case"SHA-512":a="1.2.840.113549.2.11";break}break;case"DH":a="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":a="1.3.14.3.2.26";break;case"SHA-256":a="2.16.840.1.101.3.4.2.1";break;case"SHA-384":a="2.16.840.1.101.3.4.2.2";break;case"SHA-512":a="2.16.840.1.101.3.4.2.3";break;case"CONCAT":break;case"HKDF":break;case"PBKDF2":a="1.2.840.113549.1.5.12";break;case"P-256":a="1.2.840.10045.3.1.7";break;case"P-384":a="1.3.132.0.34";break;case"P-521":a="1.3.132.0.35";break}if(!a&&t)throw new Error(`Unsupported algorithm ${s?`for ${s} `:c}: ${e.name}`);return a}getAlgorithmParameters(e,t){let s={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":s={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":s={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":s={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":s={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":s={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":s={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":s={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":s={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":s={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":s={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}break}return s}getHashAlgorithm(e){let t=c;switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{let s=new Na({schema:e.algorithmParams});if(s.hashAlgorithm){let a=this.getAlgorithmByOID(s.hashAlgorithm.algorithmId);if("name"in a)t=a.name;else return c}else t="SHA-1"}catch(s){}break}return t}async encryptEncryptedContentInfo(e){Q.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");let t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),s=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),a=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),r=new ArrayBuffer(16),o=new Uint8Array(r);this.getRandomValues(o);let u=new ArrayBuffer(64),l=new Uint8Array(u);this.getRandomValues(l);let h=new Uint8Array(e.contentToEncrypt),m=new Zt({salt:new I({valueHex:u}),iterationCount:e.iterationCount,prf:new S({algorithmId:a,algorithmParams:new le})}),g=new Uint8Array(e.password),d=await this.importKey("raw",g,"PBKDF2",!1,["deriveKey"]),b=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},d,e.contentEncryptionAlgorithm,!1,["encrypt"]),y=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:o},b,h),E=new $i({keyDerivationFunc:new S({algorithmId:s,algorithmParams:m.toSchema()}),encryptionScheme:new S({algorithmId:t,algorithmParams:new I({valueHex:r})})});return new ke({contentType:e.contentType,contentEncryptionAlgorithm:new S({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:E.toSchema()}),encryptedContent:new I({valueHex:y})})}async decryptEncryptedContentInfo(e){if(Q.assert(e,"password","encryptedContentInfo"),e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId!=="1.2.840.113549.1.5.13")throw new Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t;try{t=new $i({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(y){throw new Error('Incorrectly encoded "pbes2Parameters"')}let s;try{s=new Zt({schema:t.keyDerivationFunc.algorithmParams})}catch(y){throw new Error('Incorrectly encoded "pbkdf2Params"')}let a=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),r=t.encryptionScheme.algorithmParams.valueBlock.valueHex,o=new Uint8Array(r),u=s.salt.valueBlock.valueHex,l=new Uint8Array(u),h=s.iterationCount,m="SHA-1";s.prf&&(m=this.getAlgorithmByOID(s.prf.algorithmId,!0).hash.name);let g=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),d=await this.deriveKey({name:"PBKDF2",hash:{name:m},salt:l,iterations:h},g,a,!1,["decrypt"]),b=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:a.name,iv:o},d,b)}async stampDataWithPassword(e){if(!(e instanceof Object))throw new Error('Parameters must have type "Object"');Q.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp");let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},a=await Kg(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(a),s,!1,["sign"]);return this.sign(s,r,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){Q.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},a=await Kg(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(a),s,!1,["verify"]);return this.verify(s,r,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");let s=new S,a=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(a.algorithm).length)throw new Error("Parameter 'algorithm' is empty");let r=a.algorithm;switch("hash"in e.algorithm&&e.algorithm.hash&&e.algorithm.hash.name?r.hash.name=e.algorithm.hash.name:r.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(r,!0);break;case"RSA-PSS":{switch(r.hash.name.toUpperCase()){case"SHA-256":r.saltLength=32;break;case"SHA-384":r.saltLength=48;break;case"SHA-512":r.saltLength=64;break}let o={};if(r.hash.name.toUpperCase()!=="SHA-1"){let l=this.getOIDByAlgorithm({name:r.hash.name},!0,"hashAlgorithm");o.hashAlgorithm=new S({algorithmId:l,algorithmParams:new le}),o.maskGenAlgorithm=new S({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:o.hashAlgorithm.toSchema()})}r.saltLength!==20&&(o.saltLength=r.saltLength);let u=new Na(o);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=u.toSchema()}break;default:throw new Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:s,parameters:a}}async signWithPrivateKey(e,t,s){let a=await this.sign(s.algorithm,t,e);return s.algorithm.name==="ECDSA"?Nd(a):a}fillPublicKeyParameters(e,t){let s={},a=this.getHashAlgorithm(t);if(a===c)throw new Error(`Unsupported signature algorithm: ${t.algorithmId}`);let r;t.algorithmId==="1.2.840.113549.1.1.10"?r=t.algorithmId:r=e.algorithm.algorithmId;let o=this.getAlgorithmByOID(r,!0);if(s.algorithm=this.getAlgorithmParameters(o.name,"importKey"),"hash"in s.algorithm.algorithm&&(s.algorithm.algorithm.hash.name=a),o.name==="ECDSA"){let u=e.algorithm;if(!u.algorithmParams)throw new Error("Algorithm parameters for ECDSA public key are missed");let l=u.algorithmParams;if("idBlock"in u.algorithmParams&&!(l.idBlock.tagClass===1&&l.idBlock.tagNumber===6))throw new Error("Incorrect type for ECDSA public key parameters");let h=this.getAlgorithmByOID(l.valueBlock.toString(),!0);s.algorithm.algorithm.namedCurve=h.name}return s}async getPublicKey(e,t,s){s||(s=this.fillPublicKeyParameters(e,t));let a=e.toSchema().toBER(!1);return this.importKey("spki",a,s.algorithm.algorithm,!0,s.algorithm.usages)}async verifyWithPublicKey(e,t,s,a,r){let o;if(r){let h={},m;a.algorithmId==="1.2.840.113549.1.1.10"?m=a.algorithmId:m=s.algorithm.algorithmId;let g=this.getAlgorithmByOID(m,!0);if(h.algorithm=this.getAlgorithmParameters(g.name,"importKey"),"hash"in h.algorithm.algorithm&&(h.algorithm.algorithm.hash.name=r),g.name==="ECDSA"){let d=!1;if("algorithmParams"in s.algorithm&&"idBlock"in s.algorithm.algorithmParams&&s.algorithm.algorithmParams.idBlock.tagClass===1&&s.algorithm.algorithmParams.idBlock.tagNumber===6&&(d=!0),d===!1)throw new Error("Incorrect type for ECDSA public key parameters");let b=this.getAlgorithmByOID(s.algorithm.algorithmParams.valueBlock.toString(),!0);h.algorithm.algorithm.namedCurve=b.name}o=await this.getPublicKey(s,null,h)}else{if(r=this.getHashAlgorithm(a),!r)throw new Error(`Unsupported signature algorithm: ${a.algorithmId}`);o=await this.getPublicKey(s,a)}let u=this.getAlgorithmParameters(o.algorithm.name,"verify");"hash"in u.algorithm&&(u.algorithm.hash.name=r);let l=t.valueBlock.valueHexView;if(o.algorithm.name==="ECDSA"){let h=it.find(o.algorithm.namedCurve);if(!h)throw new Error("Unsupported named curve in use");let m=ve(l);A.assert(m,"Signature value"),l=Id(m.result,h.size)}if(o.algorithm.name==="RSA-PSS"){let h=new Na({schema:a.algorithmParams});"saltLength"in h?u.algorithm.saltLength=h.saltLength:u.algorithm.saltLength=20;let m="SHA-1";"hashAlgorithm"in h&&(m=this.getAlgorithmByOID(h.hashAlgorithm.algorithmId,!0).name),u.algorithm.hash.name=m}return this.verify(u.algorithm,o,l,e)}},Om={name:"none",crypto:null};function Mg(n){return!!(n&&typeof n=="object"&&"crypto"in n)}function Gf(n,...e){let t=null;if(e.length<2)e.length?t=e[0]:t=typeof self!="undefined"&&self.crypto?new Oa({name:"browser",crypto:self.crypto}):null;else{let s=e[0],a=e[1];Mg(a)?t=a:Mg(s)?t=s:"subtle"in s&&"getRandomValues"in s&&(t=new Oa({crypto:s}))}if(typeof process!="undefined"&&"pid"in process&&typeof global!="undefined"&&typeof window=="undefined"){if(typeof global[process.pid]=="undefined")global[process.pid]={};else if(typeof global[process.pid]!="object")throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(typeof global[process.pid].pkijs=="undefined")global[process.pid].pkijs={};else if(typeof global[process.pid].pkijs!="object")throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:n,crypto:t}}else Om={name:n,crypto:t}}function Ed(){if(typeof process!="undefined"&&"pid"in process&&typeof global!="undefined"&&typeof window=="undefined"){let n;try{n=global[process.pid].pkijs.engine}catch(e){throw new Error("Please call 'setEngine' before call to 'getEngine'")}return n}return Om}function q(n=!1){let e=Ed();if(!e.crypto&&n)throw new Error("Unable to create WebCrypto object");return e.crypto}function bp(n){return q(!0).getRandomValues(n)}function Cp(n,e,t){return q(!0).getOIDByAlgorithm(n,e,t)}function kp(n,e){return q(!0).getAlgorithmParameters(n,e)}function Nd(n){if(n.byteLength%2!==0)return we;let e=n.byteLength/2,t=new ArrayBuffer(e);new Uint8Array(t).set(new Uint8Array(n,0,e));let a=new w({valueHex:t}),r=new ArrayBuffer(e);new Uint8Array(r).set(new Uint8Array(n,e,e));let u=new w({valueHex:r});return new f({value:[a.convertToDER(),u.convertToDER()]}).toBER(!1)}function Id(n,e){if(!(n instanceof f&&n.valueBlock.value.length===2&&n.valueBlock.value[0]instanceof w&&n.valueBlock.value[1]instanceof w))return we;let t=n.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,s=n.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,a=new Uint8Array(e*2);return a.set(t,e-t.byteLength),a.set(s,2*e-s.byteLength),a.buffer}function Ep(n,e=!1,t){return q(!0).getAlgorithmByOID(n,e,t)}function Np(n){return q(!0).getHashAlgorithm(n)}async function Ip(n,e,t,s,a){switch(n.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new se(`Unknown hash function: ${n}`)}if(se.assert(e,"zBuffer","ArrayBuffer"),e.byteLength===0)throw new se("'zBuffer' has zero length, error");if(se.assert(s,"SharedInfo","ArrayBuffer"),t>255)throw new se("Please set 'Counter' argument to value less or equal to 255");let r=new ArrayBuffer(4),o=new Uint8Array(r);o[0]=0,o[1]=0,o[2]=0,o[3]=t;let u=we;u=pn(u,e),u=pn(u,r),u=pn(u,s);let l=await a.digest({name:n},u);return{counter:t,result:l}}async function Wf(n,e,t,s,a=q(!0)){let r=0,o=1;switch(n.toUpperCase()){case"SHA-1":r=160;break;case"SHA-256":r=256;break;case"SHA-384":r=384;break;case"SHA-512":r=512;break;default:throw new se(`Unknown hash function: ${n}`)}if(se.assert(e,"Zbuffer","ArrayBuffer"),e.byteLength===0)throw new se("'Zbuffer' has zero length, error");se.assert(s,"SharedInfo","ArrayBuffer");let u=t/r;Math.floor(u)>0&&(o=Math.floor(u),u-o>0&&o++);let l=[];for(let d=1;d<=o;d++)l.push(await Ip(n,e,d,s,a));let h=we,m=1,g=!0;for(;g;){g=!1;for(let d of l)if(d.counter===m){h=pn(h,d.result),g=!0;break}m++}if(t>>=3,h.byteLength>t){let d=new ArrayBuffer(t),b=new Uint8Array(d),y=new Uint8Array(h);for(let E=0;E<t;E++)b[E]=y[E];return d}return h}var pf="version",vf="logID",wf="extensions",Sf="timestamp",yf="hashAlgorithm",Af="signatureAlgorithm",bf="signature",qg="none",$g="md5",Jg="sha1",Fg="sha224",Gg="sha256",Wg="sha384",Yg="sha512",Qg="anonymous",Xg="rsa",zg="dsa",Zg="ecdsa",Ou=class n extends C{constructor(e={}){super(),this.version=i(e,pf,n.defaultValues(pf)),this.logID=i(e,vf,n.defaultValues(vf)),this.timestamp=i(e,Sf,n.defaultValues(Sf)),this.extensions=i(e,wf,n.defaultValues(wf)),this.hashAlgorithm=i(e,yf,n.defaultValues(yf)),this.signatureAlgorithm=i(e,Af,n.defaultValues(Af)),this.signature=i(e,bf,n.defaultValues(bf)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pf:return 0;case vf:case wf:return we;case Sf:return new Date(0);case yf:case Af:return c;case bf:return we;default:return super.defaultValues(e)}}fromSchema(e){if(!(e instanceof us))throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");let t=new mt({stream:new Ve({buffer:e.data})});this.fromStream(t)}fromStream(e){let t=e.getUint16();if(this.version=e.getBlock(1)[0],this.version===0){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(It(new Uint8Array(e.getBlock(8)),8));let s=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(s)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=qg;break;case 1:this.hashAlgorithm=$g;break;case 2:this.hashAlgorithm=Jg;break;case 3:this.hashAlgorithm=Fg;break;case 4:this.hashAlgorithm=Gg;break;case 5:this.hashAlgorithm=Wg;break;case 6:this.hashAlgorithm=Yg;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=Qg;break;case 1:this.signatureAlgorithm=Xg;break;case 2:this.signatureAlgorithm=zg;break;case 3:this.signatureAlgorithm=Zg;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}let a=e.getUint16();if(this.signature=new Uint8Array(e.getBlock(a)).buffer.slice(0),t!==47+s+a)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){let e=this.toStream();return new us({data:e.stream.buffer})}toStream(){let e=new mt;e.appendUint16(47+this.extensions.byteLength+this.signature.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));let t=new ArrayBuffer(8),s=new Uint8Array(t),a=ze(this.timestamp.valueOf(),8);s.set(new Uint8Array(a),8-a.byteLength),e.appendView(s),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions));let r;switch(this.hashAlgorithm.toLowerCase()){case qg:r=0;break;case $g:r=1;break;case Jg:r=2;break;case Fg:r=3;break;case Gg:r=4;break;case Wg:r=5;break;case Yg:r=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}e.appendChar(r);let o;switch(this.signatureAlgorithm.toLowerCase()){case Qg:o=0;break;case Xg:o=1;break;case zg:o=2;break;case Zg:o=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}return e.appendChar(o),e.appendUint16(this.signature.byteLength),e.appendView(new Uint8Array(this.signature)),e}toJSON(){return{version:this.version,logID:Yu(this.logID),timestamp:this.timestamp,extensions:Yu(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:Yu(this.signature)}}async verify(e,t,s=0,a=q(!0)){let r=Xu(eo(this.logID)),o=null,u=new mt;for(let b of e)if(b.log_id===r){o=b.key;break}if(!o)throw new Error(`Public key not found for CT with logId: ${r}`);let l=vn(Wa(o)),h=qe.fromBER(l);u.appendChar(0),u.appendChar(0);let m=new ArrayBuffer(8),g=new Uint8Array(m),d=ze(this.timestamp.valueOf(),8);return g.set(new Uint8Array(d),8-d.byteLength),u.appendView(g),u.appendUint16(s),s===0&&u.appendUint24(t.byteLength),u.appendView(new Uint8Array(t)),u.appendUint16(this.extensions.byteLength),this.extensions.byteLength!==0&&u.appendView(new Uint8Array(this.extensions)),a.verifyWithPublicKey(u.buffer.slice(0,u.length),new I({valueHex:this.signature}),h,{algorithmId:c},"SHA-256")}};Ou.CLASS_NAME="SignedCertificateTimestamp";async function Vp(n,e,t,s=-1,a=q(!0)){let r=null,o=new mt;if(n.extensions)for(let m=n.extensions.length-1;m>=0;m--)switch(n.extensions[m].extnID){case Bm:{if(r=n.extensions[m].parsedValue,!r||r.timestamps.length===0)throw new Error("Nothing to verify in the certificate");n.extensions.splice(m,1)}break}if(r===null)throw new Error("No SignedCertificateTimestampList extension in the specified certificate");let u=n.encodeTBS().toBER(),l=await a.digest({name:"SHA-256"},new Uint8Array(e.subjectPublicKeyInfo.toSchema().toBER(!1)));o.appendView(new Uint8Array(l)),o.appendUint24(u.byteLength),o.appendView(new Uint8Array(u));let h=o.stream.slice(0,o.length);if(s===-1){let m=[];for(let g of r.timestamps){let d=await g.verify(t,h.buffer,1,a);m.push(d)}return m}return s>=r.timestamps.length&&(s=r.timestamps.length-1),[await r.timestamps[s].verify(t,h.buffer,1,a)]}var Ic="timestamps",Ru=class n extends C{constructor(e={}){super(),this.timestamps=i(e,Ic,n.defaultValues(Ic)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ic:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ic:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){var t;let s=i(e,"names",{});return(t=s.optional)!==null&&t!==void 0||(s.optional=!1),new I({name:s.blockName||"SignedCertificateTimestampList",optional:s.optional})}fromSchema(e){if(!(e instanceof I))throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");let t=new mt({stream:new Ve({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new Ou({stream:t}))}toSchema(){let e=new mt,t=0,s=[];for(let a of this.timestamps){let r=a.toStream();s.push(r),t+=r.stream.buffer.byteLength}e.appendUint16(t);for(let a of s)e.appendView(a.stream.view);return new I({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}};Ru.CLASS_NAME="SignedCertificateTimestampList";var ml="attributes",Bp=[ml],Tu=class n extends C{constructor(e={}){super(),this.attributes=i(e,ml,n.defaultValues(ml)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ml:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.attributes||c,value:fe.schema()})]})}fromSchema(e){N(e,Bp);let t=k(e,e,n.schema({names:{attributes:ml}}));A.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,s=>new fe({schema:s}))}toSchema(){return new f({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}};Tu.CLASS_NAME="SubjectDirectoryAttributes";var Eh=class n{static getItems(){return this.types||(this.types={},n.register(ym,"SubjectAltName",Pi),n.register(Am,"IssuerAltName",Pi),n.register(Jh,"AuthorityKeyIdentifier",ji),n.register(qh,"BasicConstraints",xi),n.register(pd,"MicrosoftCaVersion",Eu),n.register(Nm,"CertificatePolicies",Ti),n.register(hd,"CertificatePoliciesMicrosoft",Ti),n.register(dd,"MicrosoftCertTemplateV2",Ch),n.register(Em,"CRLDistributionPoints",Ui),n.register($h,"FreshestCRL",Ui),n.register(fd,"ExtKeyUsage",Nu),n.register(Cm,"CertificateIssuer",ye),n.register(Fh,"AuthorityInfoAccess",Li),n.register(gd,"SubjectInfoAccess",Li),n.register(bm,"IssuingDistributionPoint",Iu),n.register(km,"NameConstraints",Vu),n.register(Vm,"PolicyConstraints",Bu),n.register(Im,"PolicyMappings",Pu),n.register(id,"PrivateKeyUsagePeriod",ju),n.register(vd,"QCStatements",xu),n.register(Bm,"SignedCertificateTimestampList",Ru),n.register(nd,"SubjectDirectoryAttributes",Tu)),this.types}static fromBER(e,t){let s=ve(t);if(s.offset===-1)return null;let a=this.find(e);if(a)try{return new a.type({schema:s.result})}catch(r){let o=new a.type;return o.parsingError=`Incorrectly formatted value of extension ${a.name} (${e})`,o}return s.result}static find(e){return this.getItems()[e]||null}static register(e,t,s){this.getItems()[e]={name:t,type:s}}},gl="extnID",js="critical",dl="extnValue",Vc="parsedValue",Pp=[gl,js,dl],Ue=class n extends C{get parsedValue(){if(this._parsedValue===void 0){let e=Eh.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}constructor(e={}){super(),this.extnID=i(e,gl,n.defaultValues(gl)),this.critical=i(e,js,n.defaultValues(js)),dl in e?this.extnValue=new I({valueHex:e.extnValue}):this.extnValue=n.defaultValues(dl),Vc in e&&(this.parsedValue=i(e,Vc,n.defaultValues(Vc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gl:return c;case js:return!1;case dl:return new I;case Vc:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.extnID||c}),new Ke({name:t.critical||c,optional:!0}),new I({name:t.extnValue||c})]})}fromSchema(e){N(e,Pp);let t=k(e,e,n.schema({names:{extnID:gl,critical:js,extnValue:dl}}));A.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),js in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){let e=[];return e.push(new O({value:this.extnID})),this.critical!==n.defaultValues(js)&&e.push(new Ke({value:this.critical})),e.push(this.extnValue),new f({value:e})}toJSON(){let e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==n.defaultValues(js)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}};Ue.CLASS_NAME="Extension";var pl="extensions",jp=[pl],Se=class n extends C{constructor(e={}){super(),this.extensions=i(e,pl,n.defaultValues(pl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pl:return[];default:return super.defaultValues(e)}}static schema(e={},t=!1){let s=i(e,"names",{});return new f({optional:t,name:s.blockName||c,value:[new _({name:s.extensions||c,value:Ue.schema(s.extension||{})})]})}fromSchema(e){N(e,jp);let t=k(e,e,n.schema({names:{extensions:pl}}));A.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,s=>new Ue({schema:s}))}toSchema(){return new f({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:this.extensions.map(e=>e.toJSON())}}};Se.CLASS_NAME="Extensions";var vl="issuer",wl="serialNumber",Hn="issuerUID",xp=[vl,wl,Hn],Je=class n extends C{constructor(e={}){super(),this.issuer=i(e,vl,n.defaultValues(vl)),this.serialNumber=i(e,wl,n.defaultValues(wl)),Hn in e&&(this.issuerUID=i(e,Hn,n.defaultValues(Hn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vl:return new ye;case wl:return new w;case Hn:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[ye.schema(t.issuer||{}),new w({name:t.serialNumber||c}),new F({optional:!0,name:t.issuerUID||c})]})}fromSchema(e){N(e,xp);let t=k(e,e,n.schema({names:{issuer:{names:{blockName:vl}},serialNumber:wl,issuerUID:Hn}}));A.assertSchema(t,this.className),this.issuer=new ye({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,Hn in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){let e=new f({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){let e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}};Je.CLASS_NAME="IssuerSerial";var Sl="version",_n="baseCertificateID",Kn="subjectName",yl="issuer",Al="signature",bl="serialNumber",Cl="attrCertValidityPeriod",kl="attributes",Mn="issuerUniqueID",qn="extensions",Op=[Sl,_n,Kn,yl,Al,bl,Cl,kl,Mn,qn],Ia=class n extends C{constructor(e={}){super(),this.version=i(e,Sl,n.defaultValues(Sl)),_n in e&&(this.baseCertificateID=i(e,_n,n.defaultValues(_n))),Kn in e&&(this.subjectName=i(e,Kn,n.defaultValues(Kn))),this.issuer=i(e,yl,n.defaultValues(yl)),this.signature=i(e,Al,n.defaultValues(Al)),this.serialNumber=i(e,bl,n.defaultValues(bl)),this.attrCertValidityPeriod=i(e,Cl,n.defaultValues(Cl)),this.attributes=i(e,kl,n.defaultValues(kl)),Mn in e&&(this.issuerUniqueID=i(e,Mn,n.defaultValues(Mn))),qn in e&&(this.extensions=i(e,qn,n.defaultValues(qn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Sl:return 0;case _n:return new Je;case Kn:return new ye;case yl:return new ye;case Al:return new S;case bl:return new w;case Cl:return new yt;case kl:return[];case Mn:return new F;case qn:return new Se;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new ie({value:[new p({name:t.baseCertificateID||c,idBlock:{tagClass:3,tagNumber:0},value:Je.schema().valueBlock.value}),new p({name:t.subjectName||c,idBlock:{tagClass:3,tagNumber:1},value:ye.schema().valueBlock.value})]}),ye.schema({names:{blockName:t.issuer||c}}),S.schema(t.signature||{}),new w({name:t.serialNumber||c}),yt.schema(t.attrCertValidityPeriod||{}),new f({name:t.attributes||c,value:[new _({value:fe.schema()})]}),new F({optional:!0,name:t.issuerUniqueID||c}),Se.schema(t.extensions||{},!0)]})}fromSchema(e){N(e,Op);let t=k(e,e,n.schema({names:{version:Sl,baseCertificateID:_n,subjectName:Kn,issuer:yl,signature:{names:{blockName:Al}},serialNumber:bl,attrCertValidityPeriod:{names:{blockName:Cl}},attributes:kl,issuerUniqueID:Mn,extensions:{names:{blockName:qn}}}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,_n in t.result&&(this.baseCertificateID=new Je({schema:new f({value:t.result.baseCertificateID.valueBlock.value})})),Kn in t.result&&(this.subjectName=new ye({schema:new f({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new S({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new yt({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,s=>new fe({schema:s})),Mn in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),qn in t.result&&(this.extensions=new Se({schema:t.result.extensions}))}toSchema(){let e=new f({value:[new w({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new f({value:Array.from(this.attributes,t=>t.toSchema())})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,t=>t.toJSON()),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}};Ia.CLASS_NAME="AttributeCertificateInfoV1";var El="acinfo",Nl="signatureAlgorithm",Il="signatureValue",Rp=[El,Il,Nl],Ra=class n extends C{constructor(e={}){super(),this.acinfo=i(e,El,n.defaultValues(El)),this.signatureAlgorithm=i(e,Nl,n.defaultValues(Nl)),this.signatureValue=i(e,Il,n.defaultValues(Il)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case El:return new Ia;case Nl:return new S;case Il:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[Ia.schema(t.acinfo||{}),S.schema(t.signatureAlgorithm||{}),new F({name:t.signatureValue||c})]})}fromSchema(e){N(e,Rp);let t=k(e,e,n.schema({names:{acinfo:{names:{blockName:El}},signatureAlgorithm:{names:{blockName:Nl}},signatureValue:Il}}));A.assertSchema(t,this.className),this.acinfo=new Ia({schema:t.result.acinfo}),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new f({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}};Ra.CLASS_NAME="AttributeCertificateV1";var Vl="digestedObjectType",$n="otherObjectTypeID",Bl="digestAlgorithm",Pl="objectDigest",Tp=[Vl,$n,Bl,Pl],At=class n extends C{constructor(e={}){super(),this.digestedObjectType=i(e,Vl,n.defaultValues(Vl)),$n in e&&(this.otherObjectTypeID=i(e,$n,n.defaultValues($n))),this.digestAlgorithm=i(e,Bl,n.defaultValues(Bl)),this.objectDigest=i(e,Pl,n.defaultValues(Pl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vl:return new Ze;case $n:return new O;case Bl:return new S;case Pl:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new Ze({name:t.digestedObjectType||c}),new O({optional:!0,name:t.otherObjectTypeID||c}),S.schema(t.digestAlgorithm||{}),new F({name:t.objectDigest||c})]})}fromSchema(e){N(e,Tp);let t=k(e,e,n.schema({names:{digestedObjectType:Vl,otherObjectTypeID:$n,digestAlgorithm:{names:{blockName:Bl}},objectDigest:Pl}}));A.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,$n in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new S({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){let e=new f({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){let e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}};At.CLASS_NAME="ObjectDigestInfo";var Jn="issuerName",Fn="baseCertificateID",Gn="objectDigestInfo",Dp=[Jn,Fn,Gn],Ji=class n extends C{constructor(e={}){super(),Jn in e&&(this.issuerName=i(e,Jn,n.defaultValues(Jn))),Fn in e&&(this.baseCertificateID=i(e,Fn,n.defaultValues(Fn))),Gn in e&&(this.objectDigestInfo=i(e,Gn,n.defaultValues(Gn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jn:return new ye;case Fn:return new Je;case Gn:return new At;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[ye.schema({names:{blockName:t.issuerName}},!0),new p({optional:!0,name:t.baseCertificateID||c,idBlock:{tagClass:3,tagNumber:0},value:Je.schema().valueBlock.value}),new p({optional:!0,name:t.objectDigestInfo||c,idBlock:{tagClass:3,tagNumber:1},value:At.schema().valueBlock.value})]})}fromSchema(e){N(e,Dp);let t=k(e,e,n.schema({names:{issuerName:Jn,baseCertificateID:Fn,objectDigestInfo:Gn}}));A.assertSchema(t,this.className),Jn in t.result&&(this.issuerName=new ye({schema:t.result.issuerName})),Fn in t.result&&(this.baseCertificateID=new Je({schema:new f({value:t.result.baseCertificateID.valueBlock.value})})),Gn in t.result&&(this.objectDigestInfo=new At({schema:new f({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new f;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}};Ji.CLASS_NAME="V2Form";var Wn="baseCertificateID",Yn="entityName",Qn="objectDigestInfo",Up=[Wn,Yn,Qn],Va=class n extends C{constructor(e={}){super(),Wn in e&&(this.baseCertificateID=i(e,Wn,n.defaultValues(Wn))),Yn in e&&(this.entityName=i(e,Yn,n.defaultValues(Yn))),Qn in e&&(this.objectDigestInfo=i(e,Qn,n.defaultValues(Qn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wn:return new Je;case Yn:return new ye;case Qn:return new At;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({optional:!0,name:t.baseCertificateID||c,idBlock:{tagClass:3,tagNumber:0},value:Je.schema().valueBlock.value}),new p({optional:!0,name:t.entityName||c,idBlock:{tagClass:3,tagNumber:1},value:ye.schema().valueBlock.value}),new p({optional:!0,name:t.objectDigestInfo||c,idBlock:{tagClass:3,tagNumber:2},value:At.schema().valueBlock.value})]})}fromSchema(e){N(e,Up);let t=k(e,e,n.schema({names:{baseCertificateID:Wn,entityName:Yn,objectDigestInfo:Qn}}));A.assertSchema(t,this.className),Wn in t.result&&(this.baseCertificateID=new Je({schema:new f({value:t.result.baseCertificateID.valueBlock.value})})),Yn in t.result&&(this.entityName=new ye({schema:new f({value:t.result.entityName.valueBlock.value})})),Qn in t.result&&(this.objectDigestInfo=new At({schema:new f({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new f;return this.baseCertificateID&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new p({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}};Va.CLASS_NAME="Holder";var jl="version",xl="holder",Ol="issuer",Rl="signature",Tl="serialNumber",Dl="attrCertValidityPeriod",Ul="attributes",Xn="issuerUniqueID",zn="extensions",Lp=[jl,xl,Ol,Rl,Tl,Dl,Ul,Xn,zn],Ba=class n extends C{constructor(e={}){super(),this.version=i(e,jl,n.defaultValues(jl)),this.holder=i(e,xl,n.defaultValues(xl)),this.issuer=i(e,Ol,n.defaultValues(Ol)),this.signature=i(e,Rl,n.defaultValues(Rl)),this.serialNumber=i(e,Tl,n.defaultValues(Tl)),this.attrCertValidityPeriod=i(e,Dl,n.defaultValues(Dl)),this.attributes=i(e,Ul,n.defaultValues(Ul)),Xn in e&&(this.issuerUniqueID=i(e,Xn,n.defaultValues(Xn))),zn in e&&(this.extensions=i(e,zn,n.defaultValues(zn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jl:return 1;case xl:return new Va;case Ol:return{};case Rl:return new S;case Tl:return new w;case Dl:return new yt;case Ul:return[];case Xn:return new F;case zn:return new Se;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),Va.schema(t.holder||{}),new ie({value:[ye.schema({names:{blockName:t.issuer||c}}),new p({name:t.issuer||c,idBlock:{tagClass:3,tagNumber:0},value:Ji.schema().valueBlock.value})]}),S.schema(t.signature||{}),new w({name:t.serialNumber||c}),yt.schema(t.attrCertValidityPeriod||{}),new f({name:t.attributes||c,value:[new _({value:fe.schema()})]}),new F({optional:!0,name:t.issuerUniqueID||c}),Se.schema(t.extensions||{},!0)]})}fromSchema(e){N(e,Lp);let t=k(e,e,n.schema({names:{version:jl,holder:{names:{blockName:xl}},issuer:Ol,signature:{names:{blockName:Rl}},serialNumber:Tl,attrCertValidityPeriod:{names:{blockName:Dl}},attributes:Ul,issuerUniqueID:Xn,extensions:{names:{blockName:zn}}}}));switch(A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new Va({schema:t.result.holder}),t.result.issuer.idBlock.tagClass){case 3:this.issuer=new Ji({schema:new f({value:t.result.issuer.valueBlock.value})});break;case 1:default:throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2")}this.signature=new S({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new yt({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,s=>new fe({schema:s})),Xn in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),zn in t.result&&(this.extensions=new Se({schema:t.result.extensions}))}toSchema(){let e=new f({value:[new w({value:this.version}),this.holder.toSchema(),new p({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new f({value:Array.from(this.attributes,t=>t.toSchema())})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,t=>t.toJSON())};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}};Ba.CLASS_NAME="AttributeCertificateInfoV2";var Ll="acinfo",Hl="signatureAlgorithm",_l="signatureValue",Hp=[Ll,Hl,_l],rt=class n extends C{constructor(e={}){super(),this.acinfo=i(e,Ll,n.defaultValues(Ll)),this.signatureAlgorithm=i(e,Hl,n.defaultValues(Hl)),this.signatureValue=i(e,_l,n.defaultValues(_l)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ll:return new Ba;case Hl:return new S;case _l:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[Ba.schema(t.acinfo||{}),S.schema(t.signatureAlgorithm||{}),new F({name:t.signatureValue||c})]})}fromSchema(e){N(e,Hp);let t=k(e,e,n.schema({names:{acinfo:{names:{blockName:Ll}},signatureAlgorithm:{names:{blockName:Hl}},signatureValue:_l}}));A.assertSchema(t,this.className),this.acinfo=new Ba({schema:t.result.acinfo}),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new f({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}};rt.CLASS_NAME="AttributeCertificateV2";var Zn="contentType",dr="content",_p=[Zn,dr],ce=class n extends C{constructor(e={}){super(),this.contentType=i(e,Zn,n.defaultValues(Zn)),this.content=i(e,dr,n.defaultValues(dr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zn:return c;case dr:return new U;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Zn:return typeof t=="string"&&t===this.defaultValues(Zn);case dr:return t instanceof U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return"optional"in t||(t.optional=!1),new f({name:t.blockName||"ContentInfo",optional:t.optional,value:[new O({name:t.contentType||Zn}),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.content||dr})]})]})}fromSchema(e){N(e,_p);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new f({value:[new O({value:this.contentType}),new p({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){let e={contentType:this.contentType};return this.content instanceof U||(e.content=this.content.toJSON()),e}};ce.CLASS_NAME="ContentInfo";ce.DATA=Gh;ce.SIGNED_DATA=Pm;ce.ENVELOPED_DATA=jm;ce.ENCRYPTED_DATA=xm;var Cf="type",kf="value",Yf="utcTimeName",Qf="generalTimeName",Kp=[Yf,Qf],Xf;(function(n){n[n.UTCTime=0]="UTCTime",n[n.GeneralizedTime=1]="GeneralizedTime",n[n.empty=2]="empty"})(Xf||(Xf={}));var Ae=class n extends C{constructor(e={}){super(),this.type=i(e,Cf,n.defaultValues(Cf)),this.value=i(e,kf,n.defaultValues(kf)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cf:return 0;case kf:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){let s=i(e,"names",{});return new ie({optional:t,value:[new ct({name:s.utcTimeName||c}),new re({name:s.generalTimeName||c})]})}fromSchema(e){N(e,Kp);let t=k(e,e,n.schema({names:{utcTimeName:Yf,generalTimeName:Qf}}));A.assertSchema(t,this.className),Yf in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),Qf in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return this.type===0?new ct({valueDate:this.value}):this.type===1?new re({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}};Ae.CLASS_NAME="Time";var Ef="tbs",xs="version",Gc="serialNumber",Wc="signature",Yc="issuer",Qc="notBefore",Xc="notAfter",zc="subject",Zc="subjectPublicKeyInfo",Kl="issuerUniqueID",Ml="subjectUniqueID",ql="extensions",$l="signatureAlgorithm",Jl="signatureValue",Fe="tbsCertificate",Nh=`${Fe}.${xs}`,Rm=`${Fe}.${Gc}`,Tm=`${Fe}.${Wc}`,Dm=`${Fe}.${Yc}`,Ih=`${Fe}.${Qc}`,Vh=`${Fe}.${Xc}`,Um=`${Fe}.${zc}`,Lm=`${Fe}.${Zc}`,Bh=`${Fe}.${Kl}`,Ph=`${Fe}.${Ml}`,ku=`${Fe}.${ql}`,Mp=[Fe,Nh,Rm,Tm,Dm,Ih,Vh,Um,Lm,Bh,Ph,ku,$l,Jl];function qp(n={}){let e=i(n,"names",{});return new f({name:e.blockName||Fe,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:e.tbsCertificateVersion||Nh})]}),new w({name:e.tbsCertificateSerialNumber||Rm}),S.schema(e.signature||{names:{blockName:Tm}}),oe.schema(e.issuer||{names:{blockName:Dm}}),new f({name:e.tbsCertificateValidity||"tbsCertificate.validity",value:[Ae.schema(e.notBefore||{names:{utcTimeName:Ih,generalTimeName:Ih}}),Ae.schema(e.notAfter||{names:{utcTimeName:Vh,generalTimeName:Vh}})]}),oe.schema(e.subject||{names:{blockName:Um}}),qe.schema(e.subjectPublicKeyInfo||{names:{blockName:Lm}}),new D({name:e.tbsCertificateIssuerUniqueID||Bh,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new D({name:e.tbsCertificateSubjectUniqueID||Ph,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Se.schema(e.extensions||{names:{blockName:ku}})]})]})}var Pe=class n extends C{get tbs(){return H.BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(i(e,Ef,n.defaultValues(Ef))),this.version=i(e,xs,n.defaultValues(xs)),this.serialNumber=i(e,Gc,n.defaultValues(Gc)),this.signature=i(e,Wc,n.defaultValues(Wc)),this.issuer=i(e,Yc,n.defaultValues(Yc)),this.notBefore=i(e,Qc,n.defaultValues(Qc)),this.notAfter=i(e,Xc,n.defaultValues(Xc)),this.subject=i(e,zc,n.defaultValues(zc)),this.subjectPublicKeyInfo=i(e,Zc,n.defaultValues(Zc)),Kl in e&&(this.issuerUniqueID=i(e,Kl,n.defaultValues(Kl))),Ml in e&&(this.subjectUniqueID=i(e,Ml,n.defaultValues(Ml))),ql in e&&(this.extensions=i(e,ql,n.defaultValues(ql))),this.signatureAlgorithm=i(e,$l,n.defaultValues($l)),this.signatureValue=i(e,Jl,n.defaultValues(Jl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ef:return we;case xs:return 0;case Gc:return new w;case Wc:return new S;case Yc:return new oe;case Qc:return new Ae;case Xc:return new Ae;case zc:return new oe;case Zc:return new qe;case Kl:return we;case Ml:return we;case ql:return[];case $l:return new S;case Jl:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[qp(t.tbsCertificate),S.schema(t.signatureAlgorithm||{names:{blockName:$l}}),new F({name:t.signatureValue||Jl})]})}fromSchema(e){N(e,Mp);let t=k(e,e,n.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:ku}}}}}}));A.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,Nh in t.result&&(this.version=t.result[Nh].valueBlock.valueDec),this.serialNumber=t.result[Rm],this.signature=new S({schema:t.result[Tm]}),this.issuer=new oe({schema:t.result[Dm]}),this.notBefore=new Ae({schema:t.result[Ih]}),this.notAfter=new Ae({schema:t.result[Vh]}),this.subject=new oe({schema:t.result[Um]}),this.subjectPublicKeyInfo=new qe({schema:t.result[Lm]}),Bh in t.result&&(this.issuerUniqueID=t.result[Bh].valueBlock.valueHex),Ph in t.result&&(this.subjectUniqueID=t.result[Ph].valueBlock.valueHex),ku in t.result&&(this.extensions=Array.from(t.result[ku],s=>new Ue({schema:s}))),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return xs in this&&this.version!==n.defaultValues(xs)&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new f({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new f({value:Array.from(this.extensions,t=>t.toSchema())})]})),new f({value:e})}toSchema(e=!1){let t;if(e===!1){if(!this.tbsView.byteLength)return n.schema().value[0];let s=ve(this.tbsView);A.assert(s,"TBS Certificate"),t=s.result}else t=this.encodeTBS();return new f({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:H.Convert.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return xs in this&&this.version!==n.defaultValues(xs)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=H.Convert.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=H.Convert.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,t=>t.toJSON())),e}async getPublicKey(e,t=q(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=q(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",s=q(!0)){if(!e)throw new Error("Need to provide a private key for signing");let a=await s.getSignatureParameters(e,t),r=a.parameters;this.signature=a.signatureAlgorithm,this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let o=await s.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new F({valueHex:o})}async verify(e,t=q(!0)){let s;if(e?s=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(s=this.subjectPublicKeyInfo),!(s instanceof qe))throw new Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,s,this.signatureAlgorithm)}};Pe.CLASS_NAME="Certificate";function Hm(n,e=null){if(e&&n.issuer.isEqual(e.issuer)&&n.serialNumber.isEqual(e.serialNumber))return null;let t=!1;if(n.extensions){for(let s of n.extensions)if(s.extnID===qh&&s.parsedValue instanceof xi&&s.parsedValue.cA){t=!0;break}}return t?n:null}var pr="certId",vr="certValue",Xa="parsedValue",$p=[pr,vr],Du=class n extends C{constructor(e={}){super(),this.certId=i(e,pr,n.defaultValues(pr)),this.certValue=i(e,vr,n.defaultValues(vr)),Xa in e&&(this.parsedValue=i(e,Xa,n.defaultValues(Xa))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pr:return c;case vr:return new U;case Xa:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pr:return t===c;case vr:return t instanceof U;case Xa:return t instanceof Object&&Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.id||"id"}),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.value||"value"})]})]})}fromSchema(e){N(e,$p);let t=k(e,e,n.schema({names:{id:pr,value:vr}}));A.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;let s=this.certValue.valueBlock.valueHexView;switch(this.certId){case $f:try{this.parsedValue=Pe.fromBER(s)}catch(a){rt.fromBER(s)}break;case Jf:this.parsedValue=rt.fromBER(s);break;case Sd:default:throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return Xa in this&&("acinfo"in this.parsedValue?this.certId=Jf:this.certId=$f,this.certValue=new I({valueHex:this.parsedValue.toSchema().toBER(!1)})),new f({value:[new O({value:this.certId}),new p({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}};Du.CLASS_NAME="CertBag";var Fl="userCertificate",wr="revocationDate",ea="crlEntryExtensions",Jp=[Fl,wr,ea],Uu=class n extends C{constructor(e={}){super(),this.userCertificate=i(e,Fl,n.defaultValues(Fl)),this.revocationDate=i(e,wr,n.defaultValues(wr)),ea in e&&(this.crlEntryExtensions=i(e,ea,n.defaultValues(ea))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fl:return new w;case wr:return new Ae;case ea:return new Se;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.userCertificate||Fl}),Ae.schema({names:{utcTimeName:t.revocationDate||wr,generalTimeName:t.revocationDate||wr}}),Se.schema({names:{blockName:t.crlEntryExtensions||ea}},!0)]})}fromSchema(e){N(e,Jp);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new Ae({schema:t.result.revocationDate}),ea in t.result&&(this.crlEntryExtensions=new Se({schema:t.result.crlEntryExtensions}))}toSchema(){let e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new f({value:e})}toJSON(){let e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}};Uu.CLASS_NAME="RevokedCertificate";var Nf="tbs",Ao="version",If="signature",Vf="issuer",Bf="thisUpdate",Bc="nextUpdate",Pc="revokedCertificates",jc="crlExtensions",Gl="signatureAlgorithm",Wl="signatureValue",ns="tbsCertList",jh=`${ns}.version`,_m=`${ns}.signature`,Km=`${ns}.issuer`,xh=`${ns}.thisUpdate`,Lu=`${ns}.nextUpdate`,Oh=`${ns}.revokedCertificates`,Rh=`${ns}.extensions`,Fp=[ns,jh,_m,Km,xh,Lu,Oh,Rh,Gl,Wl];function Gp(n={}){let e=i(n,"names",{});return new f({name:e.blockName||ns,value:[new w({optional:!0,name:e.tbsCertListVersion||jh,value:2}),S.schema(e.signature||{names:{blockName:_m}}),oe.schema(e.issuer||{names:{blockName:Km}}),Ae.schema(e.tbsCertListThisUpdate||{names:{utcTimeName:xh,generalTimeName:xh}}),Ae.schema(e.tbsCertListNextUpdate||{names:{utcTimeName:Lu,generalTimeName:Lu}},!0),new f({optional:!0,value:[new _({name:e.tbsCertListRevokedCertificates||Oh,value:new f({value:[new w,Ae.schema(),Se.schema({},!0)]})})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Se.schema(e.crlExtensions||{names:{blockName:Rh}})]})]})}var Wp=[Jh,Am,od,ld,bm,$h,Fh,ud,cd,Cm],fn=class n extends C{get tbs(){return H.BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(i(e,Nf,n.defaultValues(Nf))),this.version=i(e,Ao,n.defaultValues(Ao)),this.signature=i(e,If,n.defaultValues(If)),this.issuer=i(e,Vf,n.defaultValues(Vf)),this.thisUpdate=i(e,Bf,n.defaultValues(Bf)),Bc in e&&(this.nextUpdate=i(e,Bc,n.defaultValues(Bc))),Pc in e&&(this.revokedCertificates=i(e,Pc,n.defaultValues(Pc))),jc in e&&(this.crlExtensions=i(e,jc,n.defaultValues(jc))),this.signatureAlgorithm=i(e,Gl,n.defaultValues(Gl)),this.signatureValue=i(e,Wl,n.defaultValues(Wl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Nf:return we;case Ao:return 0;case If:return new S;case Vf:return new oe;case Bf:return new Ae;case Bc:return new Ae;case Pc:return[];case jc:return new Se;case Gl:return new S;case Wl:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||"CertificateList",value:[Gp(e),S.schema(t.signatureAlgorithm||{names:{blockName:Gl}}),new F({name:t.signatureValue||Wl})]})}fromSchema(e){N(e,Fp);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,jh in t.result&&(this.version=t.result[jh].valueBlock.valueDec),this.signature=new S({schema:t.result[_m]}),this.issuer=new oe({schema:t.result[Km]}),this.thisUpdate=new Ae({schema:t.result[xh]}),Lu in t.result&&(this.nextUpdate=new Ae({schema:t.result[Lu]})),Oh in t.result&&(this.revokedCertificates=Array.from(t.result[Oh],s=>new Uu({schema:s}))),Rh in t.result&&(this.crlExtensions=new Se({schema:t.result[Rh]})),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return this.version!==n.defaultValues(Ao)&&e.push(new w({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new f({value:Array.from(this.revokedCertificates,t=>t.toSchema())})),this.crlExtensions&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new f({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return n.schema();let s=ve(this.tbsView);A.assert(s,"TBS Certificate Revocation List"),t=s.result}return new f({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:H.Convert.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==n.defaultValues(Ao)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,t=>t.toJSON())),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer)||!this.revokedCertificates)return!1;for(let t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",s=q(!0)){if(!e)throw new Error("Need to provide a private key for signing");let a=await s.getSignatureParameters(e,t),{parameters:r}=a;this.signature=a.signatureAlgorithm,this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let o=await s.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new F({valueHex:o})}async verify(e={},t=q(!0)){let s;if(e.issuerCertificate&&(s=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(s=e.publicKeyInfo),!s)throw new Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions){for(let a of this.crlExtensions.extensions)if(a.critical&&!Wp.includes(a.extnID))return!1}return t.verifyWithPublicKey(this.tbsView,this.signatureValue,s,this.signatureAlgorithm)}};fn.CLASS_NAME="CertificateRevocationList";var Sr="crlId",yr="crlValue",bo="parsedValue",Yp=[Sr,yr],Hu=class n extends C{constructor(e={}){super(),this.crlId=i(e,Sr,n.defaultValues(Sr)),this.crlValue=i(e,yr,n.defaultValues(yr)),bo in e&&(this.parsedValue=i(e,bo,n.defaultValues(bo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Sr:return c;case yr:return new U;case bo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Sr:return t===c;case yr:return t instanceof U;case bo:return t instanceof Object&&Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.id||"id"}),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.value||"value"})]})]})}fromSchema(e){N(e,Yp);let t=k(e,e,n.schema({names:{id:Sr,value:yr}}));switch(A.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId){case Ff:this.parsedValue=fn.fromBER(this.certValue.valueBlock.valueHex);break;default:throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`)}}toSchema(){return this.parsedValue&&(this.crlId=Ff,this.crlValue=new I({valueHex:this.parsedValue.toSchema().toBER(!1)})),new f({value:[new O({value:this.crlId}),new p({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}};Hu.CLASS_NAME="CRLBag";var Ar="version",br="encryptedContentInfo",Os="unprotectedAttrs",Qp=[Ar,br,Os],mn=class n extends C{constructor(e={}){super(),this.version=i(e,Ar,n.defaultValues(Ar)),this.encryptedContentInfo=i(e,br,n.defaultValues(br)),Os in e&&(this.unprotectedAttrs=i(e,Os,n.defaultValues(Os))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ar:return 0;case br:return new ke;case Os:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ar:return t===0;case br:return ke.compareWithDefault("contentType",t.contentType)&&ke.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&ke.compareWithDefault("encryptedContent",t.encryptedContent);case Os:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),ke.schema(t.encryptedContentInfo||{}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new _({name:t.unprotectedAttrs||c,value:fe.schema()})]})]})}fromSchema(e){N(e,Qp);let t=k(e,e,n.schema({names:{version:Ar,encryptedContentInfo:{names:{blockName:br}},unprotectedAttrs:Os}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new ke({schema:t.result.encryptedContentInfo}),Os in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,s=>new fe({schema:s})))}toSchema(){let e=[];return e.push(new w({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,t=>t.toJSON())),e}async encrypt(e,t=q(!0)){se.assert(e,"parameters","object");let s={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await t.encryptEncryptedContentInfo(s)}async decrypt(e,t=q(!0)){se.assert(e,"parameters","object");let s={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(s)}};mn.CLASS_NAME="EncryptedData";var ta="encryptionAlgorithm",Rs="encryptedData",Co="parsedValue",Xp=[ta,Rs],_u=class n extends C{constructor(e={}){super(),this.encryptionAlgorithm=i(e,ta,n.defaultValues(ta)),this.encryptedData=i(e,Rs,n.defaultValues(Rs)),Co in e&&(this.parsedValue=i(e,Co,n.defaultValues(Co))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ta:return new S;case Rs:return new I;case Co:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ta:return S.compareWithDefault("algorithmId",t.algorithmId)&&!("algorithmParams"in t);case Rs:return t.isEqual(n.defaultValues(e));case Co:return t instanceof Object&&Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.encryptionAlgorithm||{names:{blockName:ta}}),new ie({value:[new I({name:t.encryptedData||Rs}),new I({idBlock:{isConstructed:!0},name:t.encryptedData||Rs})]})]})}fromSchema(e){N(e,Xp);let t=k(e,e,n.schema({names:{encryptionAlgorithm:{names:{blockName:ta}},encryptedData:Rs}}));A.assertSchema(t,this.className),this.encryptionAlgorithm=new S({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new f({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=q(!0)){let a=await new mn({encryptedContentInfo:new ke({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}).decrypt(e,t);this.parsedValue=ts.fromBER(a)}async makeInternalValues(e,t=q(!0)){if(!this.parsedValue)throw new Error('Please initialize "parsedValue" first');let s=new mn,a={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await s.encrypt(a,t),!s.encryptedContentInfo.encryptedContent)throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=s.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=s.encryptedContentInfo.encryptedContent}};_u.CLASS_NAME="PKCS8ShroudedKeyBag";var Cr="secretTypeId",kr="secretValue",zp=[Cr,kr],Ku=class n extends C{constructor(e={}){super(),this.secretTypeId=i(e,Cr,n.defaultValues(Cr)),this.secretValue=i(e,kr,n.defaultValues(kr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cr:return c;case kr:return new U;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Cr:return t===c;case kr:return t instanceof U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.id||"id"}),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.value||"value"})]})]})}fromSchema(e){N(e,zp);let t=k(e,e,n.schema({names:{id:Cr,value:kr}}));A.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new f({value:[new O({value:this.secretTypeId}),new p({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}};Ku.CLASS_NAME="SecretBag";var Th=class n{static getItems(){return this.items||(this.items={},n.register("1.2.840.113549.1.12.10.1.1",ts),n.register("1.2.840.113549.1.12.10.1.2",_u),n.register("1.2.840.113549.1.12.10.1.3",Du),n.register("1.2.840.113549.1.12.10.1.4",Hu),n.register("1.2.840.113549.1.12.10.1.5",Ku),n.register("1.2.840.113549.1.12.10.1.6",zt)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}},sa="bagId",na="bagValue",_t="bagAttributes",Zp=[sa,na,_t],Fi=class n extends C{constructor(e={}){super(),this.bagId=i(e,sa,n.defaultValues(sa)),this.bagValue=i(e,na,n.defaultValues(na)),_t in e&&(this.bagAttributes=i(e,_t,n.defaultValues(_t))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sa:return c;case na:return new U;case _t:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case sa:return t===c;case na:return t instanceof U;case _t:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.bagId||sa}),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.bagValue||na})]}),new ue({optional:!0,value:[new _({name:t.bagAttributes||_t,value:fe.schema()})]})]})}fromSchema(e){N(e,Zp);let t=k(e,e,n.schema({names:{bagId:sa,bagValue:na,bagAttributes:_t}}));A.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();let s=Th.find(this.bagId);if(!s)throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new s({schema:t.result.bagValue}),_t in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,a=>new fe({schema:a})))}toSchema(){let e=[new O({value:this.bagId}),new p({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new ue({value:Array.from(this.bagAttributes,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,t=>t.toJSON())),e}};Fi.CLASS_NAME="SafeBag";var za="safeBags",zt=class n extends C{constructor(e={}){super(),this.safeBags=i(e,za,n.defaultValues(za)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case za:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case za:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.safeBags||c,value:Fi.schema()})]})}fromSchema(e){N(e,[za]);let t=k(e,e,n.schema({names:{safeBags:za}}));A.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,s=>new Fi({schema:s}))}toSchema(){return new f({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}};zt.CLASS_NAME="SafeContents";var Yl="otherCertFormat",Ql="otherCert",ev=[Yl,Ql],Pa=class n extends C{constructor(e={}){super(),this.otherCertFormat=i(e,Yl,n.defaultValues(Yl)),this.otherCert=i(e,Ql,n.defaultValues(Ql)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Yl:return c;case Ql:return new U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.otherCertFormat||Yl}),new U({name:t.otherCert||Ql})]})}fromSchema(e){N(e,ev);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new f({value:[new O({value:this.otherCertFormat}),this.otherCert]})}toJSON(){let e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof U||(e.otherCert=this.otherCert.toJSON()),e}},Xl="certificates",tv=[Xl],bt=class n extends C{constructor(e={}){super(),this.certificates=i(e,Xl,n.defaultValues(Xl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xl:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ue({name:t.blockName||c,value:[new _({name:t.certificates||Xl,value:new ie({value:[Pe.schema(),new p({idBlock:{tagClass:3,tagNumber:0},value:[new U]}),new p({idBlock:{tagClass:3,tagNumber:1},value:[new f]}),new p({idBlock:{tagClass:3,tagNumber:2},value:rt.schema().valueBlock.value}),new p({idBlock:{tagClass:3,tagNumber:3},value:Pa.schema().valueBlock.value})]})})]})}fromSchema(e){N(e,tv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],s=>{let a=s.idBlock.tagNumber;if(s.idBlock.tagClass===1)return new Pe({schema:s});let r=new f({value:s.valueBlock.value});switch(a){case 1:return r.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec===1?new rt({schema:r}):new Ra({schema:r});case 2:return new rt({schema:r});case 3:return new Pa({schema:r})}return s})}toSchema(){return new ue({value:Array.from(this.certificates,e=>{switch(!0){case e instanceof Pe:return e.toSchema();case e instanceof Ra:return new p({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof rt:return new p({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof Pa:return new p({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()})})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}};bt.CLASS_NAME="CertificateSet";var zl="otherRevInfoFormat",Zl="otherRevInfo",sv=[zl,Zl],rn=class n extends C{constructor(e={}){super(),this.otherRevInfoFormat=i(e,zl,n.defaultValues(zl)),this.otherRevInfo=i(e,Zl,n.defaultValues(Zl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case zl:return c;case Zl:return new U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.otherRevInfoFormat||zl}),new U({name:t.otherRevInfo||Zl})]})}fromSchema(e){N(e,sv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new f({value:[new O({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){let e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof U||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}};rn.CLASS_NAME="OtherRevocationInfoFormat";var eu="crls",Pf="otherRevocationInfos",nv=[eu],on=class n extends C{constructor(e={}){super(),this.crls=i(e,eu,n.defaultValues(eu)),this.otherRevocationInfos=i(e,Pf,n.defaultValues(Pf)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eu:return[];case Pf:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ue({name:t.blockName||c,value:[new _({name:t.crls||c,value:new ie({value:[fn.schema(),new p({idBlock:{tagClass:3,tagNumber:1},value:[new O,new U]})]})})]})}fromSchema(e){N(e,nv);let t=k(e,e,n.schema({names:{crls:eu}}));if(A.assertSchema(t,this.className),t.result.crls)for(let s of t.result.crls)s.idBlock.tagClass===1?this.crls.push(new fn({schema:s})):this.otherRevocationInfos.push(new rn({schema:s}))}toSchema(){let e=[];return e.push(...Array.from(this.crls,t=>t.toSchema())),e.push(...Array.from(this.otherRevocationInfos,t=>{let s=t.toSchema();return s.idBlock.tagClass=3,s.idBlock.tagNumber=1,s})),new ue({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}};on.CLASS_NAME="RevocationInfoChoices";var tu="certs",aa="crls",av=[tu,aa],ja=class n extends C{constructor(e={}){super(),this.crls=i(e,aa,n.defaultValues(aa)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tu:return new bt;case aa:return new on;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tu:return t.certificates.length===0;case aa:return t.crls.length===0&&t.otherRevocationInfos.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({name:t.certs||c,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:bt.schema().valueBlock.value}),new p({name:t.crls||c,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:on.schema().valueBlock.value})]})}fromSchema(e){N(e,av);let t=k(e,e,n.schema({names:{certs:tu,crls:aa}}));A.assertSchema(t,this.className),tu in t.result&&(this.certs=new bt({schema:new ue({value:t.result.certs.valueBlock.value})})),aa in t.result&&(this.crls=new on({schema:new ue({value:t.result.crls.valueBlock.value})}))}toSchema(){let e=[];return this.certs&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new f({value:e})}toJSON(){let e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}};ja.CLASS_NAME="OriginatorInfo";var su="issuer",nu="serialNumber",rv=[su,nu],be=class n extends C{constructor(e={}){super(),this.issuer=i(e,su,n.defaultValues(su)),this.serialNumber=i(e,nu,n.defaultValues(nu)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case su:return new oe;case nu:return new w;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[oe.schema(t.issuer||{}),new w({name:t.serialNumber||c})]})}fromSchema(e){N(e,rv);let t=k(e,e,n.schema({names:{issuer:{names:{blockName:su}},serialNumber:nu}}));A.assertSchema(t,this.className),this.issuer=new oe({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new f({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}};be.CLASS_NAME="IssuerAndSerialNumber";var xc="variant",ko="value",iv=["blockName"],Mu=class n extends C{constructor(e={}){super(),this.variant=i(e,xc,n.defaultValues(xc)),ko in e&&(this.value=i(e,ko,n.defaultValues(ko))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xc:return-1;case ko:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xc:return t===-1;case ko:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ie({value:[be.schema({names:{blockName:t.blockName||c}}),new D({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){N(e,iv);let t=k(e,e,n.schema({names:{blockName:"blockName"}}));A.assertSchema(t,this.className),t.result.blockName.idBlock.tagClass===1?(this.variant=1,this.value=new be({schema:t.result.blockName})):(this.variant=2,this.value=new I({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof be))throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof I))throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new D({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new U}}toJSON(){let e={variant:this.variant};return(this.variant===1||this.variant===2)&&this.value&&(e.value=this.value.toJSON()),e}};Mu.CLASS_NAME="RecipientIdentifier";var ra="version",Er="rid",Nr="keyEncryptionAlgorithm",Ir="encryptedKey",Oc="recipientCertificate",ov=[ra,Er,Nr,Ir],Ta=class n extends C{constructor(e={}){super(),this.version=i(e,ra,n.defaultValues(ra)),this.rid=i(e,Er,n.defaultValues(Er)),this.keyEncryptionAlgorithm=i(e,Nr,n.defaultValues(Nr)),this.encryptedKey=i(e,Ir,n.defaultValues(Ir)),this.recipientCertificate=i(e,Oc,n.defaultValues(Oc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ra:return-1;case Er:return{};case Nr:return new S;case Ir:return new I;case Oc:return new Pe;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ra:return t===n.defaultValues(ra);case Er:return Object.keys(t).length===0;case Nr:case Ir:return t.isEqual(n.defaultValues(e));case Oc:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),Mu.schema(t.rid||{}),S.schema(t.keyEncryptionAlgorithm||{}),new I({name:t.encryptedKey||c})]})}fromSchema(e){N(e,ov);let t=k(e,e,n.schema({names:{version:ra,rid:{names:{blockName:Er}},keyEncryptionAlgorithm:{names:{blockName:Nr}},encryptedKey:Ir}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,t.result.rid.idBlock.tagClass===3?this.rid=new I({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new be({schema:t.result.rid}),this.keyEncryptionAlgorithm=new S({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return this.rid instanceof be?(this.version=0,e.push(new w({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new w({value:this.version})),e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new f({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}};Ta.CLASS_NAME="KeyTransRecipientInfo";var Vr="algorithm",Br="publicKey",lv=[Vr,Br],Da=class n extends C{constructor(e={}){super(),this.algorithm=i(e,Vr,n.defaultValues(Vr)),this.publicKey=i(e,Br,n.defaultValues(Br)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vr:return new S;case Br:return new F;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Vr:case Br:return t.isEqual(n.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.algorithm||{}),new F({name:t.publicKey||c})]})}fromSchema(e){N(e,lv);let t=k(e,e,n.schema({names:{algorithm:{names:{blockName:Vr}},publicKey:Br}}));A.assertSchema(t,this.className),this.algorithm=new S({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new f({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}};Da.CLASS_NAME="OriginatorPublicKey";var Rc="variant",Eo="value",uv=["blockName"],ln=class n extends C{constructor(e={}){super(),this.variant=i(e,Rc,n.defaultValues(Rc)),Eo in e&&(this.value=i(e,Eo,n.defaultValues(Eo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Rc:return-1;case Eo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Rc:return t===-1;case Eo:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ie({value:[be.schema({names:{blockName:t.blockName||c}}),new D({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||c}),new p({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||c,value:Da.schema().valueBlock.value})]})}fromSchema(e){N(e,uv);let t=k(e,e,n.schema({names:{blockName:"blockName"}}));A.assertSchema(t,this.className),t.result.blockName.idBlock.tagClass===1?(this.variant=1,this.value=new be({schema:t.result.blockName})):t.result.blockName.idBlock.tagNumber===0?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new Da({schema:new f({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{let e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new U}}toJSON(){let e={variant:this.variant};return(this.variant===1||this.variant===2||this.variant===3)&&(e.value=this.value.toJSON()),e}};ln.CLASS_NAME="OriginatorIdentifierOrKey";var Pr="keyAttrId",gt="keyAttr",cv=[Pr,gt],Ct=class n extends C{constructor(e={}){super(),this.keyAttrId=i(e,Pr,n.defaultValues(Pr)),gt in e&&(this.keyAttr=i(e,gt,n.defaultValues(gt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pr:return c;case gt:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Pr:return typeof t=="string"&&t===c;case gt:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({optional:t.optional||!0,name:t.blockName||c,value:[new O({name:t.keyAttrId||c}),new U({optional:!0,name:t.keyAttr||c})]})}fromSchema(e){N(e,cv);let t=k(e,e,n.schema({names:{keyAttrId:Pr,keyAttr:gt}}));A.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),gt in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){let e=[];return e.push(new O({value:this.keyAttrId})),gt in this&&e.push(this.keyAttr),new f({value:e})}toJSON(){let e={keyAttrId:this.keyAttrId};return gt in this&&(e.keyAttr=this.keyAttr.toJSON()),e}};Ct.CLASS_NAME="OtherKeyAttribute";var ia="subjectKeyIdentifier",Ts="date",Ds="other",hv=[ia,Ts,Ds],Ua=class n extends C{constructor(e={}){super(),this.subjectKeyIdentifier=i(e,ia,n.defaultValues(ia)),Ts in e&&(this.date=i(e,Ts,n.defaultValues(Ts))),Ds in e&&(this.other=i(e,Ds,n.defaultValues(Ds))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ia:return new I;case Ts:return new re;case Ds:return new Ct;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ia:return t.isEqual(n.defaultValues(ia));case Ts:return t.year===0&&t.month===0&&t.day===0&&t.hour===0&&t.minute===0&&t.second===0&&t.millisecond===0;case Ds:return t.keyAttrId===c&&!("keyAttr"in t);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new I({name:t.subjectKeyIdentifier||c}),new re({optional:!0,name:t.date||c}),Ct.schema(t.other||{})]})}fromSchema(e){N(e,hv);let t=k(e,e,n.schema({names:{subjectKeyIdentifier:ia,date:Ts,other:{names:{blockName:Ds}}}}));A.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,Ts in t.result&&(this.date=t.result.date),Ds in t.result&&(this.other=new Ct({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new f({value:e})}toJSON(){let e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}};Ua.CLASS_NAME="RecipientKeyIdentifier";var Tc="variant",Dc="value",fv=["blockName"],es=class n extends C{constructor(e={}){super(),this.variant=i(e,Tc,n.defaultValues(Tc)),this.value=i(e,Dc,n.defaultValues(Dc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Tc:return-1;case Dc:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Tc:return t===-1;case Dc:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ie({value:[be.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||c}}),new p({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:0},value:Ua.schema(t.rKeyId||{names:{blockName:t.blockName||c}}).valueBlock.value})]})}fromSchema(e){N(e,fv);let t=k(e,e,n.schema({names:{blockName:"blockName"}}));A.assertSchema(t,this.className),t.result.blockName.idBlock.tagClass===1?(this.variant=1,this.value=new be({schema:t.result.blockName})):(this.variant=2,this.value=new Ua({schema:new f({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new p({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new U}}toJSON(){let e={variant:this.variant};return(this.variant===1||this.variant===2)&&(e.value=this.value.toJSON()),e}};es.CLASS_NAME="KeyAgreeRecipientIdentifier";var jr="rid",oa="encryptedKey",mv=[jr,oa],La=class n extends C{constructor(e={}){super(),this.rid=i(e,jr,n.defaultValues(jr)),this.encryptedKey=i(e,oa,n.defaultValues(oa)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jr:return new es;case oa:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case jr:return t.variant===-1&&!("value"in t);case oa:return t.isEqual(n.defaultValues(oa));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[es.schema(t.rid||{}),new I({name:t.encryptedKey||c})]})}fromSchema(e){N(e,mv);let t=k(e,e,n.schema({names:{rid:{names:{blockName:jr}},encryptedKey:oa}}));A.assertSchema(t,this.className),this.rid=new es({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new f({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}};La.CLASS_NAME="RecipientEncryptedKey";var Uc="encryptedKeys",Vd="RecipientEncryptedKeys",gv=[Vd],un=class n extends C{constructor(e={}){super(),this.encryptedKeys=i(e,Uc,n.defaultValues(Uc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Uc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Uc:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.RecipientEncryptedKeys||c,value:La.schema()})]})}fromSchema(e){N(e,gv);let t=k(e,e,n.schema({names:{RecipientEncryptedKeys:Vd}}));A.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,s=>new La({schema:s}))}toSchema(){return new f({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}};un.CLASS_NAME="RecipientEncryptedKeys";var xr="version",Or="originator",Kt="ukm",Rr="keyEncryptionAlgorithm",Tr="recipientEncryptedKeys",Lc="recipientCertificate",Hc="recipientPublicKey",dv=[xr,Or,Kt,Rr,Tr],Ha=class n extends C{constructor(e={}){super(),this.version=i(e,xr,n.defaultValues(xr)),this.originator=i(e,Or,n.defaultValues(Or)),Kt in e&&(this.ukm=i(e,Kt,n.defaultValues(Kt))),this.keyEncryptionAlgorithm=i(e,Rr,n.defaultValues(Rr)),this.recipientEncryptedKeys=i(e,Tr,n.defaultValues(Tr)),this.recipientCertificate=i(e,Lc,n.defaultValues(Lc)),this.recipientPublicKey=i(e,Hc,n.defaultValues(Hc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xr:return 0;case Or:return new ln;case Kt:return new I;case Rr:return new S;case Tr:return new un;case Lc:return new Pe;case Hc:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xr:return t===0;case Or:return t.variant===-1&&!("value"in t);case Kt:return t.isEqual(n.defaultValues(Kt));case Rr:return t.algorithmId===c&&!("algorithmParams"in t);case Tr:return t.encryptedKeys.length===0;case Lc:return!1;case Hc:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new p({idBlock:{tagClass:3,tagNumber:0},value:[ln.schema(t.originator||{})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new I({name:t.ukm||c})]}),S.schema(t.keyEncryptionAlgorithm||{}),un.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){N(e,dv);let t=k(e,e,n.schema({names:{version:xr,originator:{names:{blockName:Or}},ukm:Kt,keyEncryptionAlgorithm:{names:{blockName:Rr}},recipientEncryptedKeys:{names:{blockName:Tr}}}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new ln({schema:t.result.originator}),Kt in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new S({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new un({schema:t.result.recipientEncryptedKeys})}toSchema(){let e=[];return e.push(new w({value:this.version})),e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new f({value:e})}toJSON(){let e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}};Ha.CLASS_NAME="KeyAgreeRecipientInfo";var la="keyIdentifier",Us="date",Ls="other",pv=[la,Us,Ls],cn=class n extends C{constructor(e={}){super(),this.keyIdentifier=i(e,la,n.defaultValues(la)),Us in e&&(this.date=i(e,Us,n.defaultValues(Us))),Ls in e&&(this.other=i(e,Ls,n.defaultValues(Ls))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case la:return new I;case Us:return new re;case Ls:return new Ct;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case la:return t.isEqual(n.defaultValues(la));case Us:return t.year===0&&t.month===0&&t.day===0&&t.hour===0&&t.minute===0&&t.second===0&&t.millisecond===0;case Ls:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&!("keyAttr"in t);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new I({name:t.keyIdentifier||c}),new re({optional:!0,name:t.date||c}),Ct.schema(t.other||{})]})}fromSchema(e){N(e,pv);let t=k(e,e,n.schema({names:{keyIdentifier:la,date:Us,other:{names:{blockName:Ls}}}}));A.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,Us in t.result&&(this.date=t.result.date),Ls in t.result&&(this.other=new Ct({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new f({value:e})}toJSON(){let e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}};cn.CLASS_NAME="KEKIdentifier";var Dr="version",Ur="kekid",Lr="keyEncryptionAlgorithm",ua="encryptedKey",_c="preDefinedKEK",vv=[Dr,Ur,Lr,ua],_a=class n extends C{constructor(e={}){super(),this.version=i(e,Dr,n.defaultValues(Dr)),this.kekid=i(e,Ur,n.defaultValues(Ur)),this.keyEncryptionAlgorithm=i(e,Lr,n.defaultValues(Lr)),this.encryptedKey=i(e,ua,n.defaultValues(ua)),this.preDefinedKEK=i(e,_c,n.defaultValues(_c)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Dr:return 0;case Ur:return new cn;case Lr:return new S;case ua:return new I;case _c:return we;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===n.defaultValues(Dr);case Ur:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&!("date"in t)&&!("other"in t);case Lr:return t.algorithmId===c&&!("algorithmParams"in t);case ua:return t.isEqual(n.defaultValues(ua));case _c:return t.byteLength===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),cn.schema(t.kekid||{}),S.schema(t.keyEncryptionAlgorithm||{}),new I({name:t.encryptedKey||c})]})}fromSchema(e){N(e,vv);let t=k(e,e,n.schema({names:{version:Dr,kekid:{names:{blockName:Ur}},keyEncryptionAlgorithm:{names:{blockName:Lr}},encryptedKey:ua}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new cn({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new S({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new f({value:[new w({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}};_a.CLASS_NAME="KEKRecipientInfo";var Hr="version",Hs="keyDerivationAlgorithm",_r="keyEncryptionAlgorithm",ca="encryptedKey",Kc="password",wv=[Hr,Hs,_r,ca],Ka=class n extends C{constructor(e={}){super(),this.version=i(e,Hr,n.defaultValues(Hr)),Hs in e&&(this.keyDerivationAlgorithm=i(e,Hs,n.defaultValues(Hs))),this.keyEncryptionAlgorithm=i(e,_r,n.defaultValues(_r)),this.encryptedKey=i(e,ca,n.defaultValues(ca)),this.password=i(e,Kc,n.defaultValues(Kc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Hr:return-1;case Hs:return new S;case _r:return new S;case ca:return new I;case Kc:return we;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Hr:return t===-1;case Hs:case _r:return t.algorithmId===c&&!("algorithmParams"in t);case ca:return t.isEqual(n.defaultValues(ca));case Kc:return t.byteLength===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new p({name:t.keyDerivationAlgorithm||c,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:S.schema().valueBlock.value}),S.schema(t.keyEncryptionAlgorithm||{}),new I({name:t.encryptedKey||c})]})}fromSchema(e){N(e,wv);let t=k(e,e,n.schema({names:{version:Hr,keyDerivationAlgorithm:Hs,keyEncryptionAlgorithm:{names:{blockName:_r}},encryptedKey:ca}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,Hs in t.result&&(this.keyDerivationAlgorithm=new S({schema:new f({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new S({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return e.push(new w({value:this.version})),this.keyDerivationAlgorithm&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new f({value:e})}toJSON(){let e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}};Ka.CLASS_NAME="PasswordRecipientInfo";var Kr="oriType",ha="oriValue",Sv=[Kr,ha],Gi=class n extends C{constructor(e={}){super(),this.oriType=i(e,Kr,n.defaultValues(Kr)),this.oriValue=i(e,ha,n.defaultValues(ha)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Kr:return c;case ha:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Kr:return t===c;case ha:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.oriType||c}),new U({name:t.oriValue||c})]})}fromSchema(e){N(e,Sv);let t=k(e,e,n.schema({names:{oriType:Kr,oriValue:ha}}));A.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new f({value:[new O({value:this.oriType}),this.oriValue]})}toJSON(){let e={oriType:this.oriType};return n.compareWithDefault(ha,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}};Gi.CLASS_NAME="OtherRecipientInfo";var Mc="variant",No="value",yv=["blockName"],pt=class n extends C{constructor(e={}){super(),this.variant=i(e,Mc,n.defaultValues(Mc)),No in e&&(this.value=i(e,No,n.defaultValues(No))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mc:return-1;case No:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Mc:return t===n.defaultValues(e);case No:return Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new ie({value:[Ta.schema({names:{blockName:t.blockName||c}}),new p({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:1},value:Ha.schema().valueBlock.value}),new p({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:2},value:_a.schema().valueBlock.value}),new p({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:3},value:Ka.schema().valueBlock.value}),new p({name:t.blockName||c,idBlock:{tagClass:3,tagNumber:4},value:Gi.schema().valueBlock.value})]})}fromSchema(e){N(e,yv);let t=k(e,e,n.schema({names:{blockName:"blockName"}}));if(A.assertSchema(t,this.className),t.result.blockName.idBlock.tagClass===1)this.variant=1,this.value=new Ta({schema:t.result.blockName});else{let s=new f({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new Ha({schema:s});break;case 2:this.variant=3,this.value=new _a({schema:s});break;case 3:this.variant=4,this.value=new Ka({schema:s});break;case 4:this.variant=5,this.value=new Gi({schema:s});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){Q.assertEmpty(this.value,"value","RecipientInfo");let e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new U}}toJSON(){let e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}};pt.CLASS_NAME="RecipientInfo";var _s="hashAlgorithm",Ks="maskGenAlgorithm",Ms="pSourceAlgorithm",Av=[_s,Ks,Ms],xa=class n extends C{constructor(e={}){super(),this.hashAlgorithm=i(e,_s,n.defaultValues(_s)),this.maskGenAlgorithm=i(e,Ks,n.defaultValues(Ks)),this.pSourceAlgorithm=i(e,Ms,n.defaultValues(Ms)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _s:return new S({algorithmId:"1.3.14.3.2.26",algorithmParams:new le});case Ks:return new S({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new S({algorithmId:"1.3.14.3.2.26",algorithmParams:new le}).toSchema()});case Ms:return new S({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new I({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new p({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[S.schema(t.hashAlgorithm||{})]}),new p({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[S.schema(t.maskGenAlgorithm||{})]}),new p({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[S.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){N(e,Av);let t=k(e,e,n.schema({names:{hashAlgorithm:{names:{blockName:_s}},maskGenAlgorithm:{names:{blockName:Ks}},pSourceAlgorithm:{names:{blockName:Ms}}}}));A.assertSchema(t,this.className),_s in t.result&&(this.hashAlgorithm=new S({schema:t.result.hashAlgorithm})),Ks in t.result&&(this.maskGenAlgorithm=new S({schema:t.result.maskGenAlgorithm})),Ms in t.result&&(this.pSourceAlgorithm=new S({schema:t.result.pSourceAlgorithm}))}toSchema(){let e=[];return this.hashAlgorithm.isEqual(n.defaultValues(_s))||e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(n.defaultValues(Ks))||e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(n.defaultValues(Ms))||e.push(new p({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new f({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(n.defaultValues(_s))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(n.defaultValues(Ks))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(n.defaultValues(Ms))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}};xa.CLASS_NAME="RSAESOAEPParams";var Mr="keyInfo",qs="entityUInfo",qr="suppPubInfo",bv=[Mr,qs,qr],Wi=class n extends C{constructor(e={}){super(),this.keyInfo=i(e,Mr,n.defaultValues(Mr)),qs in e&&(this.entityUInfo=i(e,qs,n.defaultValues(qs))),this.suppPubInfo=i(e,qr,n.defaultValues(qr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mr:return new S;case qs:return new I;case qr:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Mr:case qs:case qr:return t.isEqual(n.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.keyInfo||{}),new p({name:t.entityUInfo||c,idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new I]}),new p({name:t.suppPubInfo||c,idBlock:{tagClass:3,tagNumber:2},value:[new I]})]})}fromSchema(e){N(e,bv);let t=k(e,e,n.schema({names:{keyInfo:{names:{blockName:Mr}},entityUInfo:qs,suppPubInfo:qr}}));A.assertSchema(t,this.className),this.keyInfo=new S({schema:t.result.keyInfo}),qs in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){let e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new p({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new f({value:e})}toJSON(){let e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}};Wi.CLASS_NAME="ECCCMSSharedInfo";var $r="version",$s="originatorInfo",Jr="recipientInfos",Fr="encryptedContentInfo",Js="unprotectedAttrs",Cv=[$r,$s,Jr,Fr,Js],ed={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},kv={"P-256":256,"P-384":384,"P-521":528},Yi=class n extends C{constructor(e={}){super(),this.version=i(e,$r,n.defaultValues($r)),$s in e&&(this.originatorInfo=i(e,$s,n.defaultValues($s))),this.recipientInfos=i(e,Jr,n.defaultValues(Jr)),this.encryptedContentInfo=i(e,Fr,n.defaultValues(Fr)),Js in e&&(this.unprotectedAttrs=i(e,Js,n.defaultValues(Js))),this.policy={disableSplit:!!e.disableSplit},e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $r:return 0;case $s:return new ja;case Jr:return[];case Fr:return new ke;case Js:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case $r:return t===n.defaultValues(e);case $s:return t.certs.certificates.length===0&&t.crls.crls.length===0;case Jr:case Js:return t.length===0;case Fr:return ke.compareWithDefault("contentType",t.contentType)&&ke.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&ke.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||c}),new p({name:t.originatorInfo||c,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:ja.schema().valueBlock.value}),new ue({value:[new _({name:t.recipientInfos||c,value:pt.schema()})]}),ke.schema(t.encryptedContentInfo||{}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new _({name:t.unprotectedAttrs||c,value:fe.schema()})]})]})}fromSchema(e){N(e,Cv);let t=k(e,e,n.schema({names:{version:$r,originatorInfo:$s,recipientInfos:Jr,encryptedContentInfo:{names:{blockName:Fr}},unprotectedAttrs:Js}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,$s in t.result&&(this.originatorInfo=new ja({schema:new f({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,s=>new pt({schema:s})),this.encryptedContentInfo=new ke({schema:t.result.encryptedContentInfo}),Js in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,s=>new fe({schema:s})))}toSchema(){let e=[];return e.push(new w({value:this.version})),this.originatorInfo&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new ue({value:Array.from(this.recipientInfos,t=>t.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={version:this.version,recipientInfos:Array.from(this.recipientInfos,t=>t.toJSON()),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,t=>t.toJSON())),e}addRecipientByCertificate(e,t,s,a=q(!0)){let r=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},ed,t||{});if(e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549")!==-1)s=1;else if(e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045")!==-1)s=2;else throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);switch(s){case 1:{let o,u;if(r.useOAEP===!0){o=a.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");let h=a.getOIDByAlgorithm({name:r.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),m=new S({algorithmId:h,algorithmParams:new le});u=new xa({hashAlgorithm:m,maskGenAlgorithm:new S({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:m.toSchema()})}).toSchema()}else{if(o=a.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"}),o===c)throw new Error("Can not find OID for RSAES-PKCS1-v1_5");u=new le}let l=new Ta({version:0,rid:new be({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new S({algorithmId:o,algorithmParams:u}),recipientCertificate:e});this.recipientInfos.push(new pt({variant:1,value:l}))}break;case 2:{let o=new es({variant:1,value:new be({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(o,r,{recipientCertificate:e},a)}break;default:throw new Error(`Unknown "variant" value: ${s}`)}return!0}addRecipientByPreDefinedData(e,t={},s,a=q(!0)){if(se.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw new Error("Pre-defined data could have zero length");if(!t.keyIdentifier){let r=new ArrayBuffer(16),o=new Uint8Array(r);a.getRandomValues(o),t.keyIdentifier=r}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),t.iterationCount===void 0&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new le),s){case 1:{let r=a.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),o=new _a({version:4,kekid:new cn({keyIdentifier:new I({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new S({algorithmId:r,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new pt({variant:3,value:o}))}break;case 2:{let r=a.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),o=new ArrayBuffer(64),u=new Uint8Array(o);a.getRandomValues(u);let l=a.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),h=new Zt({salt:new I({valueHex:o}),iterationCount:t.iterationCount,prf:new S({algorithmId:l,algorithmParams:new le})}),m=a.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),g=new Ka({version:0,keyDerivationAlgorithm:new S({algorithmId:r,algorithmParams:h.toSchema()}),keyEncryptionAlgorithm:new S({algorithmId:m,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new pt({variant:4,value:g}))}break;default:throw new Error(`Unknown value for "variant": ${s}`)}}addRecipientByKeyIdentifier(e,t,s,a=q(!0)){let r=Object.assign({},ed,s||{}),o=new es({variant:2,value:new Ua({subjectKeyIdentifier:new I({valueHex:t})})});this._addKeyAgreeRecipientInfo(o,r,{recipientPublicKey:e},a)}_addKeyAgreeRecipientInfo(e,t,s,a=q(!0)){let r=new La({rid:e}),o=a.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),u=new S({algorithmId:o}),l=a.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),h=new ArrayBuffer(64),m=new Uint8Array(h);a.getRandomValues(m);let g={version:3,ukm:new I({valueHex:h}),keyEncryptionAlgorithm:new S({algorithmId:l,algorithmParams:u.toSchema()}),recipientEncryptedKeys:new un({encryptedKeys:[r]})},d=new Ha(Object.assign(g,s));this.recipientInfos.push(new pt({variant:2,value:d}))}async encrypt(e,t,s=q(!0)){let a=new ArrayBuffer(16),r=new Uint8Array(a);s.getRandomValues(r);let o=new Uint8Array(t),u=s.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),l=await s.generateKey(e,!0,["encrypt"]),h=await s.encrypt({name:e.name,iv:r},l,o),m=await s.exportKey("raw",l);this.version=2,this.encryptedContentInfo=new ke({disableSplit:this.policy.disableSplit,contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new S({algorithmId:u,algorithmParams:new I({valueHex:a})}),encryptedContent:new I({valueHex:h})});let g=async v=>{let j=this.recipientInfos[v].value,P,V;if(j.recipientPublicKey)P=j.recipientPublicKey.algorithm.namedCurve,V=j.recipientPublicKey;else if(j.recipientCertificate){let T=j.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(T.constructor.blockName()!==O.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${v}`);switch(T.valueBlock.toString()){case"1.2.840.10045.3.1.7":P="P-256";break;case"1.3.132.0.34":P="P-384";break;case"1.3.132.0.35":P="P-521";break;default:throw new Error(`Incorrect curve OID for index ${v}`)}V=await j.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:P},usages:[]}},s)}else throw new Error("Unsupported RecipientInfo");let B=kv[P],x=await s.generateKey({name:"ECDH",namedCurve:P},!0,["deriveBits"]),K=await s.exportKey("spki",x.publicKey),ee=await s.deriveBits({name:"ECDH",public:V},x.privateKey,B),$=new S({schema:j.keyEncryptionAlgorithm.algorithmParams}),X=s.getAlgorithmByOID($.algorithmId,!0,"aesKWAlgorithm"),me=X.length,z=new ArrayBuffer(4),ae=new Uint8Array(z);for(let T=3;T>=0;T--)ae[T]=me,me>>=8;let je=new Wi({keyInfo:new S({algorithmId:$.algorithmId}),entityUInfo:j.ukm,suppPubInfo:new I({valueHex:z})}).toSchema().toBER(!1),ge=s.getAlgorithmByOID(j.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),Le=await Wf(ge.kdf,ee,X.length,je,s),xe=await s.importKey("raw",Le,{name:"AES-KW"},!0,["wrapKey"]),Ge=await s.wrapKey("raw",l,xe,{name:"AES-KW"}),de=new ln;return de.variant=3,de.value=Da.fromBER(K),j.originator=de,j.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new I({valueHex:Ge}),{ecdhPrivateKey:x.privateKey}},d=async v=>{let j=this.recipientInfos[v].value,P=s.getAlgorithmByOID(j.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if(P.name==="RSA-OAEP"){let V=j.keyEncryptionAlgorithm.algorithmParams,B=new xa({schema:V});if(P.hash=s.getAlgorithmByOID(B.hashAlgorithm.algorithmId),!("name"in P.hash))throw new Error(`Incorrect OID for hash algorithm: ${B.hashAlgorithm.algorithmId}`)}try{let V=await j.recipientCertificate.getPublicKey({algorithm:{algorithm:P,usages:["encrypt","wrapKey"]}},s),B=await s.encrypt(V.algorithm,V,m);j.encryptedKey=new I({valueHex:B})}catch(V){}},b=async v=>{let j=this.recipientInfos[v].value,P=s.getAlgorithmByOID(j.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),V=await s.importKey("raw",new Uint8Array(j.preDefinedKEK),P,!0,["wrapKey"]),B=await s.wrapKey("raw",l,V,P);j.encryptedKey=new I({valueHex:B})},y=async v=>{let j=this.recipientInfos[v].value,P;if(!j.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!j.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{P=new Zt({schema:j.keyDerivationAlgorithm.algorithmParams})}catch(z){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}let V=new Uint8Array(j.password),B=await s.importKey("raw",V,"PBKDF2",!1,["deriveKey"]),x=s.getAlgorithmByOID(j.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),K="SHA-1";P.prf&&(K=s.getAlgorithmByOID(P.prf.algorithmId,!0,"prfAlgorithm").hash.name);let ee=new Uint8Array(P.salt.valueBlock.valueHex),$=P.iterationCount,X=await s.deriveKey({name:"PBKDF2",hash:{name:K},salt:ee,iterations:$},B,x,!0,["wrapKey"]),me=await s.wrapKey("raw",l,X,x);j.encryptedKey=new I({valueHex:me})},E=[];for(let v=0;v<this.recipientInfos.length;v++)switch(this.recipientInfos[v].variant){case 1:E.push(await d(v));break;case 2:E.push(await g(v));break;case 3:E.push(await b(v));break;case 4:E.push(await y(v));break;default:throw new Error(`Unknown recipient type in array with index ${v}`)}return E}async decrypt(e,t,s=q(!0)){let a=t||{};if(e+1>this.recipientInfos.length)throw new Error(`Maximum value for "index" is: ${this.recipientInfos.length-1}`);let r=async E=>{let v=this.recipientInfos[E].value,j,P,V,B=v.originator;if(a.recipientCertificate){let ge=a.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(ge.constructor.blockName()!==O.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${E}`);j=ge.valueBlock.toString()}else if(B.value.algorithm.algorithmParams){let ge=B.value.algorithm.algorithmParams;if(ge.constructor.blockName()!==O.blockName())throw new Error(`Incorrect originator for index ${E}`);j=ge.valueBlock.toString()}else throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');if(!a.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(j){case"1.2.840.10045.3.1.7":P="P-256",V=256;break;case"1.3.132.0.34":P="P-384",V=384;break;case"1.3.132.0.35":P="P-521",V=528;break;default:throw new Error(`Incorrect curve OID for index ${E}`)}let x,K=s;Ii.BufferSourceConverter.isBufferSource(a.recipientPrivateKey)?x=await s.importKey("pkcs8",a.recipientPrivateKey,{name:"ECDH",namedCurve:P},!0,["deriveBits"]):(x=a.recipientPrivateKey,"crypto"in a&&a.crypto&&(K=a.crypto.subtle)),"algorithmParams"in B.value.algorithm||(B.value.algorithm.algorithmParams=new O({value:j}));let ee=B.value.toSchema().toBER(!1),$=await s.importKey("spki",ee,{name:"ECDH",namedCurve:P},!0,[]),X=await K.deriveBits({name:"ECDH",public:$},x,V);async function me(ge){ge=ge||!1;let Le=new S({schema:v.keyEncryptionAlgorithm.algorithmParams}),xe=s.getAlgorithmByOID(Le.algorithmId,!0,"kwAlgorithm"),Ge=xe.length,de=new ArrayBuffer(4),T=new Uint8Array(de);for(let Ee=3;Ee>=0;Ee--)T[Ee]=Ge,Ge>>=8;let J={algorithmId:Le.algorithmId};ge&&(J.algorithmParams=new le);let W=new Wi({keyInfo:new S(J),entityUInfo:v.ukm,suppPubInfo:new I({valueHex:de})}).toSchema().toBER(!1),te=s.getAlgorithmByOID(v.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!te.name)throw new Error(`Incorrect OID for key encryption algorithm: ${v.keyEncryptionAlgorithm.algorithmId}`);return Wf(te.kdf,X,xe.length,W,s)}let z=await me(),ae=async ge=>s.importKey("raw",ge,{name:"AES-KW"},!0,["unwrapKey"]),kt=await ae(z),je=async ge=>{let Le=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,xe=s.getAlgorithmByOID(Le,!0,"contentEncryptionAlgorithm");return s.unwrapKey("raw",v.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,ge,{name:"AES-KW"},xe,!0,["decrypt"])};try{return await je(kt)}catch(ge){let Le=await me(!0),xe=await ae(Le);return je(xe)}},o=async E=>{let v=this.recipientInfos[E].value;if(!a.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');let j=s.getAlgorithmByOID(v.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if(j.name==="RSA-OAEP"){let ee=v.keyEncryptionAlgorithm.algorithmParams,$=new xa({schema:ee});if(j.hash=s.getAlgorithmByOID($.hashAlgorithm.algorithmId),!("name"in j.hash))throw new Error(`Incorrect OID for hash algorithm: ${$.hashAlgorithm.algorithmId}`)}let P,V=s;Ii.BufferSourceConverter.isBufferSource(a.recipientPrivateKey)?P=await s.importKey("pkcs8",a.recipientPrivateKey,j,!0,["decrypt"]):(P=a.recipientPrivateKey,"crypto"in a&&a.crypto&&(V=a.crypto.subtle));let B=await V.decrypt(P.algorithm,P,v.encryptedKey.valueBlock.valueHexView),x=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,K=s.getAlgorithmByOID(x,!0,"contentEncryptionAlgorithm");if(!("name"in K))throw new Error(`Incorrect "contentEncryptionAlgorithm": ${x}`);return s.importKey("raw",B,K,!0,["decrypt"])},u=async E=>{let v=this.recipientInfos[E].value;if(!a.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');let j=s.getAlgorithmByOID(v.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),P=await s.importKey("raw",a.preDefinedData,j,!0,["unwrapKey"]),V=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,B=s.getAlgorithmByOID(V,!0,"contentEncryptionAlgorithm");if(!B.name)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${V}`);return s.unwrapKey("raw",v.encryptedKey.valueBlock.valueHexView,P,j,B,!0,["decrypt"])},l=async E=>{let v=this.recipientInfos[E].value,j;if(!a.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!v.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!v.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{j=new Zt({schema:v.keyDerivationAlgorithm.algorithmParams})}catch(me){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}let P=await s.importKey("raw",a.preDefinedData,"PBKDF2",!1,["deriveKey"]),V=s.getAlgorithmByOID(v.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),B=j.prf?s.getAlgorithmByOID(j.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",x=new Uint8Array(j.salt.valueBlock.valueHex),K=j.iterationCount,ee=await s.deriveKey({name:"PBKDF2",hash:{name:B},salt:x,iterations:K},P,V,!0,["unwrapKey"]),$=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,X=s.getAlgorithmByOID($,!0,"contentEncryptionAlgorithm");return s.unwrapKey("raw",v.encryptedKey.valueBlock.valueHexView,ee,V,X,!0,["decrypt"])},h;switch(this.recipientInfos[e].variant){case 1:h=await o(e);break;case 2:h=await r(e);break;case 3:h=await u(e);break;case 4:h=await l(e);break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}let m=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,g=s.getAlgorithmByOID(m,!0,"contentEncryptionAlgorithm"),d=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,b=new Uint8Array(d);if(!this.encryptedContentInfo.encryptedContent)throw new Error("Required property `encryptedContent` is empty");let y=this.encryptedContentInfo.getEncryptedContent();return s.decrypt({name:g.name,iv:b},h,y)}};Yi.CLASS_NAME="EnvelopedData";var Za="safeContents",Io="parsedValue",td="contentInfos",Qi=class n extends C{constructor(e={}){super(),this.safeContents=i(e,Za,n.defaultValues(Za)),Io in e&&(this.parsedValue=i(e,Io,n.defaultValues(Io))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Za:return[];case Io:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Za:return t.length===0;case Io:return t instanceof Object&&Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new _({name:t.contentInfos||c,value:ce.schema()})]})}fromSchema(e){N(e,[td]);let t=k(e,e,n.schema({names:{contentInfos:td}}));A.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,s=>new ce({schema:s}))}toSchema(){return new f({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}async parseInternalValues(e,t=q(!0)){if(Q.assert(e,Za),se.assert(e.safeContents,Za,"Array"),e.safeContents.length!==this.safeContents.length)throw new se('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');this.parsedValue={safeContents:[]};for(let[s,a]of this.safeContents.entries()){let r=e.safeContents[s],o=`parameters.safeContents[${s}]`;switch(a.contentType){case Gh:{se.assert(a.content,"this.safeContents[j].content",I);let u=a.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:zt.fromBER(u)})}break;case jm:{let u=new Yi({schema:a.content});Q.assert(o,r,"recipientCertificate","recipientKey");let l=r,h=l.recipientCertificate,m=l.recipientKey,g=await u.decrypt(0,{recipientCertificate:h,recipientPrivateKey:m},t);this.parsedValue.safeContents.push({privacyMode:2,value:zt.fromBER(g)})}break;case xm:{let u=new mn({schema:a.content});Q.assert(o,r,"password");let l=r.password,h=await u.decrypt({password:l},t);this.parsedValue.safeContents.push({privacyMode:1,value:zt.fromBER(h)})}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${a.contentType}`)}}}async makeInternalValues(e,t=q(!0)){if(!this.parsedValue)throw new Error('Please run "parseValues" first or add "parsedValue" manually');if(se.assert(this.parsedValue,"this.parsedValue","object"),se.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),se.assert(e,"parameters","object"),Q.assert(e,"safeContents"),se.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new se('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');this.safeContents=[];for(let[s,a]of this.parsedValue.safeContents.entries())switch(Q.assert("content",a,"privacyMode","value"),se.assert(a.value,"content.value",zt),a.privacyMode){case 0:{let r=a.value.toSchema().toBER(!1);this.safeContents.push(new ce({contentType:"1.2.840.113549.1.7.1",content:new I({valueHex:r})}))}break;case 1:{let r=new mn,o=e.safeContents[s];o.contentToEncrypt=a.value.toSchema().toBER(!1),await r.encrypt(o,t),this.safeContents.push(new ce({contentType:"1.2.840.113549.1.7.6",content:r.toSchema()}))}break;case 2:{let r=new Yi,o=a.value.toSchema().toBER(!1),u=e.safeContents[s];switch(Q.assert(`parameters.safeContents[${s}]`,u,"encryptingCertificate","encryptionAlgorithm"),!0){case u.encryptionAlgorithm.name.toLowerCase()==="aes-cbc":case u.encryptionAlgorithm.name.toLowerCase()==="aes-gcm":break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${u.encryptionAlgorithm}`)}switch(!0){case u.encryptionAlgorithm.length===128:case u.encryptionAlgorithm.length===192:case u.encryptionAlgorithm.length===256:break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${u.encryptionAlgorithm.length}`)}let l=u.encryptionAlgorithm;r.addRecipientByCertificate(u.encryptingCertificate,{},void 0,t),await r.encrypt(l,o,t),this.safeContents.push(new ce({contentType:"1.2.840.113549.1.7.3",content:r.toSchema()}))}break;default:throw new Error(`Incorrect value for "content.privacyMode": ${a.privacyMode}`)}return this}};Qi.CLASS_NAME="AuthenticatedSafe";var fa="hashAlgorithm",Gr="issuerNameHash",Wr="issuerKeyHash",ma="serialNumber",Ev=[fa,Gr,Wr,ma],Oe=class n extends C{static async create(e,t,s=q(!0)){let a=new n;return await a.createForCertificate(e,t,s),a}constructor(e={}){super(),this.hashAlgorithm=i(e,fa,n.defaultValues(fa)),this.issuerNameHash=i(e,Gr,n.defaultValues(Gr)),this.issuerKeyHash=i(e,Wr,n.defaultValues(Wr)),this.serialNumber=i(e,ma,n.defaultValues(ma)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fa:return new S;case Gr:case Wr:return new I;case ma:return new w;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fa:return t.algorithmId===c&&!("algorithmParams"in t);case Gr:case Wr:case ma:return t.isEqual(n.defaultValues(ma));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||c}}),new I({name:t.issuerNameHash||c}),new I({name:t.issuerKeyHash||c}),new w({name:t.serialNumber||c})]})}fromSchema(e){N(e,Ev);let t=k(e,e,n.schema({names:{hashAlgorithm:fa,issuerNameHash:Gr,issuerKeyHash:Wr,serialNumber:ma}}));A.assertSchema(t,this.className),this.hashAlgorithm=new S({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new f({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return!(this.hashAlgorithm.algorithmId!==e.hashAlgorithm.algorithmId||!H.BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)||!H.BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)||!this.serialNumber.isEqual(e.serialNumber))}async createForCertificate(e,t,s=q(!0)){Q.assert(t,fa,"issuerCertificate");let a=s.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new S({algorithmId:a,algorithmParams:new le});let r=t.issuerCertificate;this.serialNumber=e.serialNumber;let o=await s.digest({name:t.hashAlgorithm},r.subject.toSchema().toBER(!1));this.issuerNameHash=new I({valueHex:o});let u=r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,l=await s.digest({name:t.hashAlgorithm},u);this.issuerKeyHash=new I({valueHex:l})}};Oe.CLASS_NAME="CertID";var Yr="certID",Qr="certStatus",Xr="thisUpdate",Fs="nextUpdate",ga="singleExtensions",Nv=[Yr,Qr,Xr,Fs,ga],Xi=class n extends C{constructor(e={}){super(),this.certID=i(e,Yr,n.defaultValues(Yr)),this.certStatus=i(e,Qr,n.defaultValues(Qr)),this.thisUpdate=i(e,Xr,n.defaultValues(Xr)),Fs in e&&(this.nextUpdate=i(e,Fs,n.defaultValues(Fs))),ga in e&&(this.singleExtensions=i(e,ga,n.defaultValues(ga))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Yr:return new Oe;case Qr:return{};case Xr:case Fs:return new Date(0,0,0);case ga:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Yr:return Oe.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&Oe.compareWithDefault("issuerNameHash",t.issuerNameHash)&&Oe.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&Oe.compareWithDefault("serialNumber",t.serialNumber);case Qr:return Object.keys(t).length===0;case Xr:case Fs:return t===n.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[Oe.schema(t.certID||{}),new ie({value:[new D({name:t.certStatus||c,idBlock:{tagClass:3,tagNumber:0}}),new p({name:t.certStatus||c,idBlock:{tagClass:3,tagNumber:1},value:[new re,new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ze]})]}),new D({name:t.certStatus||c,idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new re({name:t.thisUpdate||c}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new re({name:t.nextUpdate||c})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Se.schema(t.singleExtensions||{})]})]})}fromSchema(e){N(e,Nv);let t=k(e,e,n.schema({names:{certID:{names:{blockName:Yr}},certStatus:Qr,thisUpdate:Xr,nextUpdate:Fs,singleExtensions:{names:{blockName:ga}}}}));A.assertSchema(t,this.className),this.certID=new Oe({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),Fs in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),ga in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,s=>new Ue({schema:s})))}toSchema(){let e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new re({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[new re({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[new f({value:Array.from(this.singleExtensions,t=>t.toSchema())})]})),new f({value:e})}toJSON(){let e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,t=>t.toJSON())),e}};Xi.CLASS_NAME="SingleResponse";var qc="tbs",da="version",au="responderID",ru="producedAt",iu="responses",zr="responseExtensions",$a="ResponseData",eh=`${$a}.${da}`,Zr=`${$a}.${au}`,zf=`${$a}.${ru}`,Zf=`${$a}.${iu}`,th=`${$a}.${zr}`,Iv=[$a,eh,Zr,zf,Zf,th],Ye=class n extends C{get tbs(){return H.BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(i(e,qc,n.defaultValues(qc))),da in e&&(this.version=i(e,da,n.defaultValues(da))),this.responderID=i(e,au,n.defaultValues(au)),this.producedAt=i(e,ru,n.defaultValues(ru)),this.responses=i(e,iu,n.defaultValues(iu)),zr in e&&(this.responseExtensions=i(e,zr,n.defaultValues(zr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case da:return 0;case qc:return we;case au:return{};case ru:return new Date(0,0,0);case iu:case zr:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case qc:return t.byteLength===0;case au:return Object.keys(t).length===0;case ru:return t===n.defaultValues(e);case iu:case zr:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||$a,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:t.version||eh})]}),new ie({value:[new p({name:t.responderID||Zr,idBlock:{tagClass:3,tagNumber:1},value:[oe.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new p({name:t.responderID||Zr,idBlock:{tagClass:3,tagNumber:2},value:[new I({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new re({name:t.producedAt||zf}),new f({value:[new _({name:Zf,value:Xi.schema(t.response||{})})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Se.schema(t.extensions||{names:{blockName:th}})]})]})}fromSchema(e){N(e,Iv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,eh in t.result&&(this.version=t.result[eh].valueBlock.valueDec),t.result[Zr].idBlock.tagNumber===1?this.responderID=new oe({schema:t.result[Zr].valueBlock.value[0]}):this.responderID=t.result[Zr].valueBlock.value[0],this.producedAt=t.result[zf].toDate(),this.responses=Array.from(t.result[Zf],s=>new Xi({schema:s})),th in t.result&&(this.responseExtensions=Array.from(t.result[th].valueBlock.value,s=>new Ue({schema:s})))}toSchema(e=!1){let t;if(e===!1){if(!this.tbsView.byteLength)return n.schema();let s=ve(this.tbsView);A.assert(s,"TBS Response Data"),t=s.result}else{let s=[];da in this&&s.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[new w({value:this.version})]})),this.responderID instanceof oe?s.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):s.push(new p({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),s.push(new re({valueDate:this.producedAt})),s.push(new f({value:Array.from(this.responses,a=>a.toSchema())})),this.responseExtensions&&s.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[new f({value:Array.from(this.responseExtensions,a=>a.toSchema())})]})),t=new f({value:s})}return t}toJSON(){let e={};return da in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,t=>t.toJSON())),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,t=>t.toJSON())),e}};Ye.CLASS_NAME="ResponseData";var jf="trustedCerts",xf="certs",Of="crls",Rf="ocsps",Tf="checkDate",Df="findOrigin",Uf="findIssuer",en;(function(n){n[n.unknown=-1]="unknown",n[n.success=0]="success",n[n.noRevocation=11]="noRevocation",n[n.noPath=60]="noPath",n[n.noValidPath=97]="noValidPath"})(en||(en={}));var Qt=class n extends Error{constructor(e,t){super(t),this.name=n.NAME,this.code=e,this.message=t}};Qt.NAME="ChainValidationError";function Vv(n,e){for(let t=0;t<e.length;t++)if(H.BufferSourceConverter.isEqual(n.tbsView,e[t].tbsView))return!0;return!1}var qu=class n{constructor(e={}){this.trustedCerts=i(e,jf,this.defaultValues(jf)),this.certs=i(e,xf,this.defaultValues(xf)),this.crls=i(e,Of,this.defaultValues(Of)),this.ocsps=i(e,Rf,this.defaultValues(Rf)),this.checkDate=i(e,Tf,this.defaultValues(Tf)),this.findOrigin=i(e,Df,this.defaultValues(Df)),this.findIssuer=i(e,Uf,this.defaultValues(Uf))}static defaultFindOrigin(e,t){e.tbsView.byteLength===0&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER()));for(let s of t.certs)if(s.tbsView.byteLength===0&&(s.tbsView=new Uint8Array(s.encodeTBS().toBER())),H.BufferSourceConverter.isEqual(e.tbsView,s.tbsView))return"Intermediate Certificates";for(let s of t.trustedCerts)if(s.tbsView.byteLength===0&&(s.tbsView=new Uint8Array(s.encodeTBS().toBER())),H.BufferSourceConverter.isEqual(e.tbsView,s.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,s=q(!0)){let a=[],r=null,o=null,u=null;if(e.subject.isEqual(e.issuer))try{if(await e.verify(void 0,s))return[e]}catch(h){}if(e.extensions){for(let h of e.extensions)if(h.extnID===Jh&&h.parsedValue instanceof ji){h.parsedValue.keyIdentifier?r=h.parsedValue.keyIdentifier:(h.parsedValue.authorityCertIssuer&&(o=h.parsedValue.authorityCertIssuer),h.parsedValue.authorityCertSerialNumber&&(u=h.parsedValue.authorityCertSerialNumber));break}}function l(h){if(r!==null&&h.extensions){let g=!1;for(let d of h.extensions)if(d.extnID===ad&&d.parsedValue){g=!0,H.BufferSourceConverter.isEqual(d.parsedValue.valueBlock.valueHex,r.valueBlock.valueHexView)&&a.push(h);break}if(g)return}let m=!1;u!==null&&(m=h.serialNumber.isEqual(u)),o!==null?h.subject.isEqual(o)&&m&&a.push(h):e.issuer.isEqual(h.subject)&&a.push(h)}for(let h of t.trustedCerts)l(h);for(let h of t.certs)l(h);for(let h=a.length-1;h>=0;h--)try{await e.verify(a[h],s)===!1&&a.splice(h,1)}catch(m){a.splice(h,1)}return a}defaultValues(e){switch(e){case jf:return[];case xf:return[];case Of:return[];case Rf:return[];case Tf:return new Date;case Df:return n.defaultFindOrigin;case Uf:return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=q(!0)){let s=[],a=async(y,E)=>{let v=[];function j(V){let B=!0;for(let x=0;x<V.length;x++){for(let K=0;K<V.length;K++)if(K!==x&&V[x]===V[K]){B=!1;break}if(!B)break}return B}if(Vv(y,this.trustedCerts))return[[y]];let P=await this.findIssuer(y,this,E);if(P.length===0)throw new Error("No valid certificate paths found");for(let V=0;V<P.length;V++){if(H.BufferSourceConverter.isEqual(P[V].tbsView,y.tbsView)){v.push([P[V]]);continue}let B=await a(P[V],E);for(let x=0;x<B.length;x++){let K=B[x].slice();K.splice(0,0,P[V]),j(K)?v.push(K):v.push(B[x])}}return v},r=async y=>{let E=[],v=[],j=[];if(E.push(...s.filter(P=>y.issuer.isEqual(P.subject))),E.length===0)return{status:1,statusMessage:"No certificate's issuers"};if(v.push(...this.crls.filter(P=>P.issuer.isEqual(y.issuer))),v.length===0)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let P=0;P<v.length;P++){let V=v[P];if(!(V.nextUpdate&&V.nextUpdate.value<this.checkDate))for(let B=0;B<E.length;B++)try{if(await v[P].verify({issuerCertificate:E[B]},t)){j.push({crl:v[P],certificate:E[B]});break}}catch(x){}}return j.length?{status:0,statusMessage:c,result:j}:{status:3,statusMessage:"No valid CRLs found"}},o=async(y,E)=>{let v=t.getAlgorithmByOID(y.signatureAlgorithm.algorithmId);if(!v.name||!v.hash)return 1;for(let j=0;j<this.ocsps.length;j++){let V=await this.ocsps[j].getCertificateStatus(y,E,t);if(V.isForCertificate)return V.status===0?0:1}return 2};async function u(y,E=!1){let v=!1,j=!1,P=!1,V=!1;if(y.extensions){for(let B=0;B<y.extensions.length;B++){let x=y.extensions[B];if(x.critical&&!x.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${x.extnID}`};if(x.extnID===rd){P=!0;let K=new Uint8Array(x.parsedValue.valueBlock.valueHex);(K[0]&4)===4&&(j=!0),(K[0]&2)===2&&(V=!0)}x.extnID===qh&&"cA"in x.parsedValue&&x.parsedValue.cA===!0&&(v=!0)}if(j===!0&&v===!1)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(P===!0&&v===!0&&j===!1)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(v===!0&&P===!0&&E&&V===!1)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return v===!1?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:c}}let l=async(y,E)=>{for(let v=0;v<y.length;v++)if(y[v].notBefore.value>E||y[v].notAfter.value<E)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(y.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let v=y.length-2;v>=0;v--)if(y[v].issuer.isEqual(y[v].subject)===!1&&y[v].issuer.isEqual(y[v+1].subject)===!1)return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(this.crls.length!==0||this.ocsps.length!==0)for(let v=0;v<y.length-1;v++){let j=2,P={status:0,statusMessage:c};if(this.ocsps.length!==0)switch(j=await o(y[v],y[v+1]),j){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(this.crls.length!==0){if(P=await r(y[v]),P.status===0&&P.result)for(let V=0;V<P.result.length;V++){if(P.result[V].crl.isCertificateRevoked(y[v]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if((await u(P.result[V].certificate,!0)).result===!1)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(e===!1)throw new Qt(en.noRevocation,`No revocation values found for one of certificates: ${P.statusMessage}`)}else if(j===2)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(j===2&&P.status===2&&e){let V=y[v+1],B=!1;if(V.extensions)for(let x of V.extensions)switch(x.extnID){case Em:case $h:case Fh:B=!0;break}if(B)throw new Qt(en.noRevocation,`No revocation values found for one of certificates: ${P.statusMessage}`)}}for(let[v,j]of y.entries()){if(!v)continue;if(!(await u(j)).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}};s.push(...this.trustedCerts),s.push(...this.certs);for(let y=0;y<s.length;y++)for(let E=0;E<s.length;E++)if(y!==E&&H.BufferSourceConverter.isEqual(s[y].tbsView,s[E].tbsView)){s.splice(E,1),y=0;break}let h=s[s.length-1],m,g=[h];if(m=await a(h,t),m.length===0)throw new Qt(en.noPath,"Unable to find certificate path");for(let y=m.length-1;y>=0;y--){let E=!1;for(let v=0;v<m[y].length;v++){let j=m[y][v];for(let P=0;P<this.trustedCerts.length;P++)if(H.BufferSourceConverter.isEqual(j.tbsView,this.trustedCerts[P].tbsView)){E=!0;break}if(E)break}E||m.splice(y,1)}if(m.length===0)throw new Qt(en.noValidPath,"No valid certificate paths found");let d=m[0].length,b=0;for(let y=0;y<m.length;y++)m[y].length<d&&(d=m[y].length,b=y);for(let y=0;y<m[b].length;y++)g.push(m[b][y]);if(m=await l(g,this.checkDate),m.result===!1)throw m;return g}async verify(e={},t=q(!0)){function s(l,h){let m=Yt(l),g=Yt(h),d=m.split("."),b=g.split("."),y=d.length,E=b.length;if(y===0||E===0||y<E)return!1;for(let v=0;v<y;v++)if(d[v].length===0)return!1;for(let v=0;v<E;v++)if(b[v].length===0){if(v===0){if(E===1)return!1;continue}return!1}for(let v=0;v<E;v++)if(b[E-1-v].length!==0&&d[y-1-v].localeCompare(b[E-1-v])!==0)return!1;return!0}function a(l,h){let m=Yt(l),g=Yt(h),d=m.split("@"),b=g.split("@");if(d.length===0||b.length===0||d.length<b.length)return!1;if(b.length===1){if(s(d[1],b[0])){let E=d[1].split("."),v=b[0].split(".");return v[0].length===0?!0:E.length===v.length}return!1}return m.localeCompare(g)===0}function r(l,h){let m=Yt(l),g=Yt(h),d=m.split("/");if(g.split("/").length>1)return!1;if(d.length>1){for(let E=0;E<d.length;E++)if(d[E].length>0&&d[E].charAt(d[E].length-1)!==":"){m=d[E].split(":")[0];break}}if(s(m,g)){let E=m.split("."),v=g.split(".");return v[0].length===0?!0:E.length===v.length}return!1}function o(l,h){let m=l.valueBlock.valueHexView,g=h.valueBlock.valueHexView;if(m.length===4&&g.length===8){for(let d=0;d<4;d++)if((m[d]^g[d])&g[d+4])return!1;return!0}if(m.length===16&&g.length===32){for(let d=0;d<16;d++)if((m[d]^g[d])&g[d+16])return!1;return!0}return!1}function u(l,h){if(l.typesAndValues.length===0||h.typesAndValues.length===0)return!0;if(l.typesAndValues.length<h.typesAndValues.length)return!1;let m=!0,g=0;for(let d=0;d<h.typesAndValues.length;d++){let b=!1;for(let y=g;y<l.typesAndValues.length;y++)if(b=l.typesAndValues[y].isEqual(h.typesAndValues[d]),l.typesAndValues[y].type===h.typesAndValues[d].type&&(m=m&&b),b===!0)if(g===0||g===y){g=y+1;break}else return!1;if(b===!1)return!1}return g===0?!1:m}try{if(this.certs.length===0)throw new Error("Empty certificate array");let l=e.passedWhenNotRevValues||!1,h=e.initialPolicySet||[$e],m=e.initialExplicitPolicy||!1,g=e.initialPolicyMappingInhibit||!1,d=e.initialInhibitPolicy||!1,b=e.initialPermittedSubtreesSet||[],y=e.initialExcludedSubtreesSet||[],E=e.initialRequiredNameForms||[],v=m,j=g,P=d,V=[!1,!1,!1],B=0,x=0,K=0,ee=b,$=y,X=E,me=1;this.certs=await this.sort(l,t);let z=[];z.push($e);let ae=[],kt=new Array(this.certs.length-1);for(let T=0;T<this.certs.length-1;T++)kt[T]=!0;ae.push(kt);let je=new Array(this.certs.length-1),ge=new Array(this.certs.length-1),Le=v?this.certs.length-1:-1;for(let T=this.certs.length-2;T>=0;T--,me++){let J=this.certs[T];if(J.extensions){for(let L=0;L<J.extensions.length;L++){let W=J.extensions[L];if(W.extnID===Nm){ge[T]=W.parsedValue;for(let te=0;te<z.length;te++)if(z[te]===$e){delete ae[te][T];break}for(let te=0;te<W.parsedValue.certificatePolicies.length;te++){let Ee=-1,Et=W.parsedValue.certificatePolicies[te].policyIdentifier;for(let pe=0;pe<z.length;pe++)if(Et===z[pe]){Ee=pe;break}if(Ee===-1){z.push(Et);let pe=new Array(this.certs.length-1);pe[T]=!0,ae.push(pe)}else ae[Ee][T]=!0}}if(W.extnID===Im){if(j)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};je[T]=W.parsedValue}W.extnID===Vm&&v===!1&&(W.parsedValue.requireExplicitPolicy===0?(v=!0,Le=T):V[0]===!1?(V[0]=!0,B=W.parsedValue.requireExplicitPolicy):B=B>W.parsedValue.requireExplicitPolicy?W.parsedValue.requireExplicitPolicy:B,W.parsedValue.inhibitPolicyMapping===0?j=!0:V[1]===!1?(V[1]=!0,x=W.parsedValue.inhibitPolicyMapping+1):x=x>W.parsedValue.inhibitPolicyMapping+1?W.parsedValue.inhibitPolicyMapping+1:x),W.extnID===md&&P===!1&&(W.parsedValue.valueBlock.valueDec===0?P=!0:V[2]===!1?(V[2]=!0,K=W.parsedValue.valueBlock.valueDec):K=K>W.parsedValue.valueBlock.valueDec?W.parsedValue.valueBlock.valueDec:K)}if(P===!0){let L=-1;for(let W=0;W<z.length;W++)if(z[W]===$e){L=W;break}L!==-1&&delete ae[0][T]}v===!1&&V[0]===!0&&(B--,B===0&&(v=!0,Le=T,V[0]=!1)),j===!1&&V[1]===!0&&(x--,x===0&&(j=!0,V[1]=!1)),P===!1&&V[2]===!0&&(K--,K===0&&(P=!0,V[2]=!1))}}for(let T=0;T<this.certs.length-1;T++)if(T<this.certs.length-2&&typeof je[T+1]!="undefined")for(let J=0;J<je[T+1].mappings.length;J++){if(je[T+1].mappings[J].issuerDomainPolicy===$e||je[T+1].mappings[J].subjectDomainPolicy===$e)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let L=-1,W=-1;for(let te=0;te<z.length;te++)z[te]===je[T+1].mappings[J].issuerDomainPolicy&&(L=te),z[te]===je[T+1].mappings[J].subjectDomainPolicy&&(W=te);typeof ae[L][T]!="undefined"&&delete ae[L][T];for(let te=0;te<ge[T].certificatePolicies.length;te++)if(je[T+1].mappings[J].subjectDomainPolicy===ge[T].certificatePolicies[te].policyIdentifier&&L!==-1&&W!==-1)for(let Ee=0;Ee<=T;Ee++)typeof ae[W][Ee]!="undefined"&&(ae[L][Ee]=!0,delete ae[W][Ee])}for(let T=0;T<z.length;T++)if(z[T]===$e)for(let J=0;J<Le;J++)delete ae[T][J];let xe=[];for(let T=0;T<ae.length;T++){let J=!0;for(let L=0;L<this.certs.length-1;L++){let W=!1;if(L<Le&&z[T]===$e&&z.length>1){J=!1;break}if(typeof ae[T][L]=="undefined"){if(L>=Le){for(let te=0;te<z.length;te++)if(z[te]===$e){ae[te][L]===!0&&(W=!0);break}}if(!W){J=!1;break}}}J===!0&&xe.push(z[T])}let Ge=[];if(h.length===1&&h[0]===$e&&v===!1)Ge=h;else if(xe.length===1&&xe[0]===$e)Ge=h;else for(let T=0;T<xe.length;T++)for(let J=0;J<h.length;J++)if(h[J]===xe[T]||h[J]===$e){Ge.push(xe[T]);break}let de={result:Ge.length>0,resultCode:0,resultMessage:Ge.length>0?c:'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:xe,userConstrPolicies:Ge,explicitPolicyIndicator:v,policyMappings:je,certificatePath:this.certs};if(Ge.length===0||de.result===!1)return de;me=1;for(let T=this.certs.length-2;T>=0;T--,me++){let J=this.certs[T],L=[],W=[],te=[];if(J.extensions)for(let Z=0;Z<J.extensions.length;Z++){let M=J.extensions[Z];M.extnID===km&&("permittedSubtrees"in M.parsedValue&&(W=W.concat(M.parsedValue.permittedSubtrees)),"excludedSubtrees"in M.parsedValue&&(te=te.concat(M.parsedValue.excludedSubtrees))),M.extnID===ym&&(L=L.concat(M.parsedValue.altNames))}let Ee=X.length<=0;for(let Z=0;Z<X.length;Z++)switch(X[Z].base.type){case 4:{if(X[Z].base.value.typesAndValues.length!==J.subject.typesAndValues.length)continue;Ee=!0;for(let M=0;M<J.subject.typesAndValues.length;M++)if(J.subject.typesAndValues[M].type!==X[Z].base.value.typesAndValues[M].type){Ee=!1;break}if(Ee===!0)break}break;default:}if(Ee===!1)throw de.result=!1,de.resultCode=21,de.resultMessage="No necessary name form found",de;let Et=[[],[],[],[],[]];for(let Z=0;Z<ee.length;Z++)switch(ee[Z].base.type){case 1:Et[0].push(ee[Z]);break;case 2:Et[1].push(ee[Z]);break;case 4:Et[2].push(ee[Z]);break;case 6:Et[3].push(ee[Z]);break;case 7:Et[4].push(ee[Z]);break;default:}for(let Z=0;Z<5;Z++){let M=!1,dn=!1,as=Et[Z];for(let rs=0;rs<as.length;rs++){switch(Z){case 0:if(L.length>0)for(let he=0;he<L.length;he++)L[he].type===1&&(dn=!0,M=M||a(L[he].value,as[rs].base.value));else for(let he=0;he<J.subject.typesAndValues.length;he++)(J.subject.typesAndValues[he].type==="1.2.840.113549.1.9.1"||J.subject.typesAndValues[he].type==="0.9.2342.19200300.100.1.3")&&(dn=!0,M=M||a(J.subject.typesAndValues[he].value.valueBlock.value,as[rs].base.value));break;case 1:if(L.length>0)for(let he=0;he<L.length;he++)L[he].type===2&&(dn=!0,M=M||s(L[he].value,as[rs].base.value));break;case 2:dn=!0,M=u(J.subject,as[rs].base.value);break;case 3:if(L.length>0)for(let he=0;he<L.length;he++)L[he].type===6&&(dn=!0,M=M||r(L[he].value,as[rs].base.value));break;case 4:if(L.length>0)for(let he=0;he<L.length;he++)L[he].type===7&&(dn=!0,M=M||o(L[he].value,as[rs].base.value));break;default:}if(M)break}if(M===!1&&as.length>0&&dn)throw de.result=!1,de.resultCode=41,de.resultMessage='Failed to meet "permitted sub-trees" name constraint',de}let pe=!1;for(let Z=0;Z<$.length;Z++){switch($[Z].base.type){case 1:if(L.length>=0)for(let M=0;M<L.length;M++)L[M].type===1&&(pe=pe||a(L[M].value,$[Z].base.value));else for(let M=0;M<J.subject.typesAndValues.length;M++)(J.subject.typesAndValues[M].type==="1.2.840.113549.1.9.1"||J.subject.typesAndValues[M].type==="0.9.2342.19200300.100.1.3")&&(pe=pe||a(J.subject.typesAndValues[M].value.valueBlock.value,$[Z].base.value));break;case 2:if(L.length>0)for(let M=0;M<L.length;M++)L[M].type===2&&(pe=pe||s(L[M].value,$[Z].base.value));break;case 4:pe=pe||u(J.subject,$[Z].base.value);break;case 6:if(L.length>0)for(let M=0;M<L.length;M++)L[M].type===6&&(pe=pe||r(L[M].value,$[Z].base.value));break;case 7:if(L.length>0)for(let M=0;M<L.length;M++)L[M].type===7&&(pe=pe||o(L[M].value,$[Z].base.value));break;default:}if(pe)break}if(pe===!0)throw de.result=!1,de.resultCode=42,de.resultMessage='Failed to meet "excluded sub-trees" name constraint',de;ee=ee.concat(W),$=$.concat(te)}return de}catch(l){return l instanceof Error?l instanceof Qt?{result:!1,resultCode:l.code,resultMessage:l.message,error:l}:{result:!1,resultCode:en.unknown,resultMessage:l.message,error:l}:l&&typeof l=="object"&&"resultMessage"in l?l:{result:!1,resultCode:-1,resultMessage:`${l}`}}}},sh="tbsResponseData",ou="signatureAlgorithm",lu="signature",ei="certs",Ju="BasicOCSPResponse",em=`${Ju}.${sh}`,tm=`${Ju}.${ou}`,sm=`${Ju}.${lu}`,nh=`${Ju}.${ei}`,Bv=[em,tm,sm,nh],hn=class n extends C{constructor(e={}){super(),this.tbsResponseData=i(e,sh,n.defaultValues(sh)),this.signatureAlgorithm=i(e,ou,n.defaultValues(ou)),this.signature=i(e,lu,n.defaultValues(lu)),ei in e&&(this.certs=i(e,ei,n.defaultValues(ei))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sh:return new Ye;case ou:return new S;case lu:return new F;case ei:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let s=Ye.compareWithDefault("tbs",t.tbs)&&Ye.compareWithDefault("responderID",t.responderID)&&Ye.compareWithDefault("producedAt",t.producedAt)&&Ye.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(s=s&&Ye.compareWithDefault("responseExtensions",t.responseExtensions)),s}case ou:return t.algorithmId===c&&!("algorithmParams"in t);case lu:return t.isEqual(n.defaultValues(e));case ei:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||Ju,value:[Ye.schema(t.tbsResponseData||{names:{blockName:em}}),S.schema(t.signatureAlgorithm||{names:{blockName:tm}}),new F({name:t.signature||sm}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new f({value:[new _({name:nh,value:Pe.schema(t.certs||{})})]})]})]})}fromSchema(e){N(e,Bv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsResponseData=new Ye({schema:t.result[em]}),this.signatureAlgorithm=new S({schema:t.result[tm]}),this.signature=t.result[sm],nh in t.result&&(this.certs=Array.from(t.result[nh],s=>new Pe({schema:s})))}toSchema(){let e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[new f({value:Array.from(this.certs,t=>t.toSchema())})]})),new f({value:e})}toJSON(){let e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,t=>t.toJSON())),e}async getCertificateStatus(e,t,s=q(!0)){let a={isForCertificate:!1,status:2},r={},o=[];for(let u of this.tbsResponseData.responses){let l=s.getAlgorithmByOID(u.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!r[l.name]){r[l.name]=1;let h=new Oe;o.push(h),await h.createForCertificate(e,{hashAlgorithm:l.name,issuerCertificate:t},s)}}for(let u of this.tbsResponseData.responses)for(let l of o)if(u.certID.isEqual(l)){a.isForCertificate=!0;try{switch(u.certStatus.idBlock.isConstructed){case!0:u.certStatus.idBlock.tagNumber===1&&(a.status=1);break;case!1:switch(u.certStatus.idBlock.tagNumber){case 0:a.status=0;break;case 2:a.status=2;break;default:}break;default:}}catch(h){}return a}return a}async sign(e,t="SHA-1",s=q(!0)){if(!e)throw new Error("Need to provide a private key for signing");let a=await s.getSignatureParameters(e,t),r=a.parameters.algorithm;if(!("name"in r))throw new Error("Empty algorithm");this.signatureAlgorithm=a.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());let o=await s.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:r});this.signature=new F({valueHex:o})}async verify(e={},t=q(!0)){let s=null,a=-1,r=e.trustedCerts||[];if(!this.certs)throw new Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof oe:for(let[h,m]of this.certs.entries())if(m.subject.isEqual(this.tbsResponseData.responderID)){a=h;break}break;case this.tbsResponseData.responderID instanceof I:for(let[h,m]of this.certs.entries()){let g=await t.digest({name:"sha-1"},m.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(is(g,this.tbsResponseData.responderID.valueBlock.valueHex)){a=h;break}}break;default:throw new Error("Wrong value for responderID")}if(a===-1)throw new Error("Correct certificate was not found in OCSP response");s=this.certs[a];let o=[s];for(let h of this.certs){let m=await Hm(h,s);m&&o.push(m)}if(!(await new qu({certs:o,trustedCerts:r}).verify({},t)).result)throw new Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[a].subjectPublicKeyInfo,this.signatureAlgorithm)}};hn.CLASS_NAME="BasicOCSPResponse";var Lf="tbs",Hf="version",_f="subject",Kf="subjectPublicKeyInfo",er="attributes",uu="signatureAlgorithm",cu="signatureValue",zi="CertificationRequestInfo",Mm=`${zi}.version`,qm=`${zi}.subject`,$m=`${zi}.subjectPublicKeyInfo`,Dh=`${zi}.attributes`,Pv=[zi,Mm,qm,$m,Dh,uu,cu];function jv(n={}){let e=i(n,"names",{});return new f({name:e.CertificationRequestInfo||zi,value:[new w({name:e.CertificationRequestInfoVersion||Mm}),oe.schema(e.subject||{names:{blockName:qm}}),qe.schema({names:{blockName:$m}}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({optional:!0,name:e.CertificationRequestInfoAttributes||Dh,value:fe.schema(e.attributes||{})})]})]})}var Uh=class n extends C{get tbs(){return H.BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(i(e,Lf,n.defaultValues(Lf))),this.version=i(e,Hf,n.defaultValues(Hf)),this.subject=i(e,_f,n.defaultValues(_f)),this.subjectPublicKeyInfo=i(e,Kf,n.defaultValues(Kf)),er in e&&(this.attributes=i(e,er,n.defaultValues(er))),this.signatureAlgorithm=i(e,uu,n.defaultValues(uu)),this.signatureValue=i(e,cu,n.defaultValues(cu)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Lf:return we;case Hf:return 0;case _f:return new oe;case Kf:return new qe;case er:return[];case uu:return new S;case cu:return new F;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({value:[jv(t.certificationRequestInfo||{}),new f({name:t.signatureAlgorithm||uu,value:[new O,new U({optional:!0})]}),new F({name:t.signatureValue||cu})]})}fromSchema(e){N(e,Pv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[Mm].valueBlock.valueDec,this.subject=new oe({schema:t.result[qm]}),this.subjectPublicKeyInfo=new qe({schema:t.result[$m]}),Dh in t.result&&(this.attributes=Array.from(t.result[Dh],s=>new fe({schema:s}))),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[new w({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return er in this&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],t=>t.toSchema())})),new f({value:e})}toSchema(e=!1){let t;if(e===!1){if(this.tbsView.byteLength===0)return n.schema();let s=ve(this.tbsView);A.assert(s,"PKCS#10 Certificate Request"),t=s.result}else t=this.encodeTBS();return new f({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:H.Convert.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return er in this&&(e.attributes=Array.from(this.attributes||[],t=>t.toJSON())),e}async sign(e,t="SHA-1",s=q(!0)){if(!e)throw new Error("Need to provide a private key for signing");let a=await s.getSignatureParameters(e,t),r=a.parameters;this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let o=await s.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new F({valueHex:o})}async verify(e=q(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=q(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}};Uh.CLASS_NAME="CertificationRequest";var pa="digestAlgorithm",va="digest",xv=[pa,va],wt=class n extends C{constructor(e={}){super(),this.digestAlgorithm=i(e,pa,n.defaultValues(pa)),this.digest=i(e,va,n.defaultValues(va)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pa:return new S;case va:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pa:return S.compareWithDefault("algorithmId",t.algorithmId)&&!("algorithmParams"in t);case va:return t.isEqual(n.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.digestAlgorithm||{names:{blockName:pa}}),new I({name:t.digest||va})]})}fromSchema(e){N(e,xv);let t=k(e,e,n.schema({names:{digestAlgorithm:{names:{blockName:pa}},digest:va}}));A.assertSchema(t,this.className),this.digestAlgorithm=new S({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new f({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}};wt.CLASS_NAME="DigestInfo";var ti="eContentType",nt="eContent",Ov=[ti,nt],St=class n extends C{constructor(e={}){if(super(),this.eContentType=i(e,ti,n.defaultValues(ti)),nt in e&&(this.eContent=i(e,nt,n.defaultValues(nt)),this.eContent.idBlock.tagClass===1&&this.eContent.idBlock.tagNumber===4&&this.eContent.idBlock.isConstructed===!1)){let t=new I({idBlock:{isConstructed:!0},isConstructed:!0}),s=0,a=this.eContent.valueBlock.valueHexView.slice().buffer,r=a.byteLength;for(;r>0;){let o=new Uint8Array(a,s,s+65536>a.byteLength?a.byteLength-s:65536),u=new ArrayBuffer(o.length),l=new Uint8Array(u);for(let h=0;h<l.length;h++)l[h]=o[h];t.valueBlock.value.push(new I({valueHex:u})),r-=o.length,s+=o.length}this.eContent=t}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ti:return c;case nt:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ti:return t===c;case nt:return t.idBlock.tagClass===1&&t.idBlock.tagNumber===4?t.isEqual(n.defaultValues(nt)):!1;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.eContentType||c}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new U({name:t.eContent||c})]})]})}fromSchema(e){N(e,Ov);let t=k(e,e,n.schema({names:{eContentType:ti,eContent:nt}}));A.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),nt in t.result&&(this.eContent=t.result.eContent)}toSchema(){let e=[];return e.push(new O({value:this.eContentType})),this.eContent&&n.compareWithDefault(nt,this.eContent)===!1&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new f({value:e})}toJSON(){let e={eContentType:this.eContentType};return this.eContent&&n.compareWithDefault(nt,this.eContent)===!1&&(e.eContent=this.eContent.toJSON()),e}};St.CLASS_NAME="EncapsulatedContentInfo";var nm=class extends ts{constructor(e={}){super(e)}},wa="mac",Sa="macSalt",Mt="iterations",Rv=[wa,Sa,Mt],at=class n extends C{constructor(e={}){super(),this.mac=i(e,wa,n.defaultValues(wa)),this.macSalt=i(e,Sa,n.defaultValues(Sa)),Mt in e&&(this.iterations=i(e,Mt,n.defaultValues(Mt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wa:return new wt;case Sa:return new I;case Mt:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case wa:return wt.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&wt.compareWithDefault("digest",t.digest);case Sa:return t.isEqual(n.defaultValues(e));case Mt:return t===n.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,optional:t.optional||!0,value:[wt.schema(t.mac||{names:{blockName:wa}}),new I({name:t.macSalt||Sa}),new w({optional:!0,name:t.iterations||Mt})]})}fromSchema(e){N(e,Rv);let t=k(e,e,n.schema({names:{mac:{names:{blockName:wa}},macSalt:Sa,iterations:Mt}}));A.assertSchema(t,this.className),this.mac=new wt({schema:t.result.mac}),this.macSalt=t.result.macSalt,Mt in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){let e=[this.mac.toSchema(),this.macSalt];return this.iterations!==void 0&&e.push(new w({value:this.iterations})),new f({value:e})}toJSON(){let e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return this.iterations!==void 0&&(e.iterations=this.iterations),e}};at.CLASS_NAME="MacData";var tn="hashAlgorithm",sn="hashedMessage",Tv=[tn,sn],Me=class n extends C{static async create(e,t,s=q(!0)){let a=s.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),r=await s.digest(e,t);return new n({hashAlgorithm:new S({algorithmId:a,algorithmParams:new le}),hashedMessage:new I({valueHex:r})})}constructor(e={}){super(),this.hashAlgorithm=i(e,tn,n.defaultValues(tn)),this.hashedMessage=i(e,sn,n.defaultValues(sn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tn:return new S;case sn:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tn:return t.algorithmId===c&&!("algorithmParams"in t);case sn:return t.isEqual(n.defaultValues(e))===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.hashAlgorithm||{}),new I({name:t.hashedMessage||c})]})}fromSchema(e){N(e,Tv);let t=k(e,e,n.schema({names:{hashAlgorithm:{names:{blockName:tn}},hashedMessage:sn}}));A.assertSchema(t,this.className),this.hashAlgorithm=new S({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new f({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}};Me.CLASS_NAME="MessageImprint";var si="reqCert",Gs="singleRequestExtensions",Dv=[si,Gs],Ma=class n extends C{constructor(e={}){super(),this.reqCert=i(e,si,n.defaultValues(si)),Gs in e&&(this.singleRequestExtensions=i(e,Gs,n.defaultValues(Gs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case si:return new Oe;case Gs:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case si:return t.isEqual(n.defaultValues(e));case Gs:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[Oe.schema(t.reqCert||{}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Se.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||c}})]})]})}fromSchema(e){N(e,Dv);let t=k(e,e,n.schema({names:{reqCert:{names:{blockName:si}},extensions:{names:{blockName:Gs}}}}));A.assertSchema(t,this.className),this.reqCert=new Oe({schema:t.result.reqCert}),Gs in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,s=>new Ue({schema:s})))}toSchema(){let e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new f({value:Array.from(this.singleRequestExtensions,t=>t.toSchema())})]})),new f({value:e})}toJSON(){let e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,t=>t.toJSON())),e}};Ma.CLASS_NAME="Request";var $c="tbs",ni="version",ai="requestorName",Jc="requestList",ri="requestExtensions",Zi="TBSRequest",ah=`${Zi}.${ni}`,rh=`${Zi}.${ai}`,am=`${Zi}.requests`,ih=`${Zi}.${ri}`,Uv=[Zi,ah,rh,am,ih],Qe=class n extends C{get tbs(){return H.BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(i(e,$c,n.defaultValues($c))),ni in e&&(this.version=i(e,ni,n.defaultValues(ni))),ai in e&&(this.requestorName=i(e,ai,n.defaultValues(ai))),this.requestList=i(e,Jc,n.defaultValues(Jc)),ri in e&&(this.requestExtensions=i(e,ri,n.defaultValues(ri))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $c:return we;case ni:return 0;case ai:return new ne;case Jc:case ri:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case $c:return t.byteLength===0;case ni:return t===n.defaultValues(e);case ai:return t.type===ne.defaultValues("type")&&Object.keys(t.value).length===0;case Jc:case ri:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||Zi,value:[new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:t.TBSRequestVersion||ah})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[ne.schema(t.requestorName||{names:{blockName:rh}})]}),new f({name:t.requestList||"TBSRequest.requestList",value:[new _({name:t.requests||am,value:Ma.schema(t.requestNames||{})})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[Se.schema(t.extensions||{names:{blockName:t.requestExtensions||ih}})]})]})}fromSchema(e){N(e,Uv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,ah in t.result&&(this.version=t.result[ah].valueBlock.valueDec),rh in t.result&&(this.requestorName=new ne({schema:t.result[rh]})),this.requestList=Array.from(t.result[am],s=>new Ma({schema:s})),ih in t.result&&(this.requestExtensions=Array.from(t.result[ih].valueBlock.value,s=>new Ue({schema:s})))}toSchema(e=!1){let t;if(e===!1){if(this.tbsView.byteLength===0)return n.schema();let s=ve(this.tbsView);if(A.assert(s,"TBS Request"),!(s.result instanceof f))throw new Error("ASN.1 result should be SEQUENCE");t=s.result}else{let s=[];this.version!==void 0&&s.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[new w({value:this.version})]})),this.requestorName&&s.push(new p({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),s.push(new f({value:Array.from(this.requestList,a=>a.toSchema())})),this.requestExtensions&&s.push(new p({idBlock:{tagClass:3,tagNumber:2},value:[new f({value:Array.from(this.requestExtensions,a=>a.toSchema())})]})),t=new f({value:s})}return t}toJSON(){let e={};return this.version!=null&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,t=>t.toJSON()),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,t=>t.toJSON())),e}};Qe.CLASS_NAME="TBSRequest";var tr="signatureAlgorithm",sr="signature",ps="certs",vt=class n extends C{constructor(e={}){super(),this.signatureAlgorithm=i(e,tr,n.defaultValues(tr)),this.signature=i(e,sr,n.defaultValues(sr)),ps in e&&(this.certs=i(e,ps,n.defaultValues(ps))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tr:return new S;case sr:return new F;case ps:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tr:return t.algorithmId===c&&!("algorithmParams"in t);case sr:return t.isEqual(n.defaultValues(e));case ps:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[S.schema(t.signatureAlgorithm||{}),new F({name:t.signature||c}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new f({value:[new _({name:t.certs||c,value:Pe.schema({})})]})]})]})}fromSchema(e){N(e,[tr,sr,ps]);let t=k(e,e,n.schema({names:{signatureAlgorithm:{names:{blockName:tr}},signature:sr,certs:ps}}));A.assertSchema(t,this.className),this.signatureAlgorithm=new S({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,ps in t.result&&(this.certs=Array.from(t.result.certs,s=>new Pe({schema:s})))}toSchema(){let e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new f({value:Array.from(this.certs,t=>t.toSchema())})]})),new f({value:e})}toJSON(){let e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,t=>t.toJSON())),e}};vt.CLASS_NAME="Signature";var ii="tbsRequest",Ws="optionalSignature",Lv=[ii,Ws],Lh=class n extends C{constructor(e={}){super(),this.tbsRequest=i(e,ii,n.defaultValues(ii)),Ws in e&&(this.optionalSignature=i(e,Ws,n.defaultValues(Ws))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ii:return new Qe;case Ws:return new vt;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ii:return Qe.compareWithDefault("tbs",t.tbs)&&Qe.compareWithDefault("version",t.version)&&Qe.compareWithDefault("requestorName",t.requestorName)&&Qe.compareWithDefault("requestList",t.requestList)&&Qe.compareWithDefault("requestExtensions",t.requestExtensions);case Ws:return vt.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&vt.compareWithDefault("signature",t.signature)&&vt.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||"OCSPRequest",value:[Qe.schema(t.tbsRequest||{names:{blockName:ii}}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[vt.schema(t.optionalSignature||{names:{blockName:Ws}})]})]})}fromSchema(e){N(e,Lv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.tbsRequest=new Qe({schema:t.result.tbsRequest}),Ws in t.result&&(this.optionalSignature=new vt({schema:t.result.optionalSignature}))}toSchema(e=!1){let t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new f({value:t})}toJSON(){let e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,s=q(!0)){let a=new Oe;await a.createForCertificate(e,t,s),this.tbsRequest.requestList.push(new Ma({reqCert:a}))}async sign(e,t="SHA-1",s=q(!0)){if(Q.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw new Error('Need to create "optionalSignature" field before signing');let a=await s.getSignatureParameters(e,t),r=a.parameters;this.optionalSignature.signatureAlgorithm=a.signatureAlgorithm;let o=this.tbsRequest.toSchema(!0).toBER(!1),u=await s.signWithPrivateKey(o,e,r);this.optionalSignature.signature=new F({valueHex:u})}verify(){}};Lh.CLASS_NAME="OCSPRequest";var oi="responseType",li="response",Hv=[oi,li],Xt=class n extends C{constructor(e={}){super(),this.responseType=i(e,oi,n.defaultValues(oi)),this.response=i(e,li,n.defaultValues(li)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oi:return c;case li:return new I;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oi:return t===c;case li:return t.isEqual(n.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new O({name:t.responseType||c}),new I({name:t.response||c})]})}fromSchema(e){N(e,Hv);let t=k(e,e,n.schema({names:{responseType:oi,response:li}}));A.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new f({value:[new O({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}};Xt.CLASS_NAME="ResponseBytes";var nr="responseStatus",Ot="responseBytes",Hh=class n extends C{constructor(e={}){super(),this.responseStatus=i(e,nr,n.defaultValues(nr)),Ot in e&&(this.responseBytes=i(e,Ot,n.defaultValues(Ot))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nr:return new Ze;case Ot:return new Xt;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nr:return t.isEqual(n.defaultValues(e));case Ot:return Xt.compareWithDefault("responseType",t.responseType)&&Xt.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||"OCSPResponse",value:[new Ze({name:t.responseStatus||nr}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Xt.schema(t.responseBytes||{names:{blockName:Ot}})]})]})}fromSchema(e){N(e,[nr,Ot]);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,Ot in t.result&&(this.responseBytes=new Xt({schema:t.result.responseBytes}))}toSchema(){let e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new f({value:e})}toJSON(){let e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,s=q(!0)){let a,r={isForCertificate:!1,status:2};if(!this.responseBytes||this.responseBytes.responseType!==Cu)return r;try{let o=ve(this.responseBytes.response.valueBlock.valueHexView);A.assert(o,"Basic OCSP response"),a=new hn({schema:o.result})}catch(o){return r}return a.getCertificateStatus(e,t,s)}async sign(e,t,s=q(!0)){var a;if(this.responseBytes&&this.responseBytes.responseType===Cu)return hn.fromBER(this.responseBytes.response.valueBlock.valueHexView).sign(e,t,s);throw new Error(`Unknown ResponseBytes type: ${((a=this.responseBytes)===null||a===void 0?void 0:a.responseType)||"Unknown"}`)}async verify(e=null,t=q(!0)){var s;if(!(Ot in this))throw new Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===Cu){let a=hn.fromBER(this.responseBytes.response.valueBlock.valueHexView);return e!==null&&(a.certs||(a.certs=[]),a.certs.push(e)),a.verify({},t)}throw new Error(`Unknown ResponseBytes type: ${((s=this.responseBytes)===null||s===void 0?void 0:s.responseType)||"Unknown"}`)}};Hh.CLASS_NAME="OCSPResponse";var En="type",qt="attributes",Fc="encodedValue",_v=[qt],Be=class n extends C{constructor(e={}){super(),this.type=i(e,En,n.defaultValues(En)),this.attributes=i(e,qt,n.defaultValues(qt)),this.encodedValue=i(e,Fc,n.defaultValues(Fc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case En:return-1;case qt:return[];case Fc:return we;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case En:return t===n.defaultValues(En);case qt:return t.length===0;case Fc:return t.byteLength===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new p({name:t.blockName||c,optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new _({name:t.attributes||c,value:fe.schema()})]})}fromSchema(e){N(e,_v);let t=k(e,e,n.schema({names:{tagNumber:this.type,attributes:qt}}));A.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=H.BufferSourceConverter.toArrayBuffer(t.result.valueBeforeDecodeView);let s=new Uint8Array(this.encodedValue);if(s[0]=49,!(qt in t.result)){if(this.type===0)throw new Error("Wrong structure of SignedUnsignedAttributes");return}this.attributes=Array.from(t.result.attributes,a=>new fe({schema:a}))}toSchema(){if(n.compareWithDefault(En,this.type)||n.compareWithDefault(qt,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new p({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(n.compareWithDefault(En,this.type)||n.compareWithDefault(qt,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}};Be.CLASS_NAME="SignedAndUnsignedAttributes";var ui="version",ya="sid",ci="digestAlgorithm",Ys="signedAttrs",hi="signatureAlgorithm",hu="signature",Qs="unsignedAttrs",gn="SignerInfo",rm=`${gn}.${ui}`,fu=`${gn}.${ya}`,im=`${gn}.${ci}`,oh=`${gn}.${Ys}`,om=`${gn}.${hi}`,lm=`${gn}.${hu}`,lh=`${gn}.${Qs}`,Kv=[rm,fu,im,oh,om,lm,lh],qa=class n extends C{constructor(e={}){super(),this.version=i(e,ui,n.defaultValues(ui)),this.sid=i(e,ya,n.defaultValues(ya)),this.digestAlgorithm=i(e,ci,n.defaultValues(ci)),Ys in e&&(this.signedAttrs=i(e,Ys,n.defaultValues(Ys))),this.signatureAlgorithm=i(e,hi,n.defaultValues(hi)),this.signature=i(e,hu,n.defaultValues(hu)),Qs in e&&(this.unsignedAttrs=i(e,Qs,n.defaultValues(Qs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ui:return 0;case ya:return new U;case ci:return new S;case Ys:return new Be({type:0});case hi:return new S;case hu:return new I;case Qs:return new Be({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ui:return n.defaultValues(ui)===t;case ya:return t instanceof U;case ci:return t instanceof S?t.isEqual(n.defaultValues(ci)):!1;case Ys:return Be.compareWithDefault("type",t.type)&&Be.compareWithDefault("attributes",t.attributes)&&Be.compareWithDefault("encodedValue",t.encodedValue);case hi:return t instanceof S?t.isEqual(n.defaultValues(hi)):!1;case hu:case Qs:return Be.compareWithDefault("type",t.type)&&Be.compareWithDefault("attributes",t.attributes)&&Be.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:gn,value:[new w({name:t.version||rm}),new ie({value:[be.schema(t.sidSchema||{names:{blockName:fu}}),new ie({value:[new p({optional:!0,name:t.sid||fu,idBlock:{tagClass:3,tagNumber:0},value:[new I]}),new D({optional:!0,name:t.sid||fu,idBlock:{tagClass:3,tagNumber:0}})]})]}),S.schema(t.digestAlgorithm||{names:{blockName:im}}),Be.schema(t.signedAttrs||{names:{blockName:oh,tagNumber:0}}),S.schema(t.signatureAlgorithm||{names:{blockName:om}}),new I({name:t.signature||lm}),Be.schema(t.unsignedAttrs||{names:{blockName:lh,tagNumber:1}})]})}fromSchema(e){N(e,Kv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.version=t.result[rm].valueBlock.valueDec;let s=t.result[fu];s.idBlock.tagClass===1?this.sid=new be({schema:s}):this.sid=s,this.digestAlgorithm=new S({schema:t.result[im]}),oh in t.result&&(this.signedAttrs=new Be({type:0,schema:t.result[oh]})),this.signatureAlgorithm=new S({schema:t.result[om]}),this.signature=t.result[lm],lh in t.result&&(this.unsignedAttrs=new Be({type:1,schema:t.result[lh]}))}toSchema(){if(n.compareWithDefault(ya,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');let e=[];return e.push(new w({value:this.version})),this.sid instanceof be?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&n.compareWithDefault(Ys,this.signedAttrs)===!1&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&n.compareWithDefault(Qs,this.unsignedAttrs)===!1&&e.push(this.unsignedAttrs.toSchema()),new f({value:e})}toJSON(){if(n.compareWithDefault(ya,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');let e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof U||(e.sid=this.sid.toJSON()),this.signedAttrs&&n.compareWithDefault(Ys,this.signedAttrs)===!1&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&n.compareWithDefault(Qs,this.unsignedAttrs)===!1&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}};qa.CLASS_NAME="SignerInfo";var mu="version",gu="policy",du="messageImprint",pu="serialNumber",vu="genTime",Aa="ordering",ba="nonce",fi="accuracy",mi="tsa",gi="extensions",ot="TSTInfo",um=`${ot}.${mu}`,cm=`${ot}.${gu}`,hm=`${ot}.${du}`,fm=`${ot}.${pu}`,mm=`${ot}.${vu}`,uh=`${ot}.${fi}`,ch=`${ot}.${Aa}`,hh=`${ot}.${ba}`,fh=`${ot}.${mi}`,mh=`${ot}.${gi}`,Mv=[um,cm,hm,fm,mm,uh,ch,hh,fh,mh],$u=class n extends C{constructor(e={}){super(),this.version=i(e,mu,n.defaultValues(mu)),this.policy=i(e,gu,n.defaultValues(gu)),this.messageImprint=i(e,du,n.defaultValues(du)),this.serialNumber=i(e,pu,n.defaultValues(pu)),this.genTime=i(e,vu,n.defaultValues(vu)),fi in e&&(this.accuracy=i(e,fi,n.defaultValues(fi))),Aa in e&&(this.ordering=i(e,Aa,n.defaultValues(Aa))),ba in e&&(this.nonce=i(e,ba,n.defaultValues(ba))),mi in e&&(this.tsa=i(e,mi,n.defaultValues(mi))),gi in e&&(this.extensions=i(e,gi,n.defaultValues(gi))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case mu:return 0;case gu:return c;case du:return new Me;case pu:return new w;case vu:return new Date(0,0,0);case fi:return new dt;case Aa:return!1;case ba:return new w;case mi:return new ne;case gi:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case mu:case gu:case vu:case Aa:return t===n.defaultValues(Aa);case du:return Me.compareWithDefault(tn,t.hashAlgorithm)&&Me.compareWithDefault(sn,t.hashedMessage);case pu:case ba:return t.isEqual(n.defaultValues(ba));case fi:return dt.compareWithDefault(Ft,t.seconds)&&dt.compareWithDefault(Gt,t.millis)&&dt.compareWithDefault(Wt,t.micros);case mi:return ne.compareWithDefault(ki,t.type)&&ne.compareWithDefault(Ei,t.value);case gi:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||ot,value:[new w({name:t.version||um}),new O({name:t.policy||cm}),Me.schema(t.messageImprint||{names:{blockName:hm}}),new w({name:t.serialNumber||fm}),new re({name:t.genTime||mm}),dt.schema(t.accuracy||{names:{blockName:uh}}),new Ke({name:t.ordering||ch,optional:!0}),new w({name:t.nonce||hh,optional:!0}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[ne.schema(t.tsa||{names:{blockName:fh}})]}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new _({name:t.extensions||mh,value:Ue.schema(t.extension||{})})]})]})}fromSchema(e){N(e,Mv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.version=t.result[um].valueBlock.valueDec,this.policy=t.result[cm].valueBlock.toString(),this.messageImprint=new Me({schema:t.result[hm]}),this.serialNumber=t.result[fm],this.genTime=t.result[mm].toDate(),uh in t.result&&(this.accuracy=new dt({schema:t.result[uh]})),ch in t.result&&(this.ordering=t.result[ch].valueBlock.value),hh in t.result&&(this.nonce=t.result[hh]),fh in t.result&&(this.tsa=new ne({schema:t.result[fh]})),mh in t.result&&(this.extensions=Array.from(t.result[mh],s=>new Ue({schema:s})))}toSchema(){let e=[];return e.push(new w({value:this.version})),e.push(new O({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new re({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),this.ordering!==void 0&&e.push(new Ke({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),this.ordering!==void 0&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,t=>t.toJSON())),e}async verify(e,t=q(!0)){if(!e.data)throw new Error('"data" is a mandatory attribute for TST_INFO verification');let s=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw new Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw new Error("Generation time for TSTInfo object is more than notAfter value");let a=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),r=await t.digest(a.name,new Uint8Array(s));return H.BufferSourceConverter.isEqual(r,this.messageImprint.hashedMessage.valueBlock.valueHexView)}};$u.CLASS_NAME="TSTInfo";var di="version",wu="digestAlgorithms",Su="encapContentInfo",pi="certificates",vi="crls",yu="signerInfos",Vo="ocsps",Ja="SignedData",gm=`${Ja}.${di}`,gh=`${Ja}.${wu}`,dm=`${Ja}.${Su}`,dh=`${Ja}.${pi}`,ph=`${Ja}.${vi}`,vh=`${Ja}.${yu}`,qv=[gm,gh,dm,dh,ph,vh],Ce=class extends Error{constructor({message:e,code:t=0,date:s=new Date,signatureVerified:a=null,signerCertificate:r=null,signerCertificateVerified:o=null,timestampSerial:u=null,certificatePath:l=[]}){super(e),this.name="SignedDataVerifyError",this.date=s,this.code=t,this.timestampSerial=u,this.signatureVerified=a,this.signerCertificate=r,this.signerCertificateVerified=o,this.certificatePath=l}},ss=class n extends C{constructor(e={}){super(),this.version=i(e,di,n.defaultValues(di)),this.digestAlgorithms=i(e,wu,n.defaultValues(wu)),this.encapContentInfo=i(e,Su,n.defaultValues(Su)),pi in e&&(this.certificates=i(e,pi,n.defaultValues(pi))),vi in e&&(this.crls=i(e,vi,n.defaultValues(vi))),Vo in e&&(this.ocsps=i(e,Vo,n.defaultValues(Vo))),this.signerInfos=i(e,yu,n.defaultValues(yu)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case di:return 0;case wu:return[];case Su:return new St;case pi:return[];case vi:return[];case Vo:return[];case yu:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case di:return t===n.defaultValues(di);case Su:return St.compareWithDefault("eContentType",t.eContentType)&&St.compareWithDefault("eContent",t.eContent);case wu:case pi:case vi:case Vo:case yu:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return t.optional===void 0&&(t.optional=!1),new f({name:t.blockName||Ja,optional:t.optional,value:[new w({name:t.version||gm}),new ue({value:[new _({name:t.digestAlgorithms||gh,value:S.schema()})]}),St.schema(t.encapContentInfo||{names:{blockName:dm}}),new p({name:t.certificates||dh,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:bt.schema().valueBlock.value}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:on.schema(t.crls||{names:{crls:ph}}).valueBlock.value}),new ue({value:[new _({name:t.signerInfos||vh,value:qa.schema()})]})]})}fromSchema(e){N(e,qv);let t=k(e,e,n.schema());if(A.assertSchema(t,this.className),this.version=t.result[gm].valueBlock.valueDec,gh in t.result&&(this.digestAlgorithms=Array.from(t.result[gh],s=>new S({schema:s}))),this.encapContentInfo=new St({schema:t.result[dm]}),dh in t.result){let s=new bt({schema:new ue({value:t.result[dh].valueBlock.value})});this.certificates=s.certificates.slice(0)}ph in t.result&&(this.crls=Array.from(t.result[ph],s=>s.idBlock.tagClass===1?new fn({schema:s}):(s.idBlock.tagClass=1,s.idBlock.tagNumber=16,new rn({schema:s})))),vh in t.result&&(this.signerInfos=Array.from(t.result[vh],s=>new qa({schema:s})))}toSchema(e=!1){let t=[];if(this.certificates&&this.certificates.length&&this.certificates.some(s=>s instanceof Pa)||this.crls&&this.crls.length&&this.crls.some(s=>s instanceof rn)?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some(s=>s instanceof rt)?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some(s=>s instanceof Ra)||this.signerInfos.some(s=>s.version===3)||this.encapContentInfo.eContentType!==n.ID_DATA?this.version=3:this.version=1,t.push(new w({value:this.version})),t.push(new ue({value:Array.from(this.digestAlgorithms,s=>s.toSchema())})),t.push(this.encapContentInfo.toSchema()),this.certificates){let a=new bt({certificates:this.certificates}).toSchema();t.push(new p({idBlock:{tagClass:3,tagNumber:0},value:a.valueBlock.value}))}return this.crls&&t.push(new p({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,s=>{if(s instanceof rn){let a=s.toSchema();return a.idBlock.tagClass=3,a.idBlock.tagNumber=1,a}return s.toSchema(e)})})),t.push(new ue({value:Array.from(this.signerInfos,s=>s.toSchema())})),new f({value:t})}toJSON(){let e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,t=>t.toJSON()),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,t=>t.toJSON())};return this.certificates&&(e.certificates=Array.from(this.certificates,t=>t.toJSON())),this.crls&&(e.crls=Array.from(this.crls,t=>t.toJSON())),e}async verify({signer:e=-1,data:t=we,trustedCerts:s=[],checkDate:a=new Date,checkChain:r=!1,passedWhenNotRevValues:o=!1,extendedMode:u=!1,findOrigin:l=null,findIssuer:h=null}={},m=q(!0)){let g=null,d=null;try{let b=we,y=c,E=[],v=this.signerInfos[e];if(!v)throw new Ce({date:a,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new Ce({date:a,code:2,message:"No certificates attached to this signed data"});if(v.sid instanceof be){for(let B of this.certificates)if(B instanceof Pe&&B.issuer.isEqual(v.sid.issuer)&&B.serialNumber.isEqual(v.sid.serialNumber)){g=B;break}}else{let B=v.sid,x=B.idBlock.isConstructed?B.valueBlock.value[0].valueBlock.valueHex:B.valueBlock.valueHex;for(let K of this.certificates){if(!(K instanceof Pe))continue;let ee=await m.digest({name:"sha-1"},K.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(is(ee,x)){g=K;break}}}if(!g)throw new Ce({date:a,code:3,message:"Unable to find signer certificate"});if(this.encapContentInfo.eContentType===wd){if(!this.encapContentInfo.eContent)throw new Ce({date:a,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0});let B;try{B=$u.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(x){throw new Ce({date:a,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0})}if(a=B.genTime,d=B.serialNumber.valueBlock.valueHexView.slice().buffer,t.byteLength===0)throw new Ce({date:a,code:4,message:"Missed detached data input array"});if(!await B.verify({data:t},m))throw new Ce({date:a,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:!1,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0})}if(r){let B=this.certificates.filter($=>$ instanceof Pe&&!!Hm($,g)),x={checkDate:a,certs:B,trustedCerts:s};h&&(x.findIssuer=h),l&&(x.findOrigin=l);let K=new qu(x);if(K.certs.push(g),this.crls)for(let $ of this.crls)"thisUpdate"in $?K.crls.push($):$.otherRevInfoFormat===Cu&&K.ocsps.push(new hn({schema:$.otherRevInfo}));this.ocsps&&K.ocsps.push(...this.ocsps);let ee=await K.verify({passedWhenNotRevValues:o},m).catch($=>{throw new Ce({date:a,code:5,message:`Validation of signer's certificate failed with error: ${$ instanceof Object?$.resultMessage:$}`,signerCertificate:g,signerCertificateVerified:!1})});if(ee.certificatePath&&(E=ee.certificatePath),!ee.result)throw new Ce({date:a,code:5,message:`Validation of signer's certificate failed: ${ee.resultMessage}`,signerCertificate:g,signerCertificateVerified:!1})}let j=m.getAlgorithmByOID(v.digestAlgorithm.algorithmId);if(!("name"in j))throw new Ce({date:a,code:7,message:`Unsupported signature algorithm: ${v.digestAlgorithm.algorithmId}`,signerCertificate:g,signerCertificateVerified:!0});y=j.name;let P=this.encapContentInfo.eContent;if(P)P.idBlock.tagClass===1&&P.idBlock.tagNumber===4?t=P.getValue():t=P.valueBlock.valueBeforeDecodeView.slice().buffer;else if(t.byteLength===0)throw new Ce({date:a,code:8,message:"Missed detached data input array",signerCertificate:g,signerCertificateVerified:!0});if(v.signedAttrs){let B=!1,x=!1;for(let K of v.signedAttrs.attributes)if(K.type==="1.2.840.113549.1.9.3"&&(B=!0),K.type==="1.2.840.113549.1.9.4"&&(x=!0,b=K.values[0].valueBlock.valueHex),B&&x)break;if(B===!1)throw new Ce({date:a,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:g,signerCertificateVerified:!0});if(x===!1)throw new Ce({date:a,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0})}if(v.signedAttrs){let B=await m.digest(y,new Uint8Array(t));if(!is(B,b))throw new Ce({date:a,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0});t=v.signedAttrs.encodedValue}let V=v.signatureAlgorithm.algorithmId==="1.2.840.113549.1.1.1"?await m.verifyWithPublicKey(t,v.signature,g.subjectPublicKeyInfo,v.signatureAlgorithm,y):await m.verifyWithPublicKey(t,v.signature,g.subjectPublicKeyInfo,v.signatureAlgorithm);return u?{date:a,code:14,message:c,signatureVerified:V,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0,certificatePath:E}:V}catch(b){throw b instanceof Ce?b:new Ce({date:a,code:15,message:`Error during verification: ${b instanceof Error?b.message:b}`,signatureVerified:null,signerCertificate:g,timestampSerial:d,signerCertificateVerified:!0})}}async sign(e,t,s="SHA-1",a=we,r=q(!0)){var o;if(!e)throw new Error("Need to provide a private key for signing");let u=this.signerInfos[t];if(!u)throw new RangeError("SignerInfo index is out of range");!(!((o=u.signedAttrs)===null||o===void 0)&&o.attributes.length)&&"hash"in e.algorithm&&"hash"in e.algorithm&&e.algorithm.hash&&(s=e.algorithm.hash.name);let l=r.getOIDByAlgorithm({name:s},!0,"hashAlgorithm");this.digestAlgorithms.filter(d=>d.algorithmId===l).length===0&&this.digestAlgorithms.push(new S({algorithmId:l,algorithmParams:new le})),u.digestAlgorithm=new S({algorithmId:l,algorithmParams:new le});let h=await r.getSignatureParameters(e,s),m=h.parameters;if(u.signatureAlgorithm=h.signatureAlgorithm,u.signedAttrs)if(u.signedAttrs.encodedValue.byteLength!==0)a=u.signedAttrs.encodedValue;else{a=u.signedAttrs.toSchema().toBER();let d=H.BufferSourceConverter.toUint8Array(a);d[0]=49}else{let d=this.encapContentInfo.eContent;if(d)d.idBlock.tagClass===1&&d.idBlock.tagNumber===4?a=d.getValue():a=d.valueBlock.valueBeforeDecodeView.slice().buffer;else if(a.byteLength===0)throw new Error("Missed detached data input array")}let g=await r.signWithPrivateKey(a,e,m);u.signature=new I({valueHex:g})}};ss.CLASS_NAME="SignedData";ss.ID_DATA=Gh;var Ca="version",ka="authSafe",$t="macData",Bo="parsedValue",$v=[Ca,ka,$t],_h=class n extends C{constructor(e={}){super(),this.version=i(e,Ca,n.defaultValues(Ca)),this.authSafe=i(e,ka,n.defaultValues(ka)),$t in e&&(this.macData=i(e,$t,n.defaultValues($t))),Bo in e&&(this.parsedValue=i(e,Bo,n.defaultValues(Bo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ca:return 3;case ka:return new ce;case $t:return new at;case Bo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ca:return t===n.defaultValues(e);case ka:return ce.compareWithDefault("contentType",t.contentType)&&ce.compareWithDefault("content",t.content);case $t:return at.compareWithDefault("mac",t.mac)&&at.compareWithDefault("macSalt",t.macSalt)&&at.compareWithDefault("iterations",t.iterations);case Bo:return t instanceof Object&&Object.keys(t).length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.version||Ca}),ce.schema(t.authSafe||{names:{blockName:ka}}),at.schema(t.macData||{names:{blockName:$t,optional:!0}})]})}fromSchema(e){N(e,$v);let t=k(e,e,n.schema({names:{version:Ca,authSafe:{names:{blockName:ka}},macData:{names:{blockName:$t}}}}));A.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new ce({schema:t.result.authSafe}),$t in t.result&&(this.macData=new at({schema:t.result.macData}))}toSchema(){let e=[new w({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new f({value:e})}toJSON(){let e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=q(!0)){if(se.assert(e,"parameters","object"),!this.parsedValue)throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(Q.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),Q.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new Q("iterations");Q.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),Q.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),Q.assertEmpty(e.password,"password");let s=new ArrayBuffer(64),a=new Uint8Array(s);t.getRandomValues(a);let r=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new ce({contentType:ce.DATA,content:new I({valueHex:r})});let o=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:s,iterationCount:e.iterations,contentToStamp:r});this.macData=new at({mac:new wt({digestAlgorithm:new S({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new I({valueHex:o})}),macSalt:new I({valueHex:s}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new Q("signingCertificate");Q.assertEmpty(e.privateKey,"privateKey"),Q.assertEmpty(e.hashAlgorithm,"hashAlgorithm");let s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),a=new ss({version:1,encapContentInfo:new St({eContentType:"1.2.840.113549.1.7.1",eContent:new I({valueHex:s})}),certificates:[e.signingCertificate]}),r=await t.digest({name:e.hashAlgorithm},new Uint8Array(s)),o=[];o.push(new fe({type:"1.2.840.113549.1.9.3",values:[new O({value:"1.2.840.113549.1.7.1"})]})),o.push(new fe({type:"1.2.840.113549.1.9.5",values:[new ct({valueDate:new Date})]})),o.push(new fe({type:"1.2.840.113549.1.9.4",values:[new I({valueHex:r})]})),a.signerInfos.push(new qa({version:1,sid:new be({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new Be({type:0,attributes:o})})),await a.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new ce({contentType:"1.2.840.113549.1.7.2",content:a.toSchema(!0)})}break;default:throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=q(!0)){switch(se.assert(e,"parameters","object"),e.checkIntegrity===void 0&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case ce.DATA:{Q.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,se.assert(this.authSafe.content,"authSafe.content",I);let s=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=Qi.fromBER(s),e.checkIntegrity){if(!this.macData)throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');let a=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm");if(!await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:a.name,salt:Ii.BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||1,contentToVerify:s,signatureToVerify:Ii.BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)}))throw new Error("Integrity for the PKCS#12 data is broken!")}}break;case ce.SIGNED_DATA:{this.parsedValue.integrityMode=1;let s=new ss({schema:this.authSafe.content}),a=s.encapContentInfo.eContent;Q.assert(a,"eContent","cmsSigned.encapContentInfo"),se.assert(a,"eContent",I);let r=a.getValue();if(this.parsedValue.authenticatedSafe=Qi.fromBER(r),!await s.verify({signer:0,checkChain:!1},t))throw new Error("Integrity for the PKCS#12 data is broken!")}break;default:throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}};_h.CLASS_NAME="PFX";var wi="status",Xs="statusStrings",zs="failInfo",Jv=[wi,Xs,zs],pm;(function(n){n[n.granted=0]="granted",n[n.grantedWithMods=1]="grantedWithMods",n[n.rejection=2]="rejection",n[n.waiting=3]="waiting",n[n.revocationWarning=4]="revocationWarning",n[n.revocationNotification=5]="revocationNotification"})(pm||(pm={}));var an=class n extends C{constructor(e={}){super(),this.status=i(e,wi,n.defaultValues(wi)),Xs in e&&(this.statusStrings=i(e,Xs,n.defaultValues(Xs))),zs in e&&(this.failInfo=i(e,zs,n.defaultValues(zs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wi:return 2;case Xs:return[];case zs:return new F;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case wi:return t===n.defaultValues(e);case Xs:return t.length===0;case zs:return t.isEqual(n.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||c,value:[new w({name:t.status||c}),new f({optional:!0,value:[new _({name:t.statusStrings||c,value:new Te})]}),new F({name:t.failInfo||c,optional:!0})]})}fromSchema(e){N(e,Jv);let t=k(e,e,n.schema({names:{status:wi,statusStrings:Xs,failInfo:zs}}));A.assertSchema(t,this.className);let s=t.result.status;if(s.valueBlock.isHexOnly===!0||s.valueBlock.valueDec<0||s.valueBlock.valueDec>5)throw new Error('PKIStatusInfo "status" has invalid value');this.status=s.valueBlock.valueDec,Xs in t.result&&(this.statusStrings=t.result.statusStrings),zs in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){let e=[];return e.push(new w({value:this.status})),this.statusStrings&&e.push(new f({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new f({value:e})}toJSON(){let e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,t=>t.toJSON())),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}};an.CLASS_NAME="PKIStatusInfo";var Au="version",bu="messageImprint",Si="reqPolicy",yi="nonce",Jt="certReq",Ai="extensions",Fa="TimeStampReq",vm=`${Fa}.${Au}`,wm=`${Fa}.${bu}`,wh=`${Fa}.${Si}`,Sh=`${Fa}.${yi}`,yh=`${Fa}.${Jt}`,Ah=`${Fa}.${Ai}`,Fv=[vm,wm,wh,Sh,yh,Ah],Kh=class n extends C{constructor(e={}){super(),this.version=i(e,Au,n.defaultValues(Au)),this.messageImprint=i(e,bu,n.defaultValues(bu)),Si in e&&(this.reqPolicy=i(e,Si,n.defaultValues(Si))),yi in e&&(this.nonce=i(e,yi,n.defaultValues(yi))),Jt in e&&(this.certReq=i(e,Jt,n.defaultValues(Jt))),Ai in e&&(this.extensions=i(e,Ai,n.defaultValues(Ai))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Au:return 0;case bu:return new Me;case Si:return c;case yi:return new w;case Jt:return!1;case Ai:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Au:case Si:case Jt:return t===n.defaultValues(e);case bu:return Me.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&Me.compareWithDefault("hashedMessage",t.hashedMessage);case yi:return t.isEqual(n.defaultValues(e));case Ai:return t.length===0;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||Fa,value:[new w({name:t.version||vm}),Me.schema(t.messageImprint||{names:{blockName:wm}}),new O({name:t.reqPolicy||wh,optional:!0}),new w({name:t.nonce||Sh,optional:!0}),new Ke({name:t.certReq||yh,optional:!0}),new p({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:t.extensions||Ah,value:Ue.schema()})]})]})}fromSchema(e){N(e,Fv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.version=t.result[vm].valueBlock.valueDec,this.messageImprint=new Me({schema:t.result[wm]}),wh in t.result&&(this.reqPolicy=t.result[wh].valueBlock.toString()),Sh in t.result&&(this.nonce=t.result[Sh]),yh in t.result&&(this.certReq=t.result[yh].valueBlock.value),Ah in t.result&&(this.extensions=Array.from(t.result[Ah],s=>new Ue({schema:s})))}toSchema(){let e=[];return e.push(new w({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new O({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),Jt in this&&n.compareWithDefault(Jt,this.certReq)===!1&&e.push(new Ke({value:this.certReq})),this.extensions&&e.push(new p({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,t=>t.toSchema())})),new f({value:e})}toJSON(){let e={version:this.version,messageImprint:this.messageImprint.toJSON()};return this.reqPolicy!==void 0&&(e.reqPolicy=this.reqPolicy),this.nonce!==void 0&&(e.nonce=this.nonce.toJSON()),this.certReq!==void 0&&n.compareWithDefault(Jt,this.certReq)===!1&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,t=>t.toJSON())),e}};Kh.CLASS_NAME="TimeStampReq";var bi="status",Ci="timeStampToken",Jm="TimeStampResp",Sm=`${Jm}.${bi}`,bh=`${Jm}.${Ci}`,Gv=[Sm,bh],Mh=class n extends C{constructor(e={}){super(),this.status=i(e,bi,n.defaultValues(bi)),Ci in e&&(this.timeStampToken=i(e,Ci,n.defaultValues(Ci))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case bi:return new an;case Ci:return new ce;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case bi:return an.compareWithDefault(bi,t.status)&&!("statusStrings"in t)&&!("failInfo"in t);case Ci:return t.contentType===c&&t.content instanceof U;default:return super.defaultValues(e)}}static schema(e={}){let t=i(e,"names",{});return new f({name:t.blockName||Jm,value:[an.schema(t.status||{names:{blockName:Sm}}),ce.schema(t.timeStampToken||{names:{blockName:bh,optional:!0}})]})}fromSchema(e){N(e,Gv);let t=k(e,e,n.schema());A.assertSchema(t,this.className),this.status=new an({schema:t.result[Sm]}),bh in t.result&&(this.timeStampToken=new ce({schema:t.result[bh]}))}toSchema(){let e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new f({value:e})}toJSON(){let e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,s=q(!0)){return this.assertContentType(),new ss({schema:this.timeStampToken.content}).sign(e,0,t,void 0,s)}async verify(e={signer:0,trustedCerts:[],data:we},t=q(!0)){return this.assertContentType(),new ss({schema:this.timeStampToken.content}).verify(e,t)}assertContentType(){if(!this.timeStampToken)throw new Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==Pm)throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}};Mh.CLASS_NAME="TimeStampResp";function Wv(){if(typeof globalThis!="undefined"&&"crypto"in globalThis){let n="webcrypto";"webkitSubtle"in globalThis.crypto&&(n="safari"),Gf(n,new Oa({name:n,crypto:globalThis.crypto}))}else if(typeof crypto!="undefined"&&"webcrypto"in crypto){let n="NodeJS ^15",e=crypto.webcrypto;Gf(n,new Oa({name:n,crypto:e}))}}Wv();window.asn1js=gc;window.pkijs=Fm;})();
/*! Bundled license information:

pvtsutils/build/index.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

pkijs/build/index.es.js:
  (*!
   * Copyright (c) 2014, GlobalSign
   * Copyright (c) 2015-2019, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the {organization} nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)
*/
